<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring5源码分析[一]:从哪里开始看Spring源码</title>
      <link href="/2019/12/12/Spring5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-%E4%BB%8E%E5%93%AA%E9%87%8C%E5%BC%80%E5%A7%8B%E7%9C%8BSpring%E6%BA%90%E7%A0%81/"/>
      <url>/2019/12/12/Spring5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-%E4%BB%8E%E5%93%AA%E9%87%8C%E5%BC%80%E5%A7%8B%E7%9C%8BSpring%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring5源码分析-一-从哪里开始看Spring源码"><a href="#Spring5源码分析-一-从哪里开始看Spring源码" class="headerlink" title="Spring5源码分析[一]:从哪里开始看Spring源码"></a>Spring5源码分析[一]:从哪里开始看Spring源码</h2><ul><li>对于大多数第一次看spring源码的人来说，都会感觉不知从哪开始看起，因为spring项目源码由多个子项目组成，如spring-beans，spring-context，spring-core，spring-aop，spring-web，spring-webmvc等，整个项目结构如</li></ul><a id="more"></a><p><img src="/medias/article/images/2019/12/12/Spring5.jpg" alt></p><ul><li>可能有人会觉得，既然spring是一个IOC容器或者说是一个bean的容器，那么应该从spring-beans看起，先了解spring是如何从xml文件配置获取需要创建的bean的信息，但是这里有个问题就是虽然知道怎么遍历初始化，但是不知道哪里用到或者说哪里让这些初始化开始，而且像BeanFactory，FactoryBean，Environment，PropertySource等接口还是比较抽象的，比较难看懂，所以很容易让人感觉枯燥，然后就放弃了</li><li>我们可以换个思路，从能接触到的角度开始，即我们通常会使用spring-mvc来进行web开发，如@Controller，@RequestMapping都是再熟悉不过的了。如果搭过spring-mvc项目都知道，通常需要在web.xml文件中，配置一个ContextLoaderListener，contextConfigLocation，DispatcherServlet，可能很多人都是从网上copy了一份配置过来或者知道contextConfigLocation是指定spring配置文件的位置，DispatcherServlet是接收所有请求的前端控制器，需要指定拦截路由：“/”，从而拦截所有URL中带“/”的请求，但是在spring源码中是怎么使用这些组件的呢？以及怎么配置了一个@Controller，@RequestMapping中指定了一个url，就可以访问了呢？还有就是通常我们的web项目都会部署在web容器，如tomcat当中，那么tomcat和spring有啥关系呢？所以我们可以带着这些问题去查看spring源码找到答案。</li><li>所以我推荐是从spring-mvc开始看spring源码，因为这个是我们使用得比较多，比较容易理解的一个模块，然后一层一层往上剥，找到与spring-context，spring-beans，spring-aop等的关系。如果真的对JavaWeb开发，Java EE很感兴趣，或者更容易读懂spring的源码，可以先看servlet规范和Tomcat的设计与Tomcat的请求处理工作流。我目前也在结合这两个方面看，也可以看下我的Tomcat源码分析系列。</li></ul><h3 id="Servlet规范"><a href="#Servlet规范" class="headerlink" title="Servlet规范"></a>Servlet规范</h3><ul><li>在servlet的规范当中，servlet容器或者叫web容器，如tomcat，中运行的每个应用都由一个ServletContext表示，在web容器中可以包含多个ServletContext，即可以有多个web应用在web容器中运行。如在tomcat的webapp目录下，每个war包都对应一个web应用，tomcat启动时会解压war包，并启动相关的应用。</li><li>在web容器启动的时候，会初始化web应用，即创建ServletContext对象，加载解析web.xml文件，获取该应用的Filters，Listener，Servlet等组件的配置并创建对象实例，作为ServletContext的属性，保存在ServletContext当中。之后web容器接收到客户端请求时，则会根据请求信息，匹配到处理这个请求的Servlet，同时在交给servlet处理之前，会先使用应用配置的Filters对这个请求先进行过滤，最后才交给servlet处理。</li><li>了解web容器启动，之后接受客户端请求这些知识有啥用处呢？这里我们需要回过头来看我们的spring项目。我们在日常开发中，直接接触的是spring相关的组件，然后打成war包，放到web容器中，如拷贝到tomcat的webapp目录，并不会直接和web容器打交道。经过以上的分析，其实一个spring项目就是对应web容器里的一个ServletContext，所以在ServletContext对象的创建和初始化的时候，就需要一种机制来触发spring相关组件的创建和初始化，如包含@Controller和@RequestMapping注解的类和方法，这样才能处理请求。</li></ul><h3 id="Listener监听器机制：ContextLoaderListener"><a href="#Listener监听器机制：ContextLoaderListener" class="headerlink" title="Listener监听器机制：ContextLoaderListener"></a>Listener监听器机制：ContextLoaderListener</h3><ul><li><p>servlet规范当中，使用了Listener监听器机制来进行web容器相关组件的生命周期管理以及Event事件监听器来实现组件之间的交互。</p></li><li><p>其中一个重要的生命周期监听器是ServletContextListener。web容器在创建和初始化ServletContext的时候，会产生一个ServletContextEvent事件，其中ServletContextEvent包含该ServletContext的引用。然后交给在web.xml中配置的，注册到这个ServletContext的监听器ServletContextListener。ServletContextListener在其contextInitialized方法中定义处理逻辑，接口定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** Implementations of this interface receive notifications about changes to the* servlet context of the web application they are part of. To receive* notification events, the implementation class must be configured in the* deployment descriptor for the web application.** @see ServletContextEvent* @since v 2.3*/</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ServletContextListener</span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   ** Notification that the web application initialization process is starting.   * All ServletContextListeners are notified of context initialization before   * any filter or servlet in the web application is initialized.   * @param sce Information about the ServletContext that was initialized   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextInitialized</span><span class="token punctuation">(</span>ServletContextEvent sce<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   ** Notification that the servlet context is about to be shut down. All   * servlets and filters have been destroy()ed before any   * ServletContextListeners are notified of context destruction.   * @param sce Information about the ServletContext that was destroyed   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextDestroyed</span><span class="token punctuation">(</span>ServletContextEvent sce<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>从contextInitialized的注释可知：通知所有的ServletContextListeners，当前的web应用正在启动，而且这些ServletContextListeners是在Filters和Servlets创建之前接收到通知的。所以在这个时候，web应用还不能接收请求，故可以在这里完成底层处理请求的组件的加载，这样等之后接收请求的Filters和Servlets创建时，则可以使用这些创建好的组件了。spring相关的bean就是这里所说的底层处理请求的组件，如数据库连接池，数据库事务管理器等。</p></li><li><p>ContextLoaderListener：spring-web包的ContextLoaderListener就是一个ServletContextListener的实现类。ContextLoaderListener主要用来获取spring项目的整体配置信息，并创建对应的WebApplicationContext来保存bean的信息，以及创建这些bean的对象实例。默认去WEB-INF下加载applicationContext.xml配置，如果applicationContext.xml放在其他位置，或者使用其他不同的名称，或者使用多个xml文件，则与指定contextConfigLocation。具体spring源码的实现过程后续文章详细分析。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 修改配置文件路径 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:spring/applicationContext.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">></span></span></code></pre><h3 id="DispatcherServlet：前端控制器"><a href="#DispatcherServlet：前端控制器" class="headerlink" title="DispatcherServlet：前端控制器"></a>DispatcherServlet：前端控制器</h3></li><li><p>在web容器中，web.xml中的加载顺序：context-param -&gt; listener -&gt; filter -&gt; servlet。其中ContextLoaderListener是属于listener阶段。我们通常需要在项目的web.xml中配置一个DispatcherServlet，并配置拦截包含“/”路径的请求，即拦截所有请求。这样在web容器启动应用时，在servlet阶段会创建这个servlet，由Servlet规范中servlet的生命周期方法可知：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Servlet</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>ServletConfig var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">;</span>  ServletConfig <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span>ServletRequest var1<span class="token punctuation">,</span> ServletResponse var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException<span class="token punctuation">;</span>  String <span class="token function">getServletInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>web容器在创建这个servlet的时候，会调用其init方法，故可以在DispatcherServlet的init方法中定义初始化逻辑，核心实现了创建DispatcherServlet自身的一个WebApplicationContext，注意在spring中每个servlet可以包含一个独立的WebApplicationContext来维护自身的组件，而上面通过ContextLoaderListener创建的WebApplicationContext为共有的，通常也是最顶层，即root WebApplicationContext，servlet的WebApplicationContext可以通过setParent方法设值到自身的一个属性。DispatcherServlet默认是加载WEB-INF下面的“servletName”-servlet.xml，来获取配置信息的，也可以与ContextLoaderListener一样通过contextLoaderConfig来指定位置。DispatcherServlet具体的源码设计在之后文章详细分析。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>从上面的分析，可知spring相关配置解析和组件创建其实是在web容器中，启动一个web应用的时候，即在其ServletContext组件创建的时候，首先解析web.xml获取该应用配置的listeners列表和servlet列表，然后保存在自身的一个属性中，然后通过分发生命周期事件ServletContextEvent给这些listeners，从而在listeners感知到应用在启动了，然后自定义自身的处理逻辑，如spring的ContextLoaderListener就是解析spring的配置文件并创建相关的bean，这样其实也是实现了一种代码的解耦；其次是创建配置的servlet列表，调用servlet的init方法，这样servlet可以自定义初始化逻辑，DispatcherServlet就是其中一个servlet。</li><li>所以在ContextLoaderListener和DispatcherServlet的创建时，都会进行WebApplicationContext的创建，这里其实就是IOC容器的创建了，即会交给spring-context，spring-beans包相关的类进行处理了，故可以从这里作为一个入口，一层一层地剥spring的源码了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> Spring </category>
          
          <category> Spring5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows环境下安装 Gradle</title>
      <link href="/2019/12/09/windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%20Gradle/"/>
      <url>/2019/12/09/windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%20Gradle/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows环境下安装-Gradle"><a href="#Windows环境下安装-Gradle" class="headerlink" title="Windows环境下安装 Gradle"></a>Windows环境下安装 Gradle</h2><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言</p><p>由于在阅读Spring5 相关源码, 所以记录下Gradle载Windows环境下安装过程,毕竟少用Gradle</p><a id="more"></a><h3 id="下载Gradle"><a href="#下载Gradle" class="headerlink" title="下载Gradle"></a>下载Gradle</h3><p>在官网的版本 <a href="https://gradle.org/releases/" target="_blank" rel="noopener">发布页面</a> 找到 Download 的 binary-only 链接，点击即可下载了（后面的 complete 指的是完整版，我们只是使用的话并不需要下载那个<br><img src="/medias/article/images/2019/12/9/gradle.jpg" alt></p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>下载完成后，将文件解压出来<br><img src="/medias/article/images/2019/12/9/gradle-1.jpg" alt></p><p>现在，我们需要设置环境变量了</p><p>在 控制面板 &gt; 系统和安全 &gt; 系统 中找到 高级系统设置 项</p><ol><li>环境变量中增加名为GRADLE_HOME的变量名,值为Gralde的解压路径,例如D:\software\Gradle</li><li>在path的后追加%GRADLE_HOME%\bin;.<br><img src="/medias/article/images/2019/12/9/gradle-2.jpg" alt></li></ol><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p><code>Gradle -v</code></p><p><img src="/medias/article/images/2019/12/9/gradle-3.jpg" alt></p><h3 id="修改默认缓存目录"><a href="#修改默认缓存目录" class="headerlink" title="修改默认缓存目录"></a>修改默认缓存目录</h3><p>修改Gradle默认缓存目录可使用命令gradle -g 目录路径,例如gradle -g D:\software\Gradle.gradle</p><h3 id="修改全局默认仓库"><a href="#修改全局默认仓库" class="headerlink" title="修改全局默认仓库"></a>修改全局默认仓库</h3><pre class=" language-xml"><code class="language-xml">allprojects {    repositories {        maven {            url 'http://maven.aliyun.com/nexus/content/groups/public/'        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> z-Tools </category>
          
          <category> Gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化原则</title>
      <link href="/2019/11/29/MySQL%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99/"/>
      <url>/2019/11/29/MySQL%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>当MySQL单表记录数过大时，增删改查性能都会急剧下降，所以我们本文会提供一些优化参考，大家可以参考以下步骤来优化</p><h2 id="单表优化"><a href="#单表优化" class="headerlink" title="单表优化"></a>单表优化</h2><p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度。一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的，而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量。</p><a id="more"></a><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul><li>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED；</li><li>VARCHAR的长度只分配真正需要的空间；</li><li>使用枚举或整数代替字符串类型；</li><li>尽量使用TIMESTAMP而非DATETIME；</li><li>单表不要有太多字段，建议在20以内；</li><li>避免使用NULL字段，很难查询优化且占用额外索引空间；</li><li>用整型来存IP。</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描；</li><li>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描；</li><li>值分布很稀少的字段不适合建索引，例如“性别”这种只有两三个值的字段；</li><li>字符字段只建前缀索引；</li><li>字符字段最好不要做主键；</li><li>不用外键，由程序保证约束；</li><li>尽量不用UNIQUE，由程序保证约束；</li><li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引。</li></ul><h3 id="查询SQL"><a href="#查询SQL" class="headerlink" title="查询SQL"></a>查询SQL</h3><ul><li>可通过开启慢查询日志来找出较慢的SQL；</li><li>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边；</li><li>sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库；</li><li>不用SELECT *；</li><li>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，IN的个数建议控制在200以内；</li><li>不用函数和触发器，在应用程序实现；</li><li>避免%xxx式查询；</li><li>少用JOIN；</li><li>使用同类型进行比较，比如用’123’和’123’比，123和123比；</li><li>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描；</li><li>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5；</li><li>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大。</li></ul><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>目前广泛使用的是MyISAM和InnoDB两种引擎：<br><strong>MyISAM</strong><br>MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</p><ul><li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁；</li><li>不支持事务；</li><li>不支持外键；</li><li>不支持崩溃后的安全恢复；</li><li>在表有读取查询的同时，支持往表中插入新纪录；</li><li>支持BLOB和TEXT的前500个字符索引，支持全文索引；</li><li>支持延迟更新索引，极大提升写入性能；</li><li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用。</li></ul><p><strong>InnoDB</strong><br>InnoDB在MySQL 5.5后成为默认索引，它的特点是：</p><ul><li>支持行锁，采用MVCC来支持高并发；</li><li>支持事务；</li><li>支持外键；</li><li>支持崩溃后的安全恢复；</li><li>不支持全文索引。<br><code>InnoDB已经在MySQL 5.6.4支持全文索引了</code><br>总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表。</li></ul><h3 id="系统调优参数"><a href="#系统调优参数" class="headerlink" title="系统调优参数"></a>系统调优参数</h3><p>可以使用下面几个工具来做基准测试：</p><ul><li><strong>sysbench</strong>：一个模块化，跨平台以及多线程的性能测试工具。<br><a href="https://github.com/akopytov/sysbench" target="_blank" rel="noopener">https://github.com/akopytov/sysbench</a></li><li><strong>iibench-mysql</strong>：基于Java的MySQL / Percona / MariaDB 索引进行插入性能测试工具。<br><a href="https://github.com/tmcallaghan/iibench-mysql" target="_blank" rel="noopener">https://github.com/tmcallaghan/iibench-mysql</a></li><li><strong>tpcc-mysql</strong>：Percona开发的TPC-C测试工具。<br><a href="https://github.com/Percona-Lab/tpcc-mysql" target="_blank" rel="noopener">https://github.com/Percona-Lab/tpcc-mysql</a></li></ul><p>具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：</p><ul><li><strong>back_log</strong>：back_log值可以指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500。</li><li><strong>wait_timeout</strong>：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时。</li><li><strong>max_user_connection</strong>：最大连接数，默认为0无上限，最好设一个合理上限。</li><li><strong>thread_concurrency</strong>：并发线程数，设为CPU核数的两倍。</li><li><strong>skip_name_resolve</strong>：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问。</li><li><strong>key_buffer_size</strong>：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询show status like ‘key_read%’，保证key_reads / key_read_requests在0.1%以下最好</li><li><strong>innodb_buffer_pool_size</strong>：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like ‘Innodb_buffer_pool_read%’，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests越高越好。</li><li><strong>query_cache_size</strong>：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们数据变化非常频繁的情况下，使用Query Cache可能得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大。可以通过命令show status like ‘Qcache_%’查看目前系统Query catch使用大小。</li><li><strong>read_buffer_size</strong>：MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能。</li><li><strong>sort_buffer_size</strong>：MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小。</li><li><strong>read_rnd_buffer_size</strong>：MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</li><li><strong>record_buffer</strong>：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值。</li><li><strong>thread_cache_size</strong>：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的。</li><li><strong>table_cache</strong>：类似于thread_cache _size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM。</li></ul><h3 id="升级硬件"><a href="#升级硬件" class="headerlink" title="升级硬件"></a>升级硬件</h3><p>Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能。</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存可以发生在这些层次：</p><ul><li><strong>MySQL内部</strong>：在系统调优参数介绍了相关设置；</li><li><strong>数据访问层</strong>：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象Persistence Object；</li><li><strong>应用服务层</strong>：可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象Data Transfer Object；</li><li><strong>Web层</strong>：针对web页面做缓存；</li><li><strong>浏览器客户端</strong>：用户端的缓存。</li></ul><p>可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式：</p><ul><li><strong>直写式（Write Through）</strong>：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。</li><li><strong>回写式（Write Back）</strong>：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。</li></ul><h2 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h2><p>MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。</p><p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。<br><img src="/medias/article/images/2019/11/29/mysql-1.jpg" alt="表分区"><br>用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：</p><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> partitions <span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> user_partition <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span>          <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>     <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> Extra                    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> user_partition <span class="token operator">|</span> p1<span class="token punctuation">,</span>p4      <span class="token operator">|</span> range <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>       <span class="token operator">|</span> <span class="token keyword">PRIMARY</span> <span class="token operator">|</span> <span class="token number">8</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">5</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span></code></pre><h3 id="分区的好处是"><a href="#分区的好处是" class="headerlink" title="分区的好处是"></a>分区的好处是</h3><p>可以让单表存储更多的数据；</p><ul><li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据，另外，还可以对一个独立分区进行优化、检查、修复等操作；</li><li>部分查询能够从查询条件确定只落在少数分区上，速度会很快；</li><li>分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备；</li><li>可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争；</li><li>可以备份和恢复单个分区。</li></ul><h3 id="分区的限制和缺点"><a href="#分区的限制和缺点" class="headerlink" title="分区的限制和缺点"></a>分区的限制和缺点</h3><ul><li><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。</li><li><strong>LIST分区</strong>：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。</li><li><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式。</li><li><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</li></ul><h4 id="分区适合的场景有"><a href="#分区适合的场景有" class="headerlink" title="分区适合的场景有"></a>分区适合的场景有</h4><p>最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> members <span class="token punctuation">(</span>    firstname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    lastname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    joined <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>joined<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1960</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1970</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1980</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1990</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。</p><ul><li>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存。<br>另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代。</li></ul><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p>垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。</p><p>垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。</p><p>比如原始的用户表是：<br><img src="/medias/article/images/2019/11/29/user.jpg" alt><br>垂直拆分后是：<br><img src="/medias/article/images/2019/11/29/user-1.jpg" alt><br><strong>垂直拆分的优点是：</strong></p><ul><li>可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)；</li><li>可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起；</li><li>数据维护简单。</li></ul><p><strong>缺点是：</strong></p><ul><li>主键出现冗余，需要管理冗余列；</li><li>会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力；</li><li>依然存在单表数据量过大的问题（需要水平拆分）。</li><li>事务处理复杂。</li></ul><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表。</p><p>库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决。</p><p>前面垂直拆分的用户表如果进行水平拆分，结果是：<br><img src="/medias/article/images/2019/11/29/user-2.jpg" alt><br>实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表。<br><strong>水平拆分的优点是：</strong></p><ul><li>不存在单库大数据和高并发的性能瓶颈；</li><li>应用端改造较少；</li><li>提高了系统的稳定性和负载能力。</li></ul><p><strong>缺点是：</strong></p><ul><li>分片事务一致性难以解决；</li><li>跨节点Join性能差，逻辑复杂；</li><li>数据多次扩展难度跟维护量极大</li></ul><h3 id="分片原则"><a href="#分片原则" class="headerlink" title="分片原则"></a>分片原则</h3><ul><li>能不分就不分，参考单表优化；</li><li>分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量；</li><li>分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容；</li><li>尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题；</li><li>查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引；</li><li>通过数据冗余和表分区赖降低跨库Join的可能。</li></ul><p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p><p>总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p><p><strong>客户端架构</strong><br>通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现。</p><p>这是一个客户端架构的例子：<br><img src="/medias/article/images/2019/11/29/user-3.jpg" alt><br>可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现。</p><p><strong>客户端架构的优点是</strong>：</p><ul><li>应用直连数据库，降低外围系统依赖所带来的宕机风险；</li><li>集成成本低，无需额外运维的组件。</li></ul><p><strong>缺点是</strong>：</p><ul><li>限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心；</li><li>将分片逻辑的压力放在应用服务器上，造成额外风险。</li></ul><p><strong>代理架构</strong><br>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件。</p><p>这是一个代理架构的例子：<br><img src="/medias/article/images/2019/11/29/user-4.jpg" alt><br>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理。<br><strong>代理架构的优点是</strong>：</p><ul><li>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强；</li><li>对于应用服务器透明且没有增加任何额外负载。</li></ul><p><strong>缺点是</strong>：</p><ul><li>需部署和运维独立的代理中间件，成本高；</li><li>应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险。</li></ul><p>目前来说，业界还是有很多的方案可供选择，但应该如何进行选择？我认为，可以按以下思路来考虑：</p><ul><li>确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构。</li><li>具体功能是否满足，比如需要跨节点ORDER BY，那么支持该功能的优先考虑。</li><li>不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持。</li><li>最好按大公司→社区→小公司→个人这样的出品方顺序来选择。</li><li>选择口碑较好的，比如github星数、使用者数量质量和使用者反馈。</li><li>开源的优先，往往项目有特殊需求可能需要改动源代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面了解mysql中utf8和utf8mb4的区别</title>
      <link href="/2019/11/29/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3mysql%E4%B8%ADutf8%E5%92%8Cutf8mb4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/29/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3mysql%E4%B8%ADutf8%E5%92%8Cutf8mb4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了。</p><h2 id="内容描述"><a href="#内容描述" class="headerlink" title="内容描述"></a>内容描述</h2><p>那上面说了既然utf8能够存下大部分中文汉字,那为什么还要使用utf8mb4呢? <code>原来mysql支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了</code>。三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xffff，也就是 Unicode 中的基本多文种平面（BMP）。也就是说，任何不在基本多文本平面的 Unicode字符，都无法使用 Mysql 的 utf8 字符集存储。包括 Emoji 表情（Emoji 是一种特殊的 Unicode 编码，常见于 ios 和android 手机上），和很多不常用的汉字，以及任何新增的 Unicode 字符等等。</p><a id="more"></a><h2 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h2><ul><li>最初的 UTF-8 格式使用一至六个字节，最大能编码 31 位字符。最新的 UTF-8 规范只使用一到四个字节，最大能编码21位，正好能够表示所有的 17个 Unicode 平面</li><li>utf8 是 Mysql 中的一种字符集，只支持最长三个字节的 UTF-8字符，也就是 Unicode 中的基本多文本平面。</li><li>Mysql 中的 utf8 为什么只支持持最长三个字节的 UTF-8字符呢？可能是因为 Mysql 刚开始开发那会，Unicode 还没有辅助平面这一说呢。那时候，Unicode 委员会还做着 “65535 个字符足够全世界用了”的美梦。Mysql 中的字符串长度算的是字符数而非字节数，对于 CHAR 数据类型来说，需要为字符串保留足够的长。<strong>当使用 utf8 字符集时，需要保留的长度就是 utf8 最长字符长度乘以字符串长度</strong>所以这里理所当然的限制了 utf8 最大长度为 3，比如 CHAR(100) Mysql 会保留 300字节长度。至于后续的版本为什么不对 4 字节长度的 UTF-8 字符提供支持，我想一个是为了向后兼容性的考虑，还有就是基本多文种平面之外的字符确实很少用到。</li><li>要在 Mysql 中保存 4 字节长度的 UTF-8 字符，需要使用 utf8mb4 字符集，但只有 5.5.3 版本以后的才支持（查看版本： select version();）。我觉得，为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8. <strong>对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 Mysql 官方建议，使用 VARCHAR 替代 CHAR</strong>。</li></ul><h2 id="utf8升级utf8mb4问题"><a href="#utf8升级utf8mb4问题" class="headerlink" title="utf8升级utf8mb4问题"></a>utf8升级utf8mb4问题</h2><p><strong>utf8mb4 字符集(4字节 UTF-8 Unicode 编码)</strong></p><ul><li>UTF-8字符集每个字符最多使用三个字节，并且只包含基本多语言面 (Basic Multilingual Plane,BMP)字符。</li><li>utf8mb4 字符集使用最多每字符四个字节支持补充字符：</li><li>对于 BMP字符 UTF8 和 utf8mb4 具有相同的存储特性：相同的代码值，相同的编码，相同的长度。</li><li>对于补充字符，UTF8不能储存所有的字符，而utf8mb4需要四个字节来存储它。因为UTF8不能存储所有的字符，你的 utf8 列中都没有补充字符，<strong>因此从旧版本的MySQL UTF8 升级数据时 不用担心字符转换或丢失数据</strong>。</li><li>utf8mb4 是 utf8 的超集，所以像下面的连接字符串操作，其结果字符集是 utf8mb4  排序规则（一组规则，定义如何对字符串进行比较和排序）是 utf8mb4_col<pre class=" language-java"><code class="language-java">SELECT <span class="token function">CONCAT</span><span class="token punctuation">(</span>utf8_col<span class="token punctuation">,</span> utf8mb4_col<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>同样，下面的 WHERE 子句中的内容比较根据 utf8mb4_col 规则：<pre class=" language-java"><code class="language-java">SELECT <span class="token operator">*</span> FROM utf8_tbl<span class="token punctuation">,</span> utf8mb4_tbl  WHERE utf8_tbl<span class="token punctuation">.</span>utf8_col <span class="token operator">=</span> utf8mb4_tbl<span class="token punctuation">.</span>utf8mb4_col<span class="token punctuation">;</span>  </code></pre>如上面所说到的：<strong>要使用 utf8mb4 节省空间，使用 VARCHAR 替换 CHAR</strong>。否则，MySQL必须为使用 utf8mb4字符集的列的每一个字符保留四字节的空间，因为其最大长度可能是四字节。例如，MySQL必须为一个使用 utf8mb4 字符集的  char（10）的列保留40字节空间。</li></ul><h2 id="utf8升级utf8mb4具体步骤"><a href="#utf8升级utf8mb4具体步骤" class="headerlink" title="utf8升级utf8mb4具体步骤"></a>utf8升级utf8mb4具体步骤</h2><p>首先将我们数据库默认字符集由utf8 更改为utf8mb4，对应的表默认字符集也更改为utf8mb4  已经存储表情的字段默认字符集也做了相应的调整。</p><p>SQL 语句</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 修改数据库:  </span><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> database_name <span class="token keyword">CHARACTER SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_unicode_ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 修改表:  </span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">CONVERT</span> <span class="token keyword">TO</span> <span class="token keyword">CHARACTER SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 修改表字段:  </span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name CHANGE column_name column_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">191</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci<span class="token punctuation">;</span> </code></pre><p>修改MySQL配置文件<br>新增如下参数：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">default</span><span class="token operator">-</span>character<span class="token operator">-</span><span class="token keyword">set</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">default</span><span class="token operator">-</span>character<span class="token operator">-</span><span class="token keyword">set</span> <span class="token operator">=</span> utf8mb4    character<span class="token operator">-</span><span class="token keyword">set</span><span class="token operator">-</span>client<span class="token operator">-</span>handshake <span class="token operator">=</span> <span class="token boolean">FALSE</span>  character<span class="token operator">-</span><span class="token keyword">set</span><span class="token operator">-</span>server <span class="token operator">=</span> utf8mb4  collation<span class="token operator">-</span>server <span class="token operator">=</span> utf8mb4_unicode_ci  init_connect<span class="token operator">=</span><span class="token string">'SET NAMES utf8mb4'</span></code></pre><p>检查环境变量 和测试 SQL 如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token keyword">WHERE</span> Variable_name <span class="token operator">LIKE</span> <span class="token string">'character\_set\_%'</span> <span class="token operator">OR</span> Variable_name <span class="token operator">LIKE</span> <span class="token string">'collation%'</span><span class="token punctuation">;</span>  </code></pre><p><strong>注意：MySQL版本必须为5.5.3以上版本，否则不支持字符集utf8mb4</strong></p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>建议普通表使用utf8， 如果这个表需要支持emoji就使用utf8mb4</li><li>新建mysql库或者表的时候还有一个排序规则</li><li>utf8_unicode_ci比较准确，utf8_general_ci速度比较快。通常情况下 utf8_general_ci的准确性就够我们用的了，在我看过很多程序源码后，发现它们大多数也用的是utf8_general_ci，所以新建数据 库时一般选用utf8_general_ci就可以了</li><li>如果是utf8mb4那么对应的就是 utf8mb4_general_ci utf8mb4_unicode_ci</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解@LoadBalanced注解的实现原理</title>
      <link href="/2019/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3@LoadBalanced%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3@LoadBalanced%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>在阅读这篇博客之前,希望你对SpringCloud套件熟悉和理解,更希望关注下<a href="https://gitee.com/ibyte/M-Pass" target="_blank" rel="noopener">微服务开发平台</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在使用springcloud ribbon客户端负载均衡的时候，可以给RestTemplate bean 加一个@LoadBalanced注解，就能让这个RestTemplate在请求时拥有客户端负载均衡的能力,先前有细嚼过但是没有做过笔记,刚好处理此类问题记录下</p><a id="more"></a><h2 id="LoadBalanced"><a href="#LoadBalanced" class="headerlink" title="@LoadBalanced"></a>@LoadBalanced</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 注释将RestTemplate bean标记为配置为使用LoadBalancerClient。 */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>PARAMETER<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Qualifier</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">LoadBalanced</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>通过源码可以发现这是一个<code>LoadBalanced</code>标记注解并且标记了<code>@Qualifier</code>(基于Spring Boot的自动配置机制),我们可以溯源到<code>LoadBalancerAutoConfiguration</code></p><h3 id="LoadBalancerAutoConfiguration"><a href="#LoadBalancerAutoConfiguration" class="headerlink" title="LoadBalancerAutoConfiguration"></a>LoadBalancerAutoConfiguration</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 功能区的自动配置（客户端负载平衡） */</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span>LoadBalancerClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>LoadBalancerRetryProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadBalancerAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@LoadBalanced</span>    <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>RestTemplate<span class="token operator">></span> restTemplates <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//这里持有@LoadBalanced标记的RestTemplate实例</span>    <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>LoadBalancerRequestTransformer<span class="token operator">></span> transformers <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> SmartInitializingSingleton <span class="token function">loadBalancedRestTemplateInitializerDeprecated</span><span class="token punctuation">(</span>            <span class="token keyword">final</span> ObjectProvider<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>RestTemplateCustomizer<span class="token operator">>></span> restTemplateCustomizers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> restTemplateCustomizers<span class="token punctuation">.</span><span class="token function">ifAvailable</span><span class="token punctuation">(</span>customizers <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>RestTemplate restTemplate <span class="token operator">:</span> LoadBalancerAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>restTemplates<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>RestTemplateCustomizer customizer <span class="token operator">:</span> customizers<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//为restTemplate添加定制</span>                    customizer<span class="token punctuation">.</span><span class="token function">customize</span><span class="token punctuation">(</span>restTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// ... </span>    <span class="token comment" spellcheck="true">/**     * 以下针对classpath存在RetryTemplate.class的情况配置，先忽略     */</span>    <span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>RetryTemplate<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">RetryAutoConfiguration</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>        <span class="token annotation punctuation">@ConditionalOnMissingBean</span>        <span class="token keyword">public</span> LoadBalancedRetryFactory <span class="token function">loadBalancedRetryFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LoadBalancedRetryFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// ... </span><span class="token punctuation">}</span></code></pre><p><code>@LoadBalanced</code>和<code>@Autowried</code>结合使用,意思就是这里注入的<code>RestTempate</code> Bean是所有加有<code>@LoadBalanced</code>注解标记的(持有<code>@LoadBalanced</code>标记的RestTemplate实例)</p><p>这段自动装配的代码的含义不难理解，就是利用了RestTempllate的拦截器，使用RestTemplateCustomizer对所有标注了@LoadBalanced的RestTemplate Bean添加了一个LoadBalancerInterceptor拦截器，而这个拦截器的作用就是对请求的URI进行转换获取到具体应该请求哪个服务实例ServiceInstance。</p><p><strong>关键问下自己：为什么？</strong></p><ul><li>RestTemplate实例是怎么被收集的？</li><li>怎样通过负载均衡规则获取具体的具体的server？</li></ul><p>继续扒看源码&gt;<br>上面可以看出，会<code>LoadBalancerAutoConfiguration类</code>对我们加上<code>@LoadBalanced</code>注解的bean 添加<code>loadBalancerInterceptor</code>拦截器</p><h3 id="LoadBalancerInterceptor"><a href="#LoadBalancerInterceptor" class="headerlink" title="LoadBalancerInterceptor"></a>LoadBalancerInterceptor</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 功能区的自动配置（客户端负载平衡）。*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadBalancerInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">ClientHttpRequestInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> LoadBalancerClient loadBalancer<span class="token punctuation">;</span>    <span class="token keyword">private</span> LoadBalancerRequestFactory requestFactory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LoadBalancerInterceptor</span><span class="token punctuation">(</span>LoadBalancerClient loadBalancer<span class="token punctuation">,</span>            LoadBalancerRequestFactory requestFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadBalancer <span class="token operator">=</span> loadBalancer<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>requestFactory <span class="token operator">=</span> requestFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">LoadBalancerInterceptor</span><span class="token punctuation">(</span>LoadBalancerClient loadBalancer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// for backwards compatibility</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>loadBalancer<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LoadBalancerRequestFactory</span><span class="token punctuation">(</span>loadBalancer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ClientHttpResponse <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token keyword">final</span> HttpRequest request<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">,</span>            <span class="token keyword">final</span> ClientHttpRequestExecution execution<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">final</span> URI originalUri <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String serviceName <span class="token operator">=</span> originalUri<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>serviceName <span class="token operator">!=</span> null<span class="token punctuation">,</span>                <span class="token string">"Request URI does not contain a valid hostname: "</span> <span class="token operator">+</span> originalUri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadBalancer<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>serviceName<span class="token punctuation">,</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>requestFactory<span class="token punctuation">.</span><span class="token function">createRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> body<span class="token punctuation">,</span> execution<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>重点看intercept方法 当我们restTemplate执行请求操作时，就会被拦截器拦截进入intercept方法,而loadBalancer是LoadBalancerClient的具体实现</p><h3 id="RibbonLoadBalancerClient"><a href="#RibbonLoadBalancerClient" class="headerlink" title="RibbonLoadBalancerClient"></a>RibbonLoadBalancerClient</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">execute</span><span class="token punctuation">(</span>String serviceId<span class="token punctuation">,</span> LoadBalancerRequest<span class="token operator">&lt;</span>T<span class="token operator">></span> request<span class="token punctuation">,</span> Object hint<span class="token punctuation">)</span>            <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        ILoadBalancer loadBalancer <span class="token operator">=</span> <span class="token function">getLoadBalancer</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>        Server server <span class="token operator">=</span> <span class="token function">getServer</span><span class="token punctuation">(</span>loadBalancer<span class="token punctuation">,</span> hint<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"No instances available for "</span> <span class="token operator">+</span> serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        RibbonServer ribbonServer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RibbonServer</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">,</span> server<span class="token punctuation">,</span>                <span class="token function">isSecure</span><span class="token punctuation">(</span>server<span class="token punctuation">,</span> serviceId<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token function">serverIntrospector</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">execute</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">,</span> ribbonServer<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>看到这里相信都遇到过类似的错误，恍然大悟</p><pre class=" language-java"><code class="language-java">No instances available <span class="token keyword">for</span>  xxxxx</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>1.根据serviceId 获取对应的loadBalancer</li><li>2.根据loadBalancer获取具体的server（这里根据负载均衡规则，获取到具体的服务实例）</li><li>3.创建RibbonServer</li><li>4.执行具体请求</li></ul><p>这里</p><blockquote><p>注意: @LoadBalanced 标记注解获取到最后通过负载均衡规则获取具体的具体的server来发起请求</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 服务注册中心配置 * * @author &lt;a href="mailto:shangzhi.ibyte@gmail.com">iByte&lt;/a> * @since 1.0.1 */</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>ModuleMappingHelper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiscoveryConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    Environment environment<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * DiscoveryHeaderHelper默认bean     * @return     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DiscoveryHeaderHelper <span class="token function">discoveryHeaderHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        DiscoveryHeaderHelper discoveryHeaderHelper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DiscoveryHeaderHelper</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>        DiscoveryHeaderHelper<span class="token punctuation">.</span>INSTANCE <span class="token operator">=</span> discoveryHeaderHelper<span class="token punctuation">;</span>        <span class="token keyword">return</span> discoveryHeaderHelper<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * resttemplate构建     */</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> RestTemplateBuilder restTemplateBuilder<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * resttemplate请求bean,更改系统本身的builder     * @return     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@LoadBalanced</span>    <span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        RestTemplate restTemplate <span class="token operator">=</span> restTemplateBuilder<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//RestTemplate interceptors 远程调用请求增加头部信息处理</span>        restTemplate<span class="token punctuation">.</span><span class="token function">getInterceptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RestApiHeaderInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//RestTemplate Set the error handler 错误处理</span>        restTemplate<span class="token punctuation">.</span><span class="token function">setErrorHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RestResponseErrorHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  restTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DiscoveryClient<span class="token punctuation">.</span>DiscoveryClientOptionalArgs <span class="token function">discoveryClientOptionalArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        DiscoveryClient<span class="token punctuation">.</span>DiscoveryClientOptionalArgs discoveryClientOptionalArgs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DiscoveryClient<span class="token punctuation">.</span>DiscoveryClientOptionalArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        discoveryClientOptionalArgs<span class="token punctuation">.</span><span class="token function">setAdditionalFilters</span><span class="token punctuation">(</span>Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DiscoveryHeaderClientFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        discoveryClientOptionalArgs<span class="token punctuation">.</span><span class="token function">setEventListeners</span><span class="token punctuation">(</span>Collections<span class="token punctuation">.</span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EurekaClientEventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> discoveryClientOptionalArgs<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>源码地址 &gt;  <a href="https://gitee.com/ibyte/M-Pass/blob/master/framework/framework-discovery-api/src/main/java/com/ibyte/framework/discovery/DiscoveryConfig.java" target="_blank" rel="noopener">DiscoveryConfig</a></p>]]></content>
      
      
      <categories>
          
          <category> mPass </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Ribbon </tag>
            
            <tag> LoadBalanced </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码分析</title>
      <link href="/2019/11/13/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/11/13/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>在阅读这篇博客之前，希望你对HashMap已经是有所理解的，如果你对java的cas操作也是有一定了解的，因为在这个类中大量使用到了cas相关的操作来保证线程安全的。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ConcurrentHashMap这个类在java.lang.current包中，这个包中的类都是线程安全的。ConcurrentHashMap底层存储数据的结构与1.8的HashMap是一样的，都是数组+链表（或红黑树）的结构。在日常的开发中，我们最长用到的键值对存储结构的是HashMap，但是我们知道，这个类是非线程安全的，在高并发的场景下，在进行put操作的时候有可能进入死循环从而使服务器的cpu使用率达到100%；sun公司因此也给出了与之对应的线程安全的类。</p><a id="more"></a><p>在jdk1.5以前，使用的是HashTable，这个类为了保证线程安全，在每个类中都添加了synchronized关键字，而想而知在高并发的情景下相率是非常低下的。为了解决HashTable效率低下的问题，官网在jdk1.5后推出了ConcurrentHashMap来替代饱受诟病的HashTable。jdk1.5后ConcurrentHashMap使用了分段锁的技术。在整个数组中被分为多个segment，每次get，put，remove操作时就锁住目标元素所在的segment中，因此segment与segment之前是可以并发操作的，上述就是jdk1.5后实现线程安全的大致思想。但是，从描述中可以看出一个问题，就是如果出现比较机端的情况，所有的数据都集中在一个segment中的话，在并发的情况下相当于锁住了全表，这种情况下其实是和HashTable的效率出不多的，但总体来说相较于HashTable，效率还是有了很大的提升。jdk1.8后，ConcurrentHashMap摒弃了segment的思想，转而使用cas+synchronized组合的方式来实现并发下的线程安全的，这种实现方式比1.5的效率又有了比较大的提升</p><h2 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h2><ol><li>ziseCtr：在多个方法中出现过这个变量，该变量主要是用来控制数组的初始化和扩容的，默认值为0，可以概括一下4种状态：<ul><li>a、sizeCtr=0：默认值；</li><li>b、sizeCtr=-1：表示Map正在初始化中；</li><li>c、sizeCtr=-N：表示正在有N-1个线程进行扩容操作；</li><li>d、sizeCtr&gt;0: 未初始化则表示初始化Map的大小，已初始化则表示下次进行扩容操作的阈值；</li></ul></li><li>table：用于存储链表或红黑数的数组，初始值为null，在第一次进行put操作的时候进行初始化，默认值为16；</li><li>nextTable：在扩容时新生成的数组，其大小为当前table的2倍，用于存放table转移过来的值；</li><li>Node：该类存储数据的核心，以key-value形式来存储；</li><li>ForwardingNode：这是一个特殊Node节点，仅在进行扩容时用作占位符，表示当前位置已被移动或者为null，该node节点的hash值为-1；</li></ol><h2 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Implementation for put and putIfAbsent */</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Boolean onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//key和value不能为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过key来计算获得hash值</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用于计算数组位置上存放的node的节点数量</span>    <span class="token comment" spellcheck="true">//在put完成后会对这个参数判断是否需要转换成红黑树或链表</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//使用自旋的方式放入数据</span>    <span class="token comment" spellcheck="true">//这个过程是非阻塞的，放入失败会一直循环尝试，直至成功</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//第一次put操作，对数组进行初始化，实现懒加载</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//初始化</span>        tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//数组已初始化完成后</span>        <span class="token comment" spellcheck="true">//使用cas来获取插入元素所在的数组的下标的位置，该位置为空的话就直接放进去 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// no lock when adding to empty bin</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//hash=-1,表明该位置正在进行扩容操作，让当前线程也帮助该位置上的扩容，并发扩容提高扩容的速度 else if ((fh = f.hash) == MOVED)</span>        <span class="token comment" spellcheck="true">//帮助扩容</span>        tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入到该位置已有数据的节点上，即用hash冲突</span>        <span class="token comment" spellcheck="true">//在这里为保证线程安全，会对当前数组位置上的第一个节点进行加锁，因此其他位置上</span>        <span class="token comment" spellcheck="true">//仍然可以进行插入，这里就是jdk1.8相较于之前版本使用segment作为锁性能要高效的地方 else {</span>            V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//再一次判断f节点是否为第一个节点，防止其他线程已修改f节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//为链表</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//将节点放入链表中</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            K ek<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span><span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//为红黑树 else if (f instanceof TreeBin) {</span>                      Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>                      binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//将节点插入红黑树中</span>                      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                          oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                              p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                      <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//插入成功后判断插入数据所在位置上的节点数量，</span>            <span class="token comment" spellcheck="true">//如果数量达到了转化红黑树的阈值，则进行转换</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//由链表转换成红黑树</span>                <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>                  <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//使用cas统计数量增加1，同时判断是否满足扩容需求，进行扩容</span>    <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在代码上写注释可能看得不是很清晰，那么我就使用文字再来描述一下插入数据的整个流程：</p><ol><li>判断传进来的key和value是否为空，在ConcurrentHashMap中key和value都不允许为空，然而在HashMap中是可以为key和val都可以为空，这一点值得注意一下；</li><li>对key进行重hash计算，获得hash值；</li><li>如果当前的数组为空，说明这是第一插入数据，则会对table进行初始化；</li><li>插入数据，这里分为3中情况：<ul><li>1). 插入位置为空，直接将数据放入table的第一个位置中；</li><li>2). 插入位置不为空，并且改为是一个ForwardingNode节点，说明该位置上的链表或红黑树正在进行扩容，然后让当前线程加进去并发扩容，提高效率；</li><li>3). 插入位置不为空，也不是ForwardingNode节点，若为链表则从第一节点开始组个往下遍历，如果有key的hashCode相等并且值也相等，那么就将该节点的数据替换掉，否则将数据加入到链表末段；若为红黑树，则按红黑树的规则放进相应的位置；</li></ul></li><li>数据插入成功后，判断当前位置上的节点的数量，如果节点数据大于转换红黑树阈值（默认为8），则将链表转换成红黑树，提高get操作的速度；</li><li>数据量+1，并判断当前table是否需要扩容；</li></ol><p>所以，put操作流程可以简单的概括为上面的六个步骤，其中一些具体的操作会在下面进行详细的说明，不过，值得注意的是：</p><ul><li>ConcurrentHashMap不可以存储key或value为null的数据，有别于HashMap；</li><li>ConcurrentHashMap使用了懒加载的方式初始化数据，把table的初始化放在第一次put数据的时候，而不是在new的时候；</li><li>扩容时是支持并发扩容，这将有助于减少扩容的时间，因为每次扩容都需要对每个节点进行重hash，从一个table转移到新的table中，这个过程会耗费大量的时间和cpu资源。</li><li>插入数据操作锁住的是表头，这是并发效率高于jdk1.7的地方；<h3 id="hash计算的spread方法"><a href="#hash计算的spread方法" class="headerlink" title="hash计算的spread方法"></a>hash计算的spread方法</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**   * Spreads (XORs) higher bits of hash to lower and also forces top   * bit to 0. Because the table uses power-of-two masking, sets of   * hashes that vary only in bits above the current mask will   * always collide. (Among known examples are sets of Float keys   * holding consecutive whole numbers in small tables.)  So we   * apply a transform that spreads the impact of higher bits   * downward. There is a tradeoff between speed, utility, and   * quality of bit-spreading. Because many common sets of hashes   * are already reasonably distributed (so don't benefit from   * spreading), and because we use trees to handle large sets of   * collisions in bins, we just XOR some shifted bits in the   * cheapest possible way to reduce systematic lossage, as well as   * to incorporate impact of the highest bits that would otherwise   * never be used in index calculations because of table bounds.   */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HASH_BITS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>从源码中可以看到，jdk1.8计算hash的方法是先获取到key的hashCode，然后对hashCode进行高16位和低16位异或运算，然后再与 0x7fffffff 进行与运算。高低位异或运算可以保证haahCode的每一位都可以参与运算，从而使运算的结果更加均匀的分布在不同的区域，在计算table位置时可以减少冲突，提高效率，我们知道Map在put操作时大部分性能都耗费在解决hash冲突上面。得出运算结果后再和 0x7fffffff 与运算，其目的是保证每次运算结果都是一个正数。对于java位运算不了解的同学，建议百度自行了解相关内容。<h3 id="java内存模型和cas操作"><a href="#java内存模型和cas操作" class="headerlink" title="java内存模型和cas操作"></a>java内存模型和cas操作</h3>这里我只是简单的说一下java的内存模型和cas，因为这篇文章的主角的ConcurrentHashMap。</li></ul><p><strong>java内存模型</strong>：在java中线程之间的通讯是通过共享内存（即我们在变成时声明的成员变量或叫全局变量）的来实现的。Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。<br><img src="/medias/article/images/2019/11/13/java_model.png" alt="java内存模型"><br>举一个非常简单的例子，就是我们常用的i++的操作，这个操作看起来只有一行，然而在编译器中这一行代码会被编译成3条指令，分别是读取、更新和写入，所以i++并不是一个原子操作，在多线程环境中是有问题了。其原因在于（我们假设当前 i 的值为1）当一条线程向主内存中读取数据时，还没来得及把更新后的值刷新到主内存中，另一个线程就已经开始向主内存中读取了数据，而此时内存中的值仍然为1，两个线程执行+1操作后得到的结果都为2，然后将结果刷新到主内存中，整个i++操作结果，最终得到的结果为2，但是我们预想的结果应该是3，这就出现了线程安全的问题了。</p><p><strong>cas</strong>： cas的全名称是Compare And Swap 即比较交换。cas算法在不需要加锁的情况也可以保证多线程安全。核心思想是： cas中有三个变量，要更新的变量V，预期值E和新值N,首先先读取V的值，然后进行相关的操作，操作完成后再向主存中读取一次取值为E，当且仅当V == E时才将N赋值给V，否则再走一遍上诉的流程，直至更新成功为止。就拿上面的i++的操作来做说明，假设当前i=1，两个线程同时对i进行+1的操作，线程A中V = 1，E = 1，N = 2；线程B中 V = 1，E = 1，N = 2；假设线程A先执行完整个操作，此时线程A发现 V = E = 1，所以线程A将N的值赋值给V，那么此时i的值就变成了 2 ；线程B随后也完成了操作，向主存中读取i的值，此时E = 2，V = 1，V ！= E，发现两个并不相等，说明i已经被其他线程修改了，因此不执行更新操作，而是从新读取V的值V = 2 ，执行+1后N = 3，完成后再读取主存中i的值，因为此时没有其他线程修改i的值了，所以E = 2，V = E = 2，两个值相等，因此执行赋值操作，将N的值赋值给i，最终得到的结果为3。在整过过程中始终没有使用到锁，却实现的线程的安全性。</p><p>从上面的过程知道，cas会面临着两个问题，一个是当线程一直更新不成功的话，那么这个线程就一直处于死循环中，这样会非常耗费cpu的资源；另一种是ABA的问题，即对i =1进行+1操作后，再-1，那么此时i的值仍为1，而另外一个线程获取的E的值也是1，认为其他线程没有修改过i，然后进行的更新操作，事实上已经有其他线程修改过了这个值了，这个就是 A —&gt; B —&gt; A 的问题；</p><h3 id="获取table对应的索引元素的位置"><a href="#获取table对应的索引元素的位置" class="headerlink" title="获取table对应的索引元素的位置"></a>获取table对应的索引元素的位置</h3><p>通过（n-1）&amp; hash 的算法来获得对应的table的下标的位置，如果对于这条公式不是很理解的同学可以到： jdk1.8源码分析-hashMap 博客中了解。</p><p>tabAt(Node&lt;K,V&gt;[] tab, int i)： 这个方法使用了java提供的原子操作的类来操作的，sun.misc.Unsafe.getObjectVolatile 的方法来保证每次线程都能获取到最新的值；</p><p>casTabAt(Node&lt;K,V&gt;[] tab, int i,Node&lt;K,V&gt; c, Node&lt;K,V&gt; v): 这个方法是通过cas的方式来获取i位置的元素；</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>如果新增节点之后，所在的链表的元素个数大于等于8，则会调用treeifyBin把链表转换为红黑树。在转换结构时，若tab的长度小于MIN_TREEIFY_CAPACITY，默认值为64，则会将数组长度扩大到原来的两倍，并触发transfer，重新调整节点位置。（只有当tab.length &gt;= 64, ConcurrentHashMap才会使用红黑树。）</li><li>新增节点后，addCount统计tab中的节点个数大于阈值（sizeCtl），会触发transfer，重新调整节点位置。<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**   * Adds to count, and if table is too small and not already   * resizing, initiates transfer. If already resizing, helps   * perform transfer if work is available.  Rechecks occupancy   * after a transfer to see if another resize is already needed   * because resizings are lagging additions.   *   * @param x the count to add   * @param check if &lt;0, don't check resize, if &lt;= 1 only check if uncontended   */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> check<span class="token punctuation">)</span> <span class="token punctuation">{</span>  CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span>  <span class="token keyword">long</span> b<span class="token punctuation">,</span> s<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">||</span>              <span class="token operator">!</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwaplong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASECOUNT<span class="token punctuation">,</span> b <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> s <span class="token operator">=</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      CounterCell a<span class="token punctuation">;</span>      <span class="token keyword">long</span> v<span class="token punctuation">;</span>      <span class="token keyword">int</span> m<span class="token punctuation">;</span>      Boolean uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>                      <span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>                      <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span>                        U<span class="token punctuation">.</span><span class="token function">compareAndSwaplong</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> CELLVALUE<span class="token punctuation">,</span> v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">fullAddCount</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>                      <span class="token keyword">return</span><span class="token punctuation">;</span>      s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> nt<span class="token punctuation">;</span>      <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                         <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>                                      sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>                                      transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                                      <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapint</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                      <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapint</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span><span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                              <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>          s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h2>get操作中没有使用到同步的操作，所以相对来说比较简单一点。通过key的hashCode计算获得相应的位置，然后在遍历该位置上的元素，找到需要的元素，然后返回，如果没有则返回null：<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**   * Returns the value to which the specified key is mapped,   * or {@code null} if this map contains no mapping for the key.   *   * &lt;p>More formally, if this map contains a mapping from a key   * {@code k} to a value {@code v} such that {@code key.equals(k)},   * then this method returns {@code v}; otherwise it returns   * {@code null}.  (There can be at most one such mapping.)   *   * @throws NullPointerException if the specified key is null   */</span><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>  Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span>  <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span>  K ek<span class="token punctuation">;</span>  <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>              <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                              <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                      <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> null<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>                              <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                              <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> JDK源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paxos算法</title>
      <link href="/2019/11/06/Paxos%E7%AE%97%E6%B3%95/"/>
      <url>/2019/11/06/Paxos%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Paxos算法详解"><a href="#Paxos算法详解" class="headerlink" title="Paxos算法详解"></a>Paxos算法详解</h2><blockquote><p>Paxos、Raft分布式一致性算法应用场景一文讲述了分布式一致性问题与分布式一致性算法的典型应用场景。作为分布式一致性代名词的Paxos算法号称是最难理解的算法</p></blockquote><h3 id="一、Paxos算法背景"><a href="#一、Paxos算法背景" class="headerlink" title="一、Paxos算法背景"></a>一、Paxos算法背景</h3><p>Paxos算法是Lamport宗师提出的一种基于消息传递的分布式一致性算法，使其获得2013年图灵奖。</p><a id="more"></a><p>Paxos由Lamport于1998年在《The Part-Time Parliament》论文中首次公开，最初的描述使用希腊的一个小岛Paxos作为比喻，描述了Paxos小岛中通过决议的流程，并以此命名这个算法，但是这个描述理解起来比较有挑战性。后来在2001年，Lamport觉得同行不能理解他的幽默感，于是重新发表了朴实的算法描述版本《Paxos Made Simple》。</p><p>自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如Chubby、Megastore以及Spanner等。开源的ZooKeeper，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。</p><p>然而，Paxos的最大特点就是难，不仅难以理解，更难以实现。</p><h3 id="二、Paxos算法流程"><a href="#二、Paxos算法流程" class="headerlink" title="二、Paxos算法流程"></a>二、Paxos算法流程</h3><p>Paxos算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致。</p><p>Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障。</p><p>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。</p><ul><li><em>Proposer</em>: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。</li><li><em>Acceptor</em>：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。</li><li><em>Learner</em>：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）</li></ul><p>在多副本状态机中，每个副本同时具有Proposer、Acceptor、Learner三种角色。<br><img src="/medias/article/images/2019/9/18/2019-09-18-1.jpg" alt></p><p>Paxos算法通过一个决议分为两个阶段（Learn阶段之前决议已经形成）：</p><ol><li>第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。</li><li>第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。</li><li>第三阶段：Learn阶段。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。</li></ol><p><img src="/medias/article/images/2019/9/18/2019-09-18-2.jpg" alt><br>Paxos算法流程中的每条消息描述如下：</p><p>Prepare: Proposer生成全局唯一且递增的Proposal ID (可使用时间戳加Server ID)，向所有Acceptors发送Prepare请求，这里无需携带提案内容，只携带Proposal ID即可。<br>Promise: Acceptors收到Prepare请求后，做出“两个承诺，一个应答”。<br>两个承诺：</p><ol><li><p>不再接受Proposal ID小于等于（注意：这里是&lt;= ）当前请求的Prepare请求。</p></li><li><p>不再接受Proposal ID小于（注意：这里是&lt; ）当前请求的Propose请求。</p></li></ol><p>一个应答：</p><p>不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。</p><ul><li><em>Propose</em>: Proposer 收到多数Acceptors的Promise应答后，从应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptors发送Propose请求。</li><li><em>Accept</em>: Acceptor收到Propose请求后，在不违背自己之前作出的承诺下，接受并持久化当前Proposal ID和提案Value。</li><li><em>Learn</em>: Proposer收到多数Acceptors的Accept后，决议形成，将形成的决议发送给所有Learners。</li></ul><p>Paxos算法伪代码描述如下：<br><img src="/medias/article/images/2019/9/18/2019-09-18-3.jpg" alt></p><ol><li>获取一个Proposal ID n，为了保证Proposal ID唯一，可采用时间戳+Server ID生成；</li><li>Proposer向所有Acceptors广播Prepare(n)请求；</li><li>Acceptor比较n和minProposal，如果n&gt;minProposal，minProposal=n，并且将 acceptedProposal 和 acceptedValue 返回；</li><li>Proposer接收到过半数回复后，如果发现有acceptedValue返回，将所有回复中acceptedProposal最大的acceptedValue作为本次提案的value，否则可以任意决定本次提案的value；<br>到这里可以进入第二阶段，广播Accept (n,value) 到所有节点；</li><li>Acceptor比较n和minProposal，如果n&gt;=minProposal，则acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后，返回；否则，返回minProposal。<br>提议者接收到过半数请求后，如果发现有返回值result &gt;n，表示有更新的提议，跳转到1；否则value达成一致。<br>下面举几个例子，实例1如下图：<br><img src="/medias/article/images/2019/9/18/2019-09-18-4.jpg" alt><br>图中P代表Prepare阶段，A代表Accept阶段。3.1代表Proposal ID为3.1，其中3为时间戳，1为Server ID。X和Y代表提议Value。</li></ol><p>实例1中P 3.1达成多数派，其Value(X)被Accept，然后P 4.5学习到Value(X)，并Accept。</p><p><img src="/medias/article/images/2019/9/18/2019-09-18-5.jpg" alt><br>实例2中P 3.1没有被多数派Accept（只有S3 Accept），但是被P 4.5学习到，P 4.5将自己的Value由Y替换为X，Accept（X）。</p><p><img src="/medias/article/images/2019/9/18/2019-09-18-6.jpg" alt><br>实例3中P 3.1没有被多数派Accept（只有S1 Accept），同时也没有被P 4.5学习到。由于P 4.5 Propose的所有应答，均未返回Value，则P 4.5可以Accept自己的Value (Y)。后续P 3.1的Accept (X) 会失败，已经Accept的S1，会被覆盖。</p><p>Paxos算法可能形成活锁而永远不会结束，如下图实例所示：<br><img src="/medias/article/images/2019/9/18/2019-09-18-7.jpg" alt></p><p>Paxos算法形成活锁<br>回顾两个承诺之一，Acceptor不再应答Proposal ID小于等于当前请求的Prepare请求。意味着需要应答Proposal ID大于当前请求的Prepare请求。</p><p>两个Proposers交替Prepare成功，而Accept失败，形成活锁（Livelock）。</p><h3 id="三、Multi-Paxos算法"><a href="#三、Multi-Paxos算法" class="headerlink" title="三、Multi-Paxos算法"></a>三、Multi-Paxos算法</h3><h4 id="附Paxos算法推导过程"><a href="#附Paxos算法推导过程" class="headerlink" title="附Paxos算法推导过程"></a>附Paxos算法推导过程</h4><p>Paxos算法的设计过程就是从正确性开始的，对于分布式一致性问题，很多进程提出（Propose）不同的值，共识算法保证最终只有其中一个值被选定，Safety表述如下：</p><ul><li>只有被提出（Propose）的值才可能被最终选定（Chosen）。</li><li>只有一个值会被选定（Chosen）。</li><li>进程只会获知到已经确认被选定（Chosen）的值。</li><li>Paxos以这几条约束作为出发点进行设计，只要算法最终满足这几点，正确性就不需要证明了。Paxos算法中共分为三种参与者：Proposer、Acceptor以及Learner，通常实现中每个进程都同时扮演这三个角色。</li></ul><p>Proposers向Acceptors提出Proposal，为了保证最多只有一个值被选定（Chosen），Proposal必须被超过一半的Acceptors所接受（Accept），且每个Acceptor只能接受一个值。</p><p>为了保证正常运行（必须有值被接受），所以Paxos算法中：</p><p>  <strong>P1：Acceptor必须接受（Accept）它所收到的第一个Proposal。</strong><br>  先来先服务，合情合理。但这样产生一个问题，如果多个Proposers同时提出Proposal，很可能会导致无法达成一致，因为没有Propopal被超过一半Acceptors的接受，因此，Acceptor必须能够接受多个Proposal，不同的Proposal由不同的编号进行区分，当某个Proposal被超过一半的Acceptors接受后，这个Proposal就被选定了。<br>  既然允许Acceptors接受多个Proposal就有可能出现多个不同值都被最终选定的情况，这违背了Safety要求，为了保证Safety要求，Paxos进一步提出：</p><p>  <strong>P2：如果值为v的Proposal被选定（Chosen），则任何被选定（Chosen）的具有更高编号的Proposal值也一定为v</strong><br>  只要算法同时满足P1和P2，就保证了Safety。P2是一个比较宽泛的约定，完全没有算法细节，我们对其进一步延伸：</p><p>  <strong>P2a：如果值为v的Proposal被选定（Chosen），则对所有的Acceptors，它们接受（Accept）的任何具有更高编号的Proposal值也一定为v。</strong><br>  如果满足P2a则一定满足P2，显然，因为只有首先被接受才有可能被最终选定。但是P2a依然难以实现，因为acceptor很有可能并不知道之前被选定的Proposal（恰好不在接受它的多数派中），因此进一步延伸</p><p>  <strong>P2b：如果值为v的Proposal被选定（Chosen），则对所有的Proposer，它们提出的的任何具有更高编号的Proposal值也一定为v。</strong><br>  更进一步的：</p><p>  <strong>P2c：为了提出值为v且编号为n的Proposal，必须存在一个包含超过一半Acceptors的集合S，满足(1) 没有任何S中的Acceptors曾经接受（Accept）过编号比n小的Proposal，或者(2) v和S中的Acceptors所接受过(Accept)的编号最大且小于n的Proposal值一致</strong><br>  满足P2c即满足P2b即满足P2a即满足P2。至此Paxos提出了Proposer的执行流程，以满足P2c：</p><ol><li><p>Proposer选择一个新的编号n，向超过一半的Acceptors发送请求消息，Acceptor回复: (a)承诺不会接受编号比n小的proposal，以及(b)它所接受过的编号比n小的最大Proposal（如果有）。该请求称为Prepare请求。</p></li><li><p>如果Proposer收到超过一半Acceptors的回复，它就可以提出Proposal，Proposal的值为收到回复中编号最大的Proposal的值，如果没有这样的值，则可以自由提出任何值。</p></li><li><p>向收到回复的Acceptors发送Accept请求，请求对方接受提出的Proposal。<br>仔细品味Proposer的执行流程，其完全吻合P2c中的要求，但你可能也发现了，当多个Proposer同时运行时，有可能出现没有任何Proposal可以成功被接受的情况（编号递增的交替完成第一步），这就是Paxos算法的Liveness问题，或者叫“活锁”，论文中建议通过对Proposers引入选主算法选出Distinguished Proposer来全权负责提出Proposal来解决这个问题，但是即使在出现多个Proposers同时提出Proposal的情况时，Paxos算法也可以保证Safety。</p><p>接下来看看Acceptors的执行过程，和我们对P2做的事情一样，我们对P1进行延伸：</p></li></ol><p>  <strong>P1a：Acceptor可以接受（Accept）编号为n的Proposal当且仅当它没有回复过一个具有更大编号的Prepare消息</strong><br>  易见，P1a包含了P1，对于Acceptors：</p><ol><li>当收到Prepare请求时，如果其编号n大于之前所收到的Prepare消息，则回复。</li><li>当收到Accept请求时，仅当它没有回复过一个具有更大编号的Prepare消息，接受该Proposal并回复。<br>以上涵盖了满足P1a和P2b的一套完整一致性算法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java线程池：ThreadPoolExecutor</title>
      <link href="/2019/11/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/"/>
      <url>/2019/11/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程池介绍"><a href="#1-线程池介绍" class="headerlink" title="1.线程池介绍"></a>1.线程池介绍</h2><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p><p>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p><a id="more"></a><p>那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p>这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p><h3 id="1-1-什么时候使用线程池？"><a href="#1-1-什么时候使用线程池？" class="headerlink" title="1.1.什么时候使用线程池？"></a>1.1.什么时候使用线程池？</h3><ul><li>单个任务处理时间比较短</li><li>需要处理的任务数量很大</li></ul><h3 id="1-2-使用线程池的好处"><a href="#1-2-使用线程池的好处" class="headerlink" title="1.2.使用线程池的好处"></a>1.2.使用线程池的好处</h3><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p>Java中的线程池是用ThreadPoolExecutor类来实现的. 本文就结合JDK 1.8对该类的源码来分析一下这个类内部对于线程的创建, 管理以及后台任务的调度等方面的执行原理。<br>先看一下线程池的类图：<br><img src="/medias/article/images/2019/11/6/ThreadPoolExecutor-struct.png" alt="线程池类图"></p><h2 id="2-Executor框架接口"><a href="#2-Executor框架接口" class="headerlink" title="2.Executor框架接口"></a>2.Executor框架接口</h2><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</p><p>J.U.C中有三个Executor接口：</p><ul><li><strong>Executor</strong>：一个运行新任务的简单接口；</li><li><strong>ExecutorService</strong>：扩展了Executor接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；</li><li><strong>ScheduledExecutorService</strong>：扩展了ExecutorService。支持Future和定期执行任务。</li></ul><h3 id="2-1-Executor接口"><a href="#2-1-Executor接口" class="headerlink" title="2.1.Executor接口"></a>2.1.Executor接口</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。例如，使用Thread来创建并启动线程的代码如下：</p><pre class=" language-java"><code class="language-java">Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用Executor来启动线程执行任务的代码如下：</p><pre class=" language-java"><code class="language-java">Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p><h3 id="2-2-ExecutorService接口"><a href="#2-2-ExecutorService接口" class="headerlink" title="2.2.ExecutorService接口"></a>2.2.ExecutorService接口</h3><p>ExecutorService接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了shutDown()，shutDownNow()，invokeAll()，invokeAny()和submit()等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。</p><h3 id="2-3-ScheduledExecutorService接口"><a href="#2-3-ScheduledExecutorService接口" class="headerlink" title="2.3.ScheduledExecutorService接口"></a>2.3.ScheduledExecutorService接口</h3><p>ScheduledExecutorService扩展ExecutorService接口并增加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate()方法和scheduleWithFixedDelay()方法。</p><h2 id="3-ThreadPoolExecutor分析"><a href="#3-ThreadPoolExecutor分析" class="headerlink" title="3.ThreadPoolExecutor分析"></a>3.ThreadPoolExecutor分析</h2><p>ThreadPoolExecutor继承自AbstractExecutorService，也是实现了ExecutorService接口。</p><h3 id="3-1-几个重要的字段"><a href="#3-1-几个重要的字段" class="headerlink" title="3.1.几个重要的字段"></a>3.1.几个重要的字段</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span></code></pre><p>ctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p><p>下面再介绍下线程池的运行状态. 线程池一共有五种状态, 分别是:</p><ul><li>RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务；</li><li>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；</li><li>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</li><li>TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</li><li>TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。<br>进入TERMINATED的条件如下：<ul><li>线程池不是RUNNING状态；</li><li>线程池状态不是TIDYING状态或TERMINATED状态；</li><li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li><li>workerCount为0；</li><li>设置TIDYING状态成功。<br>下图为线程池的状态转换过程：<br><img src="/medias/article/images/2019/11/6/threadpool-status.png" alt="线程池的状态转换过程"></li></ul></li></ul><h3 id="3-2-ctl相关方法"><a href="#3-2-ctl相关方法" class="headerlink" title="3.2.ctl相关方法"></a>3.2.ctl相关方法</h3><p>这里还有几个对ctl进行计算的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ul><li>runStateOf：获取运行状态；</li><li>workerCountOf：获取活动线程数；</li><li>ctlOf：获取运行状态和活动线程数的值。</li></ul><h3 id="3-3-ThreadPoolExecutor构造方法"><a href="#3-3-ThreadPoolExecutor构造方法" class="headerlink" title="3.3.ThreadPoolExecutor构造方法"></a>3.3.ThreadPoolExecutor构造方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>构造方法中的字段含义如下：</p><ul><li><strong>corePoolSize</strong>：核心线程数量，当有新任务在<code>execute()</code>方法提交时，会执行以下判断：<ul><li>如果运行的线程少于 <code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li><li>如果线程池中的线程数量大于等于 <code>corePoolSize</code> 且小于 <code>maximumPoolSize</code>，则只有当<code>workQueue</code>满时才创建新的线程去处理任务；</li><li>如果设置的<code>corePoolSize</code> 和 <code>maximumPoolSize</code>相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若<code>workQueue</code>未满，则将请求放入<code>workQueue</code>中，等待有空闲的线程去从<code>workQueue</code>中取任务并处理；</li><li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；<br>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</li></ul></li><li><strong>maximumPoolSize</strong>：最大线程数量；</li><li><strong>workQueue</strong>：等待队列，当任务提交时，如果线程池中的线程数量大于等于<code>corePoolSize</code>的时候，把该任务封装成一个<code>Worker</code>对象放入等待队列；</li><li><strong>workQueue</strong>：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:<ul><li>直接切换：这种方式常用的队列是<code>SynchronousQueue</code>，但现在还没有研究过该队列，这里暂时还没法介绍；</li><li>使用无界队列：一般使用基于链表的阻塞队列<code>LinkedBlockingQueue</code>。如果使用这种方式，那么线程池中能够创建的最大线程数就是<code>corePoolSize</code>，而<code>maximumPoolSize</code>就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</li><li>使用有界队列：一般使用<code>ArrayBlockingQueue</code>。使用该方式可以将线程池的最大线程数量限制为<code>maximumPoolSize</code>，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。<ul><li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li><li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 <code>setMaximumPoolSize()</code> 方法来重新设定线程池的容量。</li><li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li></ul></li></ul></li><li><strong>keepAliveTime</strong>：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于<code>corePoolSize</code>的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了<code>keepAliveTime</code>；</li><li><strong>threadFactory</strong>：它是ThreadFactory类型的变量，用来创建新线程。默认使用<code>Executors.defaultThreadFactory()</code> 来创建线程。使用默认的- - - - ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</li><li><strong>handler</strong>：它是<code>RejectedExecutionHandler</code>类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ul><li>AbortPolicy：直接抛出异常，这是默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ul></li></ul><h3 id="3-4-execute方法"><a href="#3-4-execute方法" class="headerlink" title="3.4.execute方法"></a>3.4.execute方法</h3><p>execute()方法用来提交任务，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * clt记录着runState和workerCount     */</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * workerCountOf方法取出低29位的值，表示当前活动的线程数；     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；     * 并把任务添加到该线程中。     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；         * 如果为true，根据corePoolSize来判断；         * 如果为false，则根据maximumPoolSize来判断         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 如果添加失败，则重新获取ctl值         */</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 如果当前线程池是运行状态并且任务添加到队列成功     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 重新获取ctl值</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span>        <span class="token comment" spellcheck="true">// 这时需要移除该command</span>        <span class="token comment" spellcheck="true">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法         * 这里传入的参数表示：         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。         */</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 如果执行到这里，有两种情况：     * 1. 线程池已经不是RUNNING状态；     * 2. 线程池是RUNNING状态，但workerCount >= corePoolSize并且workQueue已满。     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；     * 如果失败则拒绝该任务     */</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</p><ul><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。<br>这里要注意一下addWorker(null, false);，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在workerCountOf(recheck) == 0时执行addWorker(null, false);也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。<br>execute方法执行流程如下：<br><img src="/medias/article/images/2019/11/6/executor.png" alt="execute方法执行流程"></li></ul><h3 id="3-5-addWorker方法"><a href="#3-5-addWorker方法" class="headerlink" title="3.5.addWorker方法"></a>3.5.addWorker方法</h3><p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取运行状态</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 这个if判断         * 如果rs >= SHUTDOWN，则表示此时不再接收新任务；         * 接着判断以下3个条件，只要有1个不满足，则返回false：         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务         * 2. firsTask为空         * 3. 阻塞队列不为空         *          * 首先考虑rs == SHUTDOWN的情况         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，         * 因为队列中已经没有任务了，不需要再添加线程了         */</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取线程数</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span>            <span class="token comment" spellcheck="true">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span>            <span class="token comment" spellcheck="true">// 如果为false则根据maximumPoolSize来比较。</span>            <span class="token comment" spellcheck="true">// </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果增加workerCount失败，则重新获取ctl的值</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>            <span class="token comment" spellcheck="true">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 根据firstTask来创建Worker对象</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 每一个Worker对象都会创建一个线程</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// rs &lt; SHUTDOWN表示是RUNNING状态；</span>                <span class="token comment" spellcheck="true">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span>                <span class="token comment" spellcheck="true">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// workers是一个HashSet</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// largestPoolSize记录着线程池中出现过的最大线程数量</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 启动线程</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意一下这里的t.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p><h3 id="3-6-Worker类"><a href="#3-6-Worker类" class="headerlink" title="3.6.Worker类"></a>3.6.Worker类</h3><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>        <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>        <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * This class will never be serialized, but we provide a     * serialVersionUID to suppress a javac warning.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Thread this worker is running in.  Null if factory fails. */</span>    <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Initial task to run.  Possibly null. */</span>    Runnable firstTask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Per-thread task counter */</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Creates with given first task and thread from ThreadFactory.     * @param firstTask the first task (null if none)     */</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Delegates main run loop to outer runWorker  */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Lock methods</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// The value 0 represents the unlocked state.</span>    <span class="token comment" spellcheck="true">// The value 1 represents the locked state.</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p><p>在调用构造方法时，需要把任务传入，这里通过getThreadFactory().newThread(this);来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p><p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li><li>如果正在执行任务，则不应该中断线程；</li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li><li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li><li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li></ol><p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p><p>此外，在构造方法中执行了setState(-1);，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>tryAcquire方法是根据state是否是0来判断的，所以，setState(-1);将state设置为-1是为了禁止在执行任务前对线程进行中断。<br>正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0.</p><h3 id="3-7-runWorker方法"><a href="#3-7-runWorker方法" class="headerlink" title="3.7.runWorker方法"></a>3.7.runWorker方法</h3><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取第一个任务</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 允许中断</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token comment" spellcheck="true">// 是否因为异常退出循环</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果task为空，则通过getTask来获取任务</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// If pool is stopping, ensure thread is interrupted;</span>            <span class="token comment" spellcheck="true">// if not, ensure thread is not interrupted.  This</span>            <span class="token comment" spellcheck="true">// requires a recheck in second case to deal with</span>            <span class="token comment" spellcheck="true">// shutdownNow race while clearing interrupt</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里说明一下第一个if判断，目的是：</p><ul><li>如果线程池正在停止，那么要保证当前线程是中断状态；</li><li>如果不是的话，则要保证当前线程不是中断状态；<br>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：<blockquote><p>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</p></blockquote></li></ul><p>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</p><p>总结一下runWorker方法的执行过程：</p><ol><li>while循环不断地通过getTask()方法获取任务；</li><li>getTask()方法从阻塞队列中取任务；</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li><li>调用task.run()执行任务；</li><li>如果task为null则跳出循环，执行processWorkerExit()方法；</li><li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。<br>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</li></ol><p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p><h3 id="3-8-getTask方法"><a href="#3-8-getTask方法" class="headerlink" title="3.8.getTask方法"></a>3.8.getTask方法</h3><p>getTask方法用来从阻塞队列中取任务，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Did the last poll() time out?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token comment" spellcheck="true">/*         * 如果线程池状态rs >= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：         * 1. rs >= STOP，线程池是否正在stop；         * 2. 阻塞队列是否为空。         * 如果以上条件满足，则将workerCount减1并返回null。         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Are workers subject to culling?</span>        <span class="token comment" spellcheck="true">// timed变量用于判断是否需要进行超时控制。</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span>        <span class="token comment" spellcheck="true">// wc > corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span>        <span class="token comment" spellcheck="true">// 对于超过核心线程数量的这些线程，需要进行超时控制</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * wc > maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；         * 如果减1失败，则返回重试。         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。             *              */</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>                workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 r == null，说明已经超时，timedOut设置为true</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</p><p>什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</p><p>getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</p><h3 id="3-9-processWorkerExit方法"><a href="#3-9-processWorkerExit方法" class="headerlink" title="3.9.processWorkerExit方法"></a>3.9.processWorkerExit方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span>    <span class="token comment" spellcheck="true">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If abrupt, then workerCount wasn't adjusted</span>        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//统计完成的任务数</span>        completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span>        workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 根据线程池状态进行判断是否结束线程池</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">>=</span> min<span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// replacement not needed</span>        <span class="token punctuation">}</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：<br><img src="/medias/article/images/2019/11/6/threadpool-lifecycle.png" alt="工作线程流程图"></p><h3 id="3-10-tryTerminate方法"><a href="#3-10-tryTerminate方法" class="headerlink" title="3.10.tryTerminate方法"></a>3.10.tryTerminate方法</h3><p>tryTerminate方法根据线程池状态进行判断是否结束线程池，代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 当前线程池的状态为以下几种情况时，直接返回：         * 1. RUNNING，因为还在运行中，不能停止；         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> TIDYING<span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果线程数量不为0，则中断一个空闲的工作线程，并返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Eligible to terminate</span>            <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span>ONLY_ONE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span>TIDYING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// terminated方法默认什么都不做，留给子类实现</span>                    <span class="token function">terminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 设置状态为TERMINATED</span>                    ctl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>TERMINATED<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    termination<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// else retry on failed CAS</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>interruptIdleWorkers(ONLY_ONE);的作用是因为在getTask方法中执行workQueue.take()时，如果不执行中断会一直阻塞。在下面介绍的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了getTask方法，这时如果workQueue中没有任务了，调用workQueue.take()时就会一直阻塞。所以每次在工作线程结束时调用tryTerminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。</p><h3 id="3-11-shutdown方法"><a href="#3-11-shutdown方法" class="headerlink" title="3.11.shutdown方法"></a>3.11.shutdown方法</h3><p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 安全策略判断</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 切换状态为SHUTDOWN</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 中断空闲线程</span>        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hook for ScheduledThreadPoolExecutor</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 尝试结束线程池</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？<br>下面仔细分析一下：</p><ul><li>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</li><li>shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；</li><li>在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用workQueue.take()进行阻塞；</li><li>如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了workQueue.take()后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；</li><li>由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；</li><li>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用workQueue.take()时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；</li><li>但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；</li><li>所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。<br>下面就来分析一下interruptIdleWorkers方法。</li></ul><h3 id="3-12-interruptIdleWorkers方法"><a href="#3-12-interruptIdleWorkers方法" class="headerlink" title="3.12.interruptIdleWorkers方法"></a>3.12.interruptIdleWorkers方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> onlyOne<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Worker w <span class="token operator">:</span> workers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> w<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>onlyOne<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>interruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。</p><p>为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。</p><h3 id="3-13-shutdownNow方法"><a href="#3-13-shutdownNow方法" class="headerlink" title="3.13.shutdownNow方法"></a>3.13.shutdownNow方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> tasks<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>STOP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 中断所有工作线程，无论是否空闲</span>        <span class="token function">interruptWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 取出队列中没有被执行的任务</span>        tasks <span class="token operator">=</span> <span class="token function">drainQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tasks<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>shutdownNow方法与shutdown方法类似，不同的地方在于：</p><ul><li>设置状态为STOP；</li><li>中断所有工作线程，无论是否是空闲的；</li><li>取出阻塞队列中没有被执行的任务并返回。</li><li>shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。<h2 id="4-线程池的监控"><a href="#4-线程池的监控" class="headerlink" title="4.线程池的监控"></a>4.线程池的监控</h2>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</li><li>getTaskCount：线程池已经执行的和未执行的任务总数；</li><li>getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；</li><li>getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li><li>getPoolSize：线程池当前的线程数量；</li><li>getActiveCount：当前线程池中正在执行任务的线程数量。</li></ul><p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>本文比较详细的分析了线程池的工作流程，总体来说有如下几个内容：</p><ul><li>分析了线程的创建，任务的提交，状态的转换以及线程池的关闭；</li><li>这里通过execute方法来展开线程池的工作流程，execute方法通过corePoolSize，maximumPoolSize以及阻塞队列的大小来- 判断决定传入的任务应该被立即执行，还是应该添加到阻塞队列中，还是应该拒绝任务。</li><li>介绍了线程池关闭时的过程，也分析了shutdown方法与getTask方法存在竞态条件；</li><li>在获取任务时，要通过线程池的状态来判断应该结束工作线程还是阻塞线程等待新的任务，也解释了为什么关闭线程池时要中断- 工作线程以及为什么每一个worker都需要lock。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mPass多租户系统微服务开发平台</title>
      <link href="/2019/11/05/mPass%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
      <url>/2019/11/05/mPass%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p align="center">    <a href="https://gitee.com/ibyte/M-Pass" target="_blank" rel="noopener"><img src="/medias/article/images/2019/11/5/mpass-log.jpg" width="700"></a></p><p>基于SpringBoot2.x、SpringCloud并采用前后端分离的企业级微服务,多租户系统架构微服务开发平台 mPaaS（Microservice PaaS）为租户业务开发、测试、运营及运维开源框架，能有效降低技术门槛、减少研发成本、提升开发效率，协助企业快速搭建稳定高质量的微服务应用;同时还集合各种微服务治理功能和监控功能。模块包括:企业级的认证系统、开发平台、应用监控、慢sql监控、统一日志、单点登录、Redis分布式高速缓存、配置中心、分布式任务调度、接口文档、代码生成等等</p><a id="more"></a><p>[TOC]</p><blockquote><p>目前只是架构初步构思图</p></blockquote><h2 id="项目总体架构图"><a href="#项目总体架构图" class="headerlink" title="项目总体架构图"></a>项目总体架构图</h2><p><img src="/medias/article/images/2019/11/5/mpass.jpg" alt="项目架构图" title="mPass_Springcloud微服务架构.jpg"></p><p> :anger:  :facepunch:   <em>系统处于开发阶段, 预计<strong>两个月</strong>时间完成整体架构体系</em></p><p><strong>核心功能</strong>：</p><ul><li><strong>快速开发</strong>：工程化的开发框架可以自动生成初始化代码，框架还提供模块化开发模式，适用于多人协作开发。</li><li><strong>性能优化</strong>：支持运营活动投放一站式全流程创建管理，加载智能化投放能力，最大可能提升运营效率和转化效果，助力业务增长。</li><li><strong>数字化运营闭环</strong>：所有组件都经历了高并发，大流量的检验，对弱网，保活，容器等都有深度的优化，能够兼容复杂的客户端情况</li><li><strong>使用方式灵活</strong>：框架与组件并没有强依赖，可分可合，灵活机动。各组件可以独立的提供强大的功能，也可以互相配合优化使用体验，发挥更大的作用</li></ul><h2 id="运维架构图"><a href="#运维架构图" class="headerlink" title="运维架构图"></a>运维架构图</h2><p><img src="/medias/article/images/2019/11/5/ops.png" alt="运维架构图" title="ops.png"></p><p><strong>查看更新记录请移步</strong><br><a href="https://gitee.com/ibyte/M-Pass/blob/master/UPDAT-RECORD.md" target="_blank" rel="noopener">目前进度</a></p><h2 id="项目详细部署图"><a href="#项目详细部署图" class="headerlink" title="项目详细部署图"></a>项目详细部署图</h2><p><img src="/medias/article/images/2019/11/5/deploy.png" alt="项目详细部署图" title="deploy.png"><br><strong>交流群</strong></p><table border="0">    <tr>        <td>微信交流群：微信群(加微信入群)</td>        <td>微信公众号：码农架构</td>        <td>Q群：QQ交流群</td>    </tr>    <tr>&nbsp;</tr>    <tr>        <td><img title="微信交流群" src="https://images.gitee.com/uploads/images/2019/1111/175326_2a1374a3_1468963.png" height="200" width="200"></td>        <td><img title="微信公众号-微技术栈" src="https://images.gitee.com/uploads/images/2019/1111/175334_5ee70c7b_1468963.jpeg" height="200" width="200"></td>        <td><img title="QQ交流群" src="https://images.gitee.com/uploads/images/2019/1111/175611_70417f38_1468963.png" height="200" width="200"></td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> mPass </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java @Retention 重复注解</title>
      <link href="/2019/11/04/Java%20@Retention%20%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/11/04/Java%20@Retention%20%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Repeatable-介绍"><a href="#Repeatable-介绍" class="headerlink" title="@Repeatable 介绍"></a>@Repeatable 介绍</h2><p><code>@Repeatable</code>注解以及其相关特性，是在JDK 8中提供的，简单而言，我们可以设计一种风格的<code>annotation</code>，可以被多次修饰在符合要求的<code>@Target</code>上，在此前一个类型的注释是不能重复修饰在相同地方。被重复修饰的注解，表示此<code>Target</code>同时具有注解的驱动能力，比如下文的<code>@Scheduled</code>，表示此任务方法分别在各自的时机执行</p><a id="more"></a><h2 id="Repeatable-源码"><a href="#Repeatable-源码" class="headerlink" title="@Repeatable 源码"></a>@Repeatable 源码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * The annotation type {@code java.lang.annotation.Repeatable} is * used to indicate that the annotation type whose declaration it * (meta-)annotates is &lt;em>repeatable&lt;/em>. The value of * {@code @Repeatable} indicates the &lt;em>containing annotation * type&lt;/em> for the repeatable annotation type. * * @since 1.8 * @jls 9.6 Annotation Types * @jls 9.7 Annotations */</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Repeatable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Indicates the &lt;em>containing annotation type&lt;/em> for the     * repeatable annotation type.     * @return the containing annotation type     */</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Repeatable-Spring使用案例"><a href="#Repeatable-Spring使用案例" class="headerlink" title="@Repeatable Spring使用案例"></a>@Repeatable Spring使用案例</h2><p>对于JAVA开发人员，我们常见的、已经基于@Repeatable的注解，比如:</p><ul><li>@ComponentScan — Spring</li><li>@Scheduled — Spring</li></ul><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>ComponentScan</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>ComponentScans<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// ComponentScan 关联ComponentScans</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ComponentScan</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p>ComponentScans</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ComponentScans</span> <span class="token punctuation">{</span>    ComponentScan<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Schedule"><a href="#Schedule" class="headerlink" title="@Schedule"></a>@Schedule</h3><p>Scheduled</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Schedules<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Scheduled</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ... </span><span class="token punctuation">}</span></code></pre><p>Schedules</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Schedules</span> <span class="token punctuation">{</span>    Scheduled<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>多租户系统微服务开发平台</code></pre><blockquote><p>注: JEP=JDK Enhancement-Proposal (JDK 增强建议 )，每个JEP即一个新特性。<br>简单实用场景如</p><ul><li>角色和权限注解使用时候常用</li><li>全局拓展点和本地拓展点使用</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Redis在Hibernate中进行缓存</title>
      <link href="/2019/10/31/%E4%BD%BF%E7%94%A8Redis%E5%9C%A8Hibernate%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98/"/>
      <url>/2019/10/31/%E4%BD%BF%E7%94%A8Redis%E5%9C%A8Hibernate%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><a href="http://hibernate.org/" target="_blank" rel="noopener">Hibernate</a>是Java编程语言的开放源代码，对象/关系映射框架。Hibernate的目标是帮助开发人员摆脱许多繁琐的手动数据处理任务。Hibernate能够在Java类和数据库表之间以及Java和SQL中的数据类型之间创建映射。</p><p>任何处理大量数据的非平凡应用程序都必须依靠缓存和其他技术来提高效率。缓存是一种通过使用缓冲区存储经常访问的数据来提高应用程序性能的策略。通过减少数据库请求的数量并将数据存储在更靠近CPU的位置，缓存可以显着提高应用程序的速度。</p><a id="more"></a><p>在本文中，我们将研究如何使用<a href="https://redisson.org/" target="_blank" rel="noopener">Redisson</a>（一种用于访问内存中数据结构存储Redis的Java包装器）在Hibernate中执行缓存。</p><h2 id="Hibernate-第一级-二级缓存"><a href="#Hibernate-第一级-二级缓存" class="headerlink" title="Hibernate  第一级 \ 二级缓存"></a>Hibernate  第一级 \ 二级缓存</h2><blockquote><p>Hibernate使用多级缓存方案。第一级是强制性的，默认情况下处于启用状态，而第二级是可选的。</p></blockquote><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存（也称为L1缓存）与Hibernate的<a href="https://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/Session.html" target="_blank" rel="noopener">Session对象</a>相关联，该对象表示Java应用程序和SQL数据库之间的连接。这意味着仅在会话存在的前提下，一级缓存才可用。每个第一级缓存只能由与其关联的Session对象访问。</p><p>首次从数据库中查询实体时，该实体将存储在与该会话关联的第一级缓存中。在同一会话期间对此实体的任何后续查询都将从缓存而不是数据库中检索实体。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存（也称为L2缓存）默认情况下处于禁用状态，但可以通过修改Hibernate的配置设置来启用。该缓存与Hibernate的<a href="https://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/SessionFactory.html" target="_blank" rel="noopener">SessionFactory</a>对象相关联，主要用于存储应在Session之间持久的数据。在查找第二级缓存之前，应用程序将始终在第一级缓存中搜索给定实体的存在。</p><p>Hibernate还具有第三种类型的缓存：查询缓存，用于存储特定数据库查询的结果。当您需要使用相同的参数多次运行相同的查询时，这很有用</p><p>Hibernate中的二级缓存有几种不同的实现，包括Ehcache和OSCache。在本文的其余部分中，我们将探讨Hibernate中用于二级缓存的另一个选项：Redisson，它允许将Redis用作Hibernate缓存</p><h2 id="如何使用Hibernate和Redis进行缓存"><a href="#如何使用Hibernate和Redis进行缓存" class="headerlink" title="如何使用Hibernate和Redis进行缓存"></a>如何使用Hibernate和Redis进行缓存</h2><p><a href="https://gitee.com/ibyte/M-Pass/blob/master/common/common-core/src/main/java/com/ibyte/component/jpa/cache/RedissonCacheRegionFactory.java" target="_blank" rel="noopener">源码案例- RedissonCacheRegionFactory</a></p><h3 id="选择策略"><a href="#选择策略" class="headerlink" title="选择策略"></a>选择策略</h3><p>Redisson是Java中的Redis客户端，其中包含许多Java对象和服务的实现，包括Hibernate缓存。Redisson支持所有四种Hibernate缓存策略：</p><ul><li>READ_ONLY：仅用于在缓存内部不会更改的实体。</li><li>NONSTRICT_READ_WRITE：在事务修改数据库中的实体之后，更新缓存。无法保证强一致性，但可以保证最终一致性。</li><li>READ_WRITE：通过使用“软”锁来保证强一致性，这些锁将保持对实体的控制，直到事务完成为止。</li><li>事务性：通过使用分布式<a href="https://docs.oracle.com/cd/E19509-01/820-5892/ref_xatrans/index.html" target="_blank" rel="noopener">XA事务</a>确保数据完整性。确保将更新提交或回滚到数据库和缓存。</li></ul><p>Redisson提供了各种Hibernate CacheFactories，包括那些支持本地缓存的。如果您打算将Hibernate缓存主要用于读取操作，或者您不想进行太多的网络往返，则本地缓存是一个明智的解决方案。</p><p>该  RedissonRegionFactory 工具实现了基本的Hibernate缓存，而  RedissonLocalCachedRegionFactory  （在<a href="https://redisson.pro/" target="_blank" rel="noopener">Redisson PRO版本</a>中可用）实现了具有本地缓存​​支持的Hibernate缓存。</p><h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><p>redisson-hibernate 可以使用Maven或Gradle 将  依赖项轻松集成到您的项目中。对于JDK 1.8，Maven设置为：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- for Hibernate v4.x --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>redisson-hibernate-4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- for Hibernate v5.0.x - v5.1.x --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>redisson-hibernate-5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- for Hibernate v5.2.x --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>redisson-hibernate-52<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- for Hibernate v5.3.x - v5.4.x --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>redisson-hibernate-53<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.10.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>并且Gradle设置是：</p><pre class=" language-xml"><code class="language-xml">// for Hibernate v4.xcompile 'org.redisson:redisson-hibernate-4:3.10.2'// for Hibernate v5.0.x - v5.1.xcompile 'org.redisson:redisson-hibernate-5:3.10.2'// for Hibernate v5.2.xcompile 'org.redisson:redisson-hibernate-52:3.10.2'// for Hibernate v5.3.x - v5.4.xcompile 'org.redisson:redisson-hibernate-53:3.10.2'</code></pre><p>要CacheFactory 在Redisson中定义  in，请在Hibernate配置中插入适当的属性：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- Redisson Region Cache factory --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate.cache.region.factory_class<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.redisson.hibernate.RedissonRegionFactory<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- or --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate.cache.region.factory_class<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.redisson.hibernate.RedissonLocalCachedRegionFactory<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h3 id="激活配置"><a href="#激活配置" class="headerlink" title="激活配置"></a>激活配置</h3><p>您还需要激活Hibernate的二级缓存并指定Redisson配置文件：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 2nd level cache activation --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate.cache.use_second_level_cache<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate.cache.use_query_cache<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- Redisson YAML config (located in filesystem or classpath) --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate.cache.redisson.config<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/redisson.yaml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- Redisson JSON config (located in filesystem or classpath) --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hibernate.cache.redisson.config<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/redisson.json<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h3 id="配置缓存参数"><a href="#配置缓存参数" class="headerlink" title="配置缓存参数"></a>配置缓存参数</h3><p>Redisson允许您为Hibernate缓存更改许多不同的重要参数，包括：</p><ul><li>Redis中缓存的最大大小</li><li>Redis中每个缓存条目的生存时间</li><li>Redis中每个缓存条目的最大空闲时间</li><li>本地缓存的最大大小</li><li>每个本地缓存条目的生存时间</li></ul><p>每个本地缓存条目的最大空闲时间</p><p>一旦达到高速缓存的最大大小（LFU，LRU，SOFT，WEAK或NONE），就对本地高速缓存逐出策略</p><p>跨所有实例将更改同步到本地缓存的策略（INVALIDATE，UPDATE或NONE）</p><p>连接失败（CLEAR，LOAD或NONE）后重新加载丢失的更新的重新连接策略</p><p><a href="https://gitee.com/ibyte/M-Pass/blob/master/common/common-core/src/main/java/com/ibyte/component/jpa/cache/RedissonCacheRegionFactory.java" target="_blank" rel="noopener">Hibernate 二级缓存 - RedissonCacheRegionFactory</a></p>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java系列之注解</title>
      <link href="/2019/10/17/Java%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/10/17/Java%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java系列之注解"><a href="#Java系列之注解" class="headerlink" title="Java系列之注解"></a>Java系列之注解</h1><blockquote><p>Java 注解（Annotation）又称之为 Java 标注、元数据，是 Java 1.5 之后加入的一种特殊语法，通过注解可以标注 Java 中的类、方法、属性、参数、包等，可以通过反射原理对这些元数据进行访问，注解的使用不会影响程序的正常运行，只会对编译器警告等辅助工具产生影响 </p></blockquote><a id="more"></a><h2 id="注解功能"><a href="#注解功能" class="headerlink" title="注解功能"></a>注解功能</h2><ol><li>编译器可以使用注解来检测错误和取消警告；</li><li>使用注解可以生成特定代码，如 ButtferKnife 使用注解简化 findViewById等；</li><li>某些注解可以在运行时进行检查和操作。</li></ol><h2 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h2><p>注解的定义使用 @interface 作为关键字，实际上表示自动继承了 java.lang.annotation.Annotation 接口，定义格式参考如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">AuthValidators</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>    AuthValidator<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">validators</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><ul><li><p>@Override  表示当前的方法将覆盖超类中的方法，编译时进行格式检查</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>SOURCE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Override</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li><li><p>@Deprecated 表示一个类或者是方法不再建议使用，将其标记为过时，但还是可以使用</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>TYPE<span class="token punctuation">,</span> FIELD<span class="token punctuation">,</span> METHOD<span class="token punctuation">,</span> PARAMETER<span class="token punctuation">,</span> CONSTRUCTOR<span class="token punctuation">,</span> LOCAL_VARIABLE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>SOURCE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SuppressWarnings</span> <span class="token punctuation">{</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>@SuppressWarnings 表示关闭不当的编译器警告信息</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token punctuation">{</span>CONSTRUCTOR<span class="token punctuation">,</span> FIELD<span class="token punctuation">,</span> LOCAL_VARIABLE<span class="token punctuation">,</span> METHOD<span class="token punctuation">,</span> PACKAGE<span class="token punctuation">,</span> PARAMETER<span class="token punctuation">,</span> TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Deprecated</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2></li><li><p>@Target</p></li><li><p>@Retention</p></li><li><p>@Documented</p></li><li><p>@Inherited</p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>@Target 用来描述注解的使用范围,它的申明如下</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>  ElementType<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由 @Target 声明可知使用 @Target 注解必须指定具体的 Java 成员，也就是该注解要使用到哪个位置，具体由枚举 ElementType 中定义，具体如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> ElementType <span class="token punctuation">{</span>  TYPE<span class="token punctuation">,</span>           <span class="token comment" spellcheck="true">//类、接口、注解、枚举</span>  FIELD<span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//属性（包括枚举常量） </span>  METHOD<span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">//方法</span>  PARAMETER<span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">//参数 </span>  CONSTRUCTOR<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//构造方法</span>  LOCAL_VARIABLE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//局部变量</span>  ANNOTATION_TYPE<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//注解</span>  PACKAGE<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//包</span>  <span class="token comment" spellcheck="true">/**   * 类型注解   * @since 1.8   */</span>  TYPE_PARAMETER<span class="token punctuation">,</span>  TYPE_USE<span class="token punctuation">}</span></code></pre><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>@Retention 表示在什么级别保存该注解的信息，它的声明如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Retention</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * Returns the retention policy.   * @return the retention policy   */</span>  RetentionPolicy <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由 @Retention 的声明可知，使用 @Retention 时，必须指定保存celue（RetentionPolicy），具体值如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> RetentionPolicy <span class="token punctuation">{</span>  SOURCE<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//在编译时会被丢弃，仅仅在源码中存在</span>  CLASS<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">//默认策略，运行时就会被丢弃，仅仅在 class 文件中</span>  RUNTIME  <span class="token comment" spellcheck="true">//编译时会将注解信息记录到class文件，运行时任然保留，可以通过反射获取注解信息</span><span class="token punctuation">}</span></code></pre><h3 id="Documented-amp-Inherted"><a href="#Documented-amp-Inherted" class="headerlink" title="@Documented &amp; @Inherted"></a>@Documented &amp; @Inherted</h3><p>@Documented 和 @Inherited 都没有配置参数，是一种标记注解，@Documented 表示将该注解显示到用户文档中，@Inherited 表示该注解只有使用在类上才会有效，而且该注解会被子类继承。</p></li></ul><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>在对元注解的说明中可知从 Java8 开始新增了类型注解，如果在注解 @Target 使用这种注解，表明该注解可以在对应的任何地方使用，如在 @Target 中指定 TYPE_PARAMETER 就可在自定义类型的声明处使用该注解，如在 @Target 中指定 TYPE_USE 就可在任何类型前添加该类之间，主要是方便 Java 开发者使用类型注解和相关插件（Checker Framework）来检查来在编译期检查运行时的异常</p><p>下面分别定义指定 TYPE_PARAMETER 和 TYPE_USE 的注解，具体如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1. TYPE_PARAMETER</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE_PARAMETER<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">TypeParameterAnnotation</span> <span class="token punctuation">{</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2. TYPE_USE</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>value <span class="token operator">=</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">TypeUseAnnotation</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之RefreshScope</title>
      <link href="/2019/10/15/SpringCloud%E4%B9%8BRefreshScope/"/>
      <url>/2019/10/15/SpringCloud%E4%B9%8BRefreshScope/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringCloud之RefreshScope"><a href="#SpringCloud之RefreshScope" class="headerlink" title="SpringCloud之RefreshScope"></a>SpringCloud之RefreshScope</h2><h3 id="Scope-源码解读"><a href="#Scope-源码解读" class="headerlink" title="@Scope 源码解读"></a>@Scope 源码解读</h3><ul><li>Scope(<code>org.springframework.beans.factory.config.Scope</code>)是Spring 2.0开始就有的核心的概念</li><li>RefreshScope(<code>org.springframework.cloud.context.scope.refresh</code>)是spring cloud提供的一种特殊的scope实现，用来实现配置、实例热加载。</li><li>Scope -&gt; GenericScope -&gt; RefreshScope<br><img src="/medias/article/images/2019/10/15/RefreshScope.jpg" alt></li><li>Scope与ApplicationContext生命周期<ul><li>AbstractBeanFactory#doGetBean创建Bean实例</li></ul></li></ul><a id="more"></a><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">final</span> RootBeanDefinition mbd <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          String scopeName <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">final</span> Scope scope <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>scopeName<span class="token punctuation">)</span><span class="token punctuation">;</span>          Object scopedInstance <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectFactory</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><ul><li>Singleton和Prototype是硬编码的，并不是Scope子类。 Scope实际上是自定义扩展的接口</li><li>Scope Bean实例交由Scope自己创建，例如SessionScope是从Session中获取实例的，ThreadScope是从ThreadLocal中获取的，而RefreshScope是在内建缓存中获取的<ul><li>@Scope 对象的实例化</li></ul></li><li>@RefreshScope 是scopeName=”refresh”的 @Scope</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"refresh"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">RefreshScope</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * @see Scope#proxyMode()     * @return proxy mode     */</span>    ScopedProxyMode <span class="token function">proxyMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> ScopedProxyMode<span class="token punctuation">.</span>TARGET_CLASS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>@Scope 的注册 AnnotatedBeanDefinitionReader#registerBean</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBean</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ScopeMetadata scopeMetadata <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopeMetadataResolver<span class="token punctuation">.</span><span class="token function">resolveScopeMetadata</span><span class="token punctuation">(</span>abd<span class="token punctuation">)</span><span class="token punctuation">;</span>      abd<span class="token punctuation">.</span><span class="token function">setScope</span><span class="token punctuation">(</span>scopeMetadata<span class="token punctuation">.</span><span class="token function">getScopeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      definitionHolder <span class="token operator">=</span> AnnotationConfigUtils<span class="token punctuation">.</span><span class="token function">applyScopedProxyMode</span><span class="token punctuation">(</span>scopeMetadata<span class="token punctuation">,</span> definitionHolder<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><ul><li>读取@Scope元数据， AnnotationScopeMetadataResolver#resolveScopeMetadata</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ScopeMetadata <span class="token function">resolveScopeMetadata</span><span class="token punctuation">(</span>BeanDefinition definition<span class="token punctuation">)</span> <span class="token punctuation">{</span>          AnnotationAttributes attributes <span class="token operator">=</span> AnnotationConfigUtils<span class="token punctuation">.</span><span class="token function">attributesFor</span><span class="token punctuation">(</span>                  annDef<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Scope<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>attributes <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              metadata<span class="token punctuation">.</span><span class="token function">setScopeName</span><span class="token punctuation">(</span>attributes<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              ScopedProxyMode proxyMode <span class="token operator">=</span> attributes<span class="token punctuation">.</span><span class="token function">getEnum</span><span class="token punctuation">(</span><span class="token string">"proxyMode"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>proxyMode <span class="token operator">==</span> null <span class="token operator">||</span> proxyMode <span class="token operator">==</span> ScopedProxyMode<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  proxyMode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultProxyMode<span class="token punctuation">;</span>              <span class="token punctuation">}</span>              metadata<span class="token punctuation">.</span><span class="token function">setScopedProxyMode</span><span class="token punctuation">(</span>proxyMode<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>Scope实例对象通过ScopedProxyFactoryBean创建，其中通过AOP使其实现ScopedObject接口，这里不再展开<h3 id="RefreshScope-源码解读"><a href="#RefreshScope-源码解读" class="headerlink" title="@RefreshScope 源码解读"></a>@RefreshScope 源码解读</h3><h4 id="RefreshScope注册"><a href="#RefreshScope注册" class="headerlink" title="RefreshScope注册"></a>RefreshScope注册</h4><ul><li>RefreshAutoConfiguration#RefreshScopeConfiguration</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>RefreshScope<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">RefreshScopeConfiguration</span> <span class="token keyword">implements</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"refreshScope"</span><span class="token punctuation">,</span>    BeanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span>RefreshScope<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">setRole</span><span class="token punctuation">(</span>BeanDefinition<span class="token punctuation">.</span>ROLE_INFRASTRUCTURE<span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><ul><li>RefreshScope extends GenericScope, 大部分逻辑在 GenericScope 中</li><li>GenericScope#postProcessBeanFactory 中向AbstractBeanFactory注册自己</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericScope</span> <span class="token keyword">implements</span> <span class="token class-name">Scope</span><span class="token punctuation">,</span> BeanFactoryPostProcessor<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span>          <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>          beanFactory<span class="token punctuation">.</span><span class="token function">registerScope</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token comment" spellcheck="true">/*refresh*/</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token comment" spellcheck="true">/*RefreshScope*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="RefreshScope-刷新过程"><a href="#RefreshScope-刷新过程" class="headerlink" title="RefreshScope 刷新过程"></a>RefreshScope 刷新过程</h4><ul><li>入口在ContextRefresher#refresh</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> <span class="token function">refreshEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>scope<span class="token punctuation">.</span><span class="token function">refreshAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> keys<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">refreshEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> before <span class="token operator">=</span> <span class="token function">extract</span><span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">addConfigFilesToEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> <span class="token function">changes</span><span class="token punctuation">(</span>before<span class="token punctuation">,</span>      <span class="token function">extract</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EnvironmentChangeEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> keys<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>①提取标准参数(SYSTEM,JNDI,SERVLET)之外所有参数变量</li><li>②把原来的Environment里的参数放到一个新建的Spring Context容器下重新加载，完事之后关闭新容器</li><li>③提起更新过的参数(排除标准参数)</li><li>④比较出变更项</li><li>⑤发布环境变更事件,接收：EnvironmentChangeListener／LoggingRebinder</li><li>⑥RefreshScope用新的环境参数重新生成Bean</li><li>⑦重新生成的过程很简单，清除refreshscope缓存幷销毁Bean，下次就会重新从BeanFactory获取一个新的实例（该实例使用新的配置）</li><li>⑧RefreshScope#refreshAll</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refreshAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>b<span class="token operator">></span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RefreshScopeRefreshedEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>⑨GenericScope#destroy</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    Collection<span class="token operator">&lt;</span>BeanLifecycleWrapper<span class="token operator">></span> wrappers <span class="token operator">=</span> <span class="token operator">&lt;</span>b<span class="token operator">></span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanLifecycleWrapper wrapper <span class="token operator">:</span> wrappers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>b<span class="token operator">></span>wrapper<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot之ConfigurationProperties</title>
      <link href="/2019/10/14/SpringBoot%E4%B9%8BConfigurationProperties/"/>
      <url>/2019/10/14/SpringBoot%E4%B9%8BConfigurationProperties/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ConfigurationProperties</code> 是<code>SpringBoot</code>引入的一个和外部配置文件相关的注解类。它可以帮助我们更好的使用外置的配置文件属性。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><blockquote><p>属性注入到Java类</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ConfigurationProperties</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"prefix"</span><span class="token punctuation">)</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>    String <span class="token function">prefix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">ignoreInvalidFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">ignoreNestedProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">ignoreUnknownFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Deprecated</span>    <span class="token keyword">boolean</span> <span class="token function">exceptionIfInvalid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><a id="more"></a><ul><li>prefix &amp; value<ul><li>prefix 属性可以指定配置文件中配置项的前缀，如此，相同前缀的配置项就可以统一解析。</li></ul></li><li>ignoreInvalidFields<ul><li>是否忽略不可用的字段，默认为false， 当配置项不能被正确转化为Java类的字段值时，会抛出异常。</li></ul></li><li>ignoreNestedProperties<ul><li>是否忽略嵌套属性，默认为false，</li></ul></li><li>ignoreUnknownFields<ul><li>是否忽略Java类不存在的字段，默认值为true。</li></ul></li><li>exceptionIfInvalid<ul><li>如果Java类加了注解@Validated，并且校验失败了，是否抛出异常。默认true</li></ul></li></ul><blockquote><p>通过@ConfigurationProperties + @Bean注解在配置类的bean定义方法上</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">"classpath:configprops.properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Credentials</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Length</span><span class="token punctuation">(</span>max <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">private</span> String authMethod<span class="token punctuation">;</span>        <span class="token keyword">private</span> String username<span class="token punctuation">;</span>        <span class="token keyword">private</span> String password<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// standard getters and setters</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@NotBlank</span>    <span class="token keyword">private</span> String host<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Min</span><span class="token punctuation">(</span><span class="token number">1025</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Max</span><span class="token punctuation">(</span><span class="token number">65536</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Pattern</span><span class="token punctuation">(</span>regexp <span class="token operator">=</span> <span class="token string">"^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,6}$"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String from<span class="token punctuation">;</span>    <span class="token keyword">private</span> Credentials credentials<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> defaultRecipients<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> additionalHeaders<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// standard getters and setters</span><span class="token punctuation">}</span></code></pre><p>默认属性配置从<code>application.properties</code>文件中获取，也可以通过<code>@PropertySource</code>指定。<br><code>@Configuration</code>注解不可缺少。<br>资源文件内容如下：</p><pre><code>#Simple propertiesmail.host=mailer@mail.commail.port=9000mail.from=mailer@mail.com#List propertiesmail.defaultRecipients[0]=admin@mail.commail.defaultRecipients[1]=owner@mail.com#Map Propertiesmail.additionalHeaders.redelivery=truemail.additionalHeaders.secure=true#Object propertiesmail.credentials.username=johnmail.credentials.password=passwordmail.credentials.authMethod=SHA1</code></pre><p>内嵌类属性</p><ul><li><code>mail.credentials.username</code>可以注入到内嵌属性<code>credentials</code>中列表字段</li><li><code>mail.defaultRecipients[0]</code> 可以注入到类的列表(数组页可以)属性中。<br>map字段 </li><li><code>mail.additionalHeaders.redelivery</code> 格式的配置项也可以注入到Map类型的属性中。</li></ul><blockquote><p>@ConfigurationProperties + @EnableConfigurationProperties</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"mail"</span><span class="token punctuation">)</span><span class="token keyword">public</span> ConfigProperties <span class="token function">mailConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConfigProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ConfigProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="属性校验"><a href="#属性校验" class="headerlink" title="属性校验"></a>属性校验</h2><p>可以给属性类上加入<code>javax.validation.constraints.*</code>中的注解，来对配置项进行校验。配合<code>exceptionIfInvalid</code>可以更早的发现问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reflections框架</title>
      <link href="/2019/09/05/Reflections%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/09/05/Reflections%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Reflections框架"><a href="#Reflections框架" class="headerlink" title="Reflections框架"></a>Reflections框架</h2><h3 id="Reflections框架简介"><a href="#Reflections框架简介" class="headerlink" title="Reflections框架简介"></a>Reflections框架简介</h3><blockquote><p>Reflections是一个能提供一站式服务的对象。它扫描工程的classpath，为元数据建索引，允许你运行时查询元数据信息。此外，他还能为你项目的lib库中所有的jar包保存和收集元数据。</p></blockquote><h4 id="Reflections-的用处"><a href="#Reflections-的用处" class="headerlink" title="Reflections 的用处"></a>Reflections 的用处</h4><ul><li>获取某个类型的全部子类</li><li>只要类型、构造器、方法，字段上带有特定注解，便能获取带有这个注解的全部信息（类型、构造器、方法，字段）</li><li>获取所有能匹配某个正则表达式的资源</li><li>获取所有带有特定签名的方法，包括参数，参数注解，返回类型</li><li>获取所有方法的名字</li><li>获取代码里所有字段、方法名、构造器的使用</li></ul><a id="more"></a><h4 id="Reflections-相关资料地址"><a href="#Reflections-相关资料地址" class="headerlink" title="Reflections 相关资料地址"></a>Reflections 相关资料地址</h4><table><thead><tr><th>说明</th><th>地址</th></tr></thead><tbody><tr><td>JavaDoc地址</td><td><a href="http://ronmamo.github.io/reflections/index.html?org/reflections/Reflections.html" target="_blank" rel="noopener">JavaDoc-链接地址</a></td></tr><tr><td>Java Code Examples</td><td><a href="https://www.programcreek.com/java-api-examples/index.php?api=org.reflections.Reflections" target="_blank" rel="noopener">Java Code-链接地址</a></td></tr></tbody></table><h3 id="Reflections官方案例"><a href="#Reflections官方案例" class="headerlink" title="Reflections官方案例"></a>Reflections官方案例</h3><p>指定扫描包路径<br><img src="/medias/article/images/2019/9/5/reflections1.jpg" alt></p><pre class=" language-java"><code class="language-java">Reflections reflections <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reflections</span><span class="token punctuation">(</span><span class="token string">"my.package.prefix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//or</span>Reflections reflections <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reflections</span><span class="token punctuation">(</span>ClasspathHelper<span class="token punctuation">.</span><span class="token function">forPackage</span><span class="token punctuation">(</span><span class="token string">"my.package.prefix"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token keyword">new</span> <span class="token class-name">SubTypesScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypesAnnotationScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FilterBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//or using the ConfigurationBuilder</span><span class="token keyword">new</span> <span class="token class-name">Reflections</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConfigurationBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filterInputsBy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FilterBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span>FilterBuilder<span class="token punctuation">.</span><span class="token function">prefix</span><span class="token punctuation">(</span><span class="token string">"my.project.prefix"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setUrls</span><span class="token punctuation">(</span>ClasspathHelper<span class="token punctuation">.</span><span class="token function">forPackage</span><span class="token punctuation">(</span><span class="token string">"my.project.prefix"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setScanners</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SubTypesScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeAnnotationsScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filterResultsBy</span><span class="token punctuation">(</span>optionalFilter<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>常用扫描结果<br><img src="/medias/article/images/2019/9/5/reflections.jpg" alt></p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Module</span><span class="token operator">>></span> modules <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getSubTypesOf</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>inject<span class="token punctuation">.</span>Module<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> singletons <span class="token operator">=</span>             reflections<span class="token punctuation">.</span><span class="token function">getTypesAnnotatedWith</span><span class="token punctuation">(</span>javax<span class="token punctuation">.</span>inject<span class="token punctuation">.</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>String<span class="token operator">></span> properties <span class="token operator">=</span>       reflections<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">".\*\.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Constructor<span class="token operator">></span> injectables <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getConstructorsAnnotatedWith</span><span class="token punctuation">(</span>javax<span class="token punctuation">.</span>inject<span class="token punctuation">.</span>Inject<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> deprecateds <span class="token operator">=</span>      reflections<span class="token punctuation">.</span><span class="token function">getMethodsAnnotatedWith</span><span class="token punctuation">(</span>javax<span class="token punctuation">.</span>ws<span class="token punctuation">.</span>rs<span class="token punctuation">.</span>Path<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Field<span class="token operator">></span> ids <span class="token operator">=</span>               reflections<span class="token punctuation">.</span><span class="token function">getFieldsAnnotatedWith</span><span class="token punctuation">(</span>javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Id<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> someMethods <span class="token operator">=</span>      reflections<span class="token punctuation">.</span><span class="token function">getMethodsMatchParams</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> voidMethods <span class="token operator">=</span>      reflections<span class="token punctuation">.</span><span class="token function">getMethodsReturn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> pathParamMethods <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getMethodsWithAnyParamAnnotated</span><span class="token punctuation">(</span>PathParam<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> floatToString <span class="token operator">=</span>    reflections<span class="token punctuation">.</span><span class="token function">getConverters</span><span class="token punctuation">(</span>Float<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> parameterNames <span class="token operator">=</span>  reflections<span class="token punctuation">.</span><span class="token function">getMethodsParamNames</span><span class="token punctuation">(</span>Method<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Member<span class="token operator">></span> fieldUsage <span class="token operator">=</span>       reflections<span class="token punctuation">.</span><span class="token function">getFieldUsage</span><span class="token punctuation">(</span>Field<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Member<span class="token operator">></span> methodUsage <span class="token operator">=</span>      reflections<span class="token punctuation">.</span><span class="token function">getMethodUsage</span><span class="token punctuation">(</span>Method<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>Member<span class="token operator">></span> constructorUsage <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getConstructorUsage</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例.1"></a>案例.1</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    Reflections reflections <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reflections</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LukkitPlus<span class="token punctuation">.</span>BUKKIT_EVENTS <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getSubTypesOf</span><span class="token punctuation">(</span>Event<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ClassPool classpath <span class="token operator">=</span> ClassPool<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CtClass eventClass <span class="token operator">=</span> classpath<span class="token punctuation">.</span><span class="token function">makeClass</span><span class="token punctuation">(</span><span class="token string">"online.pizzacrust.lukkitplus"</span> <span class="token operator">+</span>            <span class="token string">".EventCallback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span><span class="token operator">></span> event <span class="token operator">:</span> LukkitPlus<span class="token punctuation">.</span>BUKKIT_EVENTS<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CtMethod eventMethod <span class="token operator">=</span> CtNewMethod<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span>CtClass<span class="token punctuation">.</span>voidType<span class="token punctuation">,</span> <span class="token string">"on"</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getSimpleName</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CtClass</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> classpath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CtClass</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"online"</span> <span class="token operator">+</span>                <span class="token string">".pizzacrust.lukkitplus.EventCallbackGenerator.call($1);"</span><span class="token punctuation">,</span> eventClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        eventClass<span class="token punctuation">.</span><span class="token function">addMethod</span><span class="token punctuation">(</span>eventMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>        AnnotationsAttribute attribute <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationsAttribute</span><span class="token punctuation">(</span>eventClass<span class="token punctuation">.</span><span class="token function">getClassFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">getConstPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> AnnotationsAttribute<span class="token punctuation">.</span>visibleTag<span class="token punctuation">)</span><span class="token punctuation">;</span>        Annotation eventHandlerAnnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Annotation</span><span class="token punctuation">(</span>EventHandler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eventClass                <span class="token punctuation">.</span><span class="token function">getClassFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConstPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        attribute<span class="token punctuation">.</span><span class="token function">addAnnotation</span><span class="token punctuation">(</span>eventHandlerAnnt<span class="token punctuation">)</span><span class="token punctuation">;</span>        eventMethod<span class="token punctuation">.</span><span class="token function">getMethodInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span>attribute<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    eventClass<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Reflections-实践案例"><a href="#Reflections-实践案例" class="headerlink" title="Reflections 实践案例"></a>Reflections 实践案例</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 程序启动     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">getRequestMappingMethod</span><span class="token punctuation">(</span>                <span class="token string">"com.alibaba.sys.portal.core"</span><span class="token punctuation">,</span>                <span class="token string">"com.alibaba.sys.portal.core.controller"</span><span class="token punctuation">,</span> <span class="token string">"com.alibaba.sys.portal.core.service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取指定模块所有方法     *     * @param scanPackage      设置扫描路径     * @param scopePackages    指定范围包     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getRequestMappingMethod</span><span class="token punctuation">(</span>String scanPackage<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> scopePackages<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> mehtodKV <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Reflections reflections <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reflections</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConfigurationBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setUrls</span><span class="token punctuation">(</span>ClasspathHelper<span class="token punctuation">.</span><span class="token function">forPackage</span><span class="token punctuation">(</span>scanPackage<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//扫描超类和类的接口，允许对子类型进行反向查找,扫描类的注释，其中@retention（retentionpolicy.runtime）</span>                <span class="token punctuation">.</span><span class="token function">setScanners</span><span class="token punctuation">(</span>                        <span class="token keyword">new</span> <span class="token class-name">TypeAnnotationsScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token keyword">new</span> <span class="token class-name">MethodParameterScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token keyword">new</span> <span class="token class-name">MethodAnnotationsScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">//指定特定包扫描</span>                <span class="token punctuation">.</span><span class="token function">filterInputsBy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FilterBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">includePackage</span><span class="token punctuation">(</span>scopePackages<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取 RequestMapping 所有的方法的类</span>        Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> allClass <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getTypesAnnotatedWith</span><span class="token punctuation">(</span>RestController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> serviceClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allClass<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>tClass <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            Set<span class="token operator">&lt;</span>Annotation<span class="token operator">></span> annotationHashSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Annotation<span class="token operator">></span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>tClass<span class="token punctuation">.</span><span class="token function">getDeclaredAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            annotationHashSet<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>annotation <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>annotation<span class="token punctuation">.</span><span class="token function">annotationType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>Service<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    serviceClass<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allClass<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>serviceClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">getRestfulApiInControllerPackage</span><span class="token punctuation">(</span>mehtodKV<span class="token punctuation">,</span>reflections<span class="token punctuation">,</span>allClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/**     * 扫描获取Controller 包里的接口     *     * @param mehtodKV     * @param reflections     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getRestfulApiInControllerPackage</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> mehtodKV<span class="token punctuation">,</span> Reflections reflections<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> typeClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> setMethods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        typeClass<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>tClass <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//直接获取方法</span>            Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredmethods <span class="token operator">=</span> tClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//条件过滤</span>            CollectionUtils<span class="token punctuation">.</span><span class="token function">arrayToList</span><span class="token punctuation">(</span>declaredmethods<span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>tMethod <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                        Method method <span class="token operator">=</span> <span class="token punctuation">(</span>Method<span class="token punctuation">)</span> tMethod<span class="token punctuation">;</span>                        setMethods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tClass<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 按字母排序</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> methodList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>setMethods<span class="token punctuation">)</span><span class="token punctuation">;</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>methodList<span class="token punctuation">,</span> Collator<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Locale<span class="token punctuation">.</span>CHINA<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取存在的所有的方法的类</span>        Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> methods <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getMethodsAnnotatedWith</span><span class="token punctuation">(</span>RequestMapping<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        methods<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>reflections<span class="token punctuation">.</span><span class="token function">getMethodsAnnotatedWith</span><span class="token punctuation">(</span>PostMapping<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        methods<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>method <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>ApiOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mehtodKV<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>ApiOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接口总数量:"</span> <span class="token operator">+</span> setMethods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        methodList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>methodName <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    methodName <span class="token operator">=</span> StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>mehtodKV<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> methodName <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">:</span> methodName <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> mehtodKV<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//首字母小写处理</span>                    String resource <span class="token operator">=</span> methodName<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>methodName<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> methodName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>反射 <code>Class</code>,<code>Method</code>,<code>Constructor</code>,<code>Field</code>,<code>Member</code>等成员可自行通过JDK API 查阅相关资料进行更在细致化内容获取<br><em>Method</em><br><img src="/medias/article/images/2019/9/5/jdk-api.jpg.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Framework源码之SpringFactoriesLoader</title>
      <link href="/2019/08/29/Spring%20Framework%E6%BA%90%E7%A0%81%E4%B9%8BSpringFactoriesLoader/"/>
      <url>/2019/08/29/Spring%20Framework%E6%BA%90%E7%A0%81%E4%B9%8BSpringFactoriesLoader/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>类名</th><th>所在包</th></tr></thead><tbody><tr><td><code>SpringFactoriesLoader</code></td><td><code>org.springframework.core.io.support</code></td></tr></tbody></table><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/support/SpringFactoriesLoader.html" target="_blank" rel="noopener">官方链接</a></p><blockquote><p>本文源代码基于 springboot 2.1.6,跟之前 springboot 1.5.x 版本相比，SpringFactoriesLoader实现已经有了变化，比如在新的实现中已经加入了缓存机制。如果相应的文件需要被读取多次的话，第一次读取后会缓存起来，之后的读取会使用缓存数据。</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>该类并不对外暴露给应用开发者使用，而是spring框架自己使用的内部工具类，本身被声明为 <code>abstract</code>,不可以被实例化。</p><p>在 Springboot 应用启动的过程中，这个类的工作很重要， 启动逻辑使用该类从<code>classpath</code>上所有jar包中找出各自的 <code>META-INF/spring.factories</code> 属性文件，并分析出其中定义的工厂类。这些工厂类进而被启动逻辑使用，应用于进一步初始化工作</p><h2 id="公开成员介绍"><a href="#公开成员介绍" class="headerlink" title="公开成员介绍"></a>公开成员介绍</h2><ol><li><p>类静态成员常量 <code>final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;</code><br>此常量定义了该工具类要从每个jar包中提取的工厂类定义属性文件的相对路径。</p></li><li><p>类静态方法 <code>&lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</code><br>此方法会读取<code>classpath</code>上所有的jar包中的所有 <code>META-INF/spring.factories</code>属性文件，找出其中定义的匹配类型 <code>factoryClass</code>的工厂类，然后创建每个工厂类的对象/实例，并返回这些工厂类对象/实例的列表。</p></li><li><p>类静态方法 <code>List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</code><br>此方法会读取<code>classpath</code>上所有的jar包中的所有<code>META-INF/spring.factories</code>属性文件，找出其中定义的匹配类型<code>factoryClass</code>的工厂类，然后并返回这些工厂类的名字列表，注意是包含包名的全限定名。</p></li></ol><h2 id="源代码解析"><a href="#源代码解析" class="headerlink" title="源代码解析"></a>源代码解析</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* * Copyright 2002-2018 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>io<span class="token punctuation">.</span>support<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Enumeration<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>logging<span class="token punctuation">.</span>Log<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>logging<span class="token punctuation">.</span>LogFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AnnotationAwareOrderComparator<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>io<span class="token punctuation">.</span>UrlResource<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Nullable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Assert<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ClassUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ConcurrentReferenceHashMap<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedMultiValueMap<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>MultiValueMap<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ReflectionUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * General purpose factory loading mechanism for internal use within the framework. *  * 仅限框架内部使用的工具类，通用目的的工厂加载机制。 * * &lt;p>{@code SpringFactoriesLoader} {@linkplain #loadFactories loads} and instantiates * factories of a given type from {@value #FACTORIES_RESOURCE_LOCATION} files which * may be present in multiple JAR files in the classpath. The {@code spring.factories} * file must be in {@link Properties} format, where the key is the fully qualified * name of the interface or abstract class, and the value is a comma-separated list of * implementation class names. For example: *  * SpringFactoriesLoader#loadFactories设计用于加载和实例化指定类型的工厂，这些工厂类型的定义 * 来自classpath中多个JAR包内常量FACTORIES_RESOURCE_LOCATION所指定的那些spring.factories文件。 * spring.factories文件的格式必须是属性文件格式，每条属性的key必须是接口或者抽象类的全限定名， * 而属性值value是一个逗号分割的实现类的名称 *  * 举例来讲，一条属性定义如下: * example.MyService=example.MyServiceImpl1,example.MyServiceImpl2 *  * 这里 example.MyService 是接口或者抽象类的全限定名, MyServiceImpl1和MyServiceImpl2是相应的 * 两个实现类。 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SpringFactoriesLoader</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The location to look for factories.     * &lt;p>Can be present in multiple JAR files.     *      * 在classpath中的多个JAR中要扫描的工厂配置文件的在本JAR包中的路径。     * 实际上，Springboot的每个 autoconfigure包都包含一个这样的文件。     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String FACTORIES_RESOURCE_LOCATION <span class="token operator">=</span> <span class="token string">"META-INF/spring.factories"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Log logger <span class="token operator">=</span> LogFactory<span class="token punctuation">.</span><span class="token function">getLog</span><span class="token punctuation">(</span>SpringFactoriesLoader<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>ClassLoader<span class="token punctuation">,</span> MultiValueMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentReferenceHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SpringFactoriesLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Load and instantiate the factory implementations of the given type from     * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.     * &lt;p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.     * &lt;p>If a custom instantiation strategy is required, use {@link #loadFactoryNames}     * to obtain all registered factory names.     * @param factoryClass the interface or abstract class representing the factory     * @param classLoader the ClassLoader to use for loading (can be {@code null} to use the default)     * @throws IllegalArgumentException if any factory implementation class cannot     * be loaded or if an error occurs while instantiating any factory     * @see #loadFactoryNames     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">loadFactories</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> factoryClass<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>factoryClass<span class="token punctuation">,</span> <span class="token string">"'factoryClass' must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ClassLoader classLoaderToUse <span class="token operator">=</span> classLoader<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>classLoaderToUse <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            classLoaderToUse <span class="token operator">=</span> SpringFactoriesLoader<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 加载类型为factoryClass的工厂的名称，其实是一个个的全限定类名，使用指定的classloader：</span>        <span class="token comment" spellcheck="true">// classLoaderToUse</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> factoryNames <span class="token operator">=</span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>factoryClass<span class="token punctuation">,</span> classLoaderToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Loaded ["</span> <span class="token operator">+</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"] names: "</span> <span class="token operator">+</span> factoryNames<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        List<span class="token operator">&lt;</span>T<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>factoryNames<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 实例化所加载的每个工厂类</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String factoryName <span class="token operator">:</span> factoryNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">instantiateFactory</span><span class="token punctuation">(</span>factoryName<span class="token punctuation">,</span> factoryClass<span class="token punctuation">,</span> classLoaderToUse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 排序</span>        AnnotationAwareOrderComparator<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Load the fully qualified class names of factory implementations of the     * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given     * class loader.     * @param factoryClass the interface or abstract class representing the factory     * @param classLoader the ClassLoader to use for loading resources; can be     * {@code null} to use the default     * @throws IllegalArgumentException if an error occurs while loading factory names     * @see #loadFactories     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factoryClass<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String factoryClassName <span class="token operator">=</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 使用指定的classloader扫描classpath上所有的JAR包中的文件META-INF/spring.factories，加载其中的多值</span>        <span class="token comment" spellcheck="true">// 工厂属性定义，使用多值Map的形式返回，</span>        <span class="token comment" spellcheck="true">// 2. 返回多值Map中key为factoryClassName的工厂名称列表，如果没有相应的entry，返回空列表而不是返回null</span>        <span class="token keyword">return</span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>factoryClassName<span class="token punctuation">,</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 使用指定的classloader扫描classpath上所有的JAR包中的文件META-INF/spring.factories，加载其中的多值     * 工厂属性定义，使用多值Map的形式返回    **/</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MultiValueMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> result <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 扫描classpath上所有JAR中的文件META-INF/spring.factories</span>            Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> urls <span class="token operator">=</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> null <span class="token operator">?</span>                    classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span> <span class="token operator">:</span>                    ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedMultiValueMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 找到的每个META-INF/spring.factories文件都是一个Properties文件，将其内容</span>                <span class="token comment" spellcheck="true">// 加载到一个 Properties 对象然后处理其中的每个属性</span>                URL url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                UrlResource resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>                Properties properties <span class="token operator">=</span> PropertiesLoaderUtils<span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> entry <span class="token operator">:</span> properties<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 获取工厂类名称（接口或者抽象类的全限定名）</span>                    String factoryClassName <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 将逗号分割的属性值逐个取出，然后放到多值Map结果result中去。</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>String factoryName <span class="token operator">:</span> StringUtils<span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>factoryClassName<span class="token punctuation">,</span> factoryName<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unable to load factories from location ["</span> <span class="token operator">+</span>                    FACTORIES_RESOURCE_LOCATION <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    *     * @param instanceClassName  工厂实现类全限定名称    * @param factoryClass       工厂所属接口/抽象类全限定名称    * @param classLoader        所要使用的类加载器    * @param &lt;T>    * @return     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">instantiateFactory</span><span class="token punctuation">(</span>String instanceClassName<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> factoryClass<span class="token punctuation">,</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> instanceClass <span class="token operator">=</span> ClassUtils<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>instanceClassName<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>factoryClass<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>instanceClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                        <span class="token string">"Class ["</span> <span class="token operator">+</span> instanceClassName <span class="token operator">+</span> <span class="token string">"] is not assignable to ["</span> <span class="token operator">+</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> ReflectionUtils<span class="token punctuation">.</span><span class="token function">accessibleConstructor</span><span class="token punctuation">(</span>instanceClass<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unable to instantiate factory class: "</span> <span class="token operator">+</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><em>spring.factories</em></p><pre class=" language-yaml"><code class="language-yaml">org.springframework.boot.SpringApplicationRunListener=\  com.landray.framework.support.loader.SystemLoadListener<span class="token punctuation">,</span>com.landray.component.config.DefaultConfigListener<span class="token punctuation">,</span>com.landray.component.logback.LogbackListener<span class="token punctuation">,</span>com.landray.component.banner.BannerListener</code></pre><p><img src="/medias/article/images/2019/8/29/SpringApplicationRunListener.jpg" alt><br><em>LogbackListener.class</em></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>landray<span class="token punctuation">.</span>component<span class="token punctuation">.</span>logback<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicBoolean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>logging<span class="token punctuation">.</span>LoggingApplicationListener<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ConfigurableApplicationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>env<span class="token punctuation">.</span>ConfigurableEnvironment<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ResourceUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>landray<span class="token punctuation">.</span>component<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>listener<span class="token punctuation">.</span>AbstractApplicationRunListener<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * logbak统一标准的配置. * 该监听器生效配置位于META-INF/spring.factories文件配置中. * 当自己指定了logback配置时，该默认配置失效。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogbackListener</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractApplicationRunListener</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 监听器排序号，需高于LoggingApplicationListener的默认优先级     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> LOGBACK_ORDER <span class="token operator">=</span> LoggingApplicationListener<span class="token punctuation">.</span>DEFAULT_ORDER <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 默认logback配置文件名     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String LOGBACK_CFG_NAME <span class="token operator">=</span> <span class="token string">"/logback-config.xml"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 监听器是否已执行标示,该监听器只需要执行一次     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> AtomicBoolean executed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LogbackListener</span><span class="token punctuation">(</span>SpringApplication app<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">environmentPrepared</span><span class="token punctuation">(</span>ConfigurableEnvironment environment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>executed<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String logConfig <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>LoggingApplicationListener<span class="token punctuation">.</span>CONFIG_PROPERTY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>logConfig<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                URL url <span class="token operator">=</span> LogbackListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>LOGBACK_CFG_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>                String filePath <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>filePath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>ResourceUtils<span class="token punctuation">.</span>JAR_FILE_EXTENSION<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    filePath <span class="token operator">=</span> ResourceUtils<span class="token punctuation">.</span>JAR_URL_PREFIX <span class="token operator">+</span> filePath<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>LoggingApplicationListener<span class="token punctuation">.</span>CONFIG_PROPERTY<span class="token punctuation">,</span> filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextPrepared</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextLoaded</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">started</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">running</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">,</span> Throwable exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> LOGBACK_ORDER<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java AtomicBoolean</title>
      <link href="/2019/08/28/Java%20AtomicBoolean/"/>
      <url>/2019/08/28/Java%20AtomicBoolean/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-AtomicBoolean"><a href="#Java-AtomicBoolean" class="headerlink" title="Java AtomicBoolean"></a>Java AtomicBoolean</h2><p><code>java.util.concurrent.atomic.AtomicBoolean</code>类提供了可以原子读取和写入的底层布尔值的操作，并且还包含高级原子操作。 <code>AtomicBoolean</code>支持基础布尔变量上的原子操作。 它具有获取和设置方法，如在<code>volatile</code>变量上的读取和写入。 也就是说，一个集合与同一变量上的任何后续get相关联。 原子<code>compareAndSet</code>方法也具有这些内存一致性功能。</p><a id="more"></a><p><code>Atomic</code>就是原子性的意思，即能够保证在高并发的情况下只有一个线程能够访问这个属性值</p><p><strong><em>AtomicBoolean类中的方法</em></strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public boolean compareAndSet(boolean expect, boolean update)</code></td><td>如果当前值==期望值，则将该值原子设置为给定的更新值</td></tr><tr><td><code>public boolean get()</code></td><td>返回当前值。</td></tr><tr><td><code>public boolean getAndSet(boolean newValue)</code></td><td>将原子设置为给定值并返回上一个值。</td></tr><tr><td><code>public void lazySet(boolean newValue)</code></td><td>最终设定为给定值。。</td></tr><tr><td><code>public void set(boolean newValue)</code></td><td>无条件地设置为给定的值。</td></tr><tr><td><code>public String  toString()</code></td><td>返回当前值的<code>String</code>表示形式。</td></tr><tr><td><code>public boolean get()</code></td><td>返回当前值。</td></tr><tr><td><code>public boolean weakCompareAndSet(boolean expect, boolean update)</code></td><td>如果当前值==期望值，则将该值原子设置为给定的更新值。</td></tr></tbody></table><p>一般情况下，我们使用 <code>AtomicBoolean</code> 高效并发处理 “只初始化一次” 的功能要求</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> AtomicBoolean initialized <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span> initialized<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 这里放置初始化代码....</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果没有<code>AtomicBoolean</code>，我们可以使用<code>volatile</code>做如下操作：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> initialized <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> initialized <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        initialized <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里初始化代码....</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>AtomicBoolean</code> 源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">;</span><span class="token keyword">import</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * A {@code boolean} value that may be updated atomically. See the * {@link java.util.concurrent.atomic} package specification for * description of the properties of atomic variables. An * {@code AtomicBoolean} is used in applications such as atomically * updated flags, and cannot be used as a replacement for a * {@link java.lang.Boolean}. * * @since 1.5 * @author Doug Lea */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicBoolean</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 4654671469794556979L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// setup to use Unsafe.compareAndSwapInt for updates</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>                <span class="token punctuation">(</span>AtomicBoolean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Creates a new {@code AtomicBoolean} with the given initial value.     *     * @param initialValue the initial value     */</span>    <span class="token keyword">public</span> <span class="token function">AtomicBoolean</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> initialValue <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Creates a new {@code AtomicBoolean} with initial value {@code false}.     */</span>    <span class="token keyword">public</span> <span class="token function">AtomicBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns the current value.     *     * @return the current value     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Atomically sets the value to the given updated value     * if the current value {@code ==} the expected value.     *     * @param expect the expected value     * @param update the new value     * @return {@code true} if successful. False return indicates that     * the actual value was not equal to the expected value.     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> expect<span class="token punctuation">,</span> <span class="token keyword">boolean</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> e <span class="token operator">=</span> expect <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> update <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> e<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Atomically sets the value to the given updated value     * if the current value {@code ==} the expected value.     *     * &lt;p>&lt;a href="package-summary.html#weakCompareAndSet">May fail     * spuriously and does not provide ordering guarantees&lt;/a>, so is     * only rarely an appropriate alternative to {@code compareAndSet}.     *     * @param expect the expected value     * @param update the new value     * @return {@code true} if successful     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">weakCompareAndSet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> expect<span class="token punctuation">,</span> <span class="token keyword">boolean</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> e <span class="token operator">=</span> expect <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> update <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> e<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Unconditionally sets to the given value.     *     * @param newValue the new value     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> newValue <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Eventually sets to the given value.     *     * @param newValue the new value     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> newValue <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        unsafe<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Atomically sets to the given value and returns the previous value.     *     * @param newValue the new value     * @return the previous value     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> prev<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns the String representation of the current value.     * @return the String representation of the current value     */</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Boolean<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可见 <code>AtomicBoolean</code>就是使用了<code>Volatile</code>属性来完成的    </p><p>Java6 以后出现的很多的原子行的类，除了上述我们所说的AtomicBoolean以外   </p><ul><li>基本类：<br><code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code></li><li>引用类型：<br><code>AtomicReference</code>、<code>AtomicReference</code>的ABA实例、<code>AtomicStampedRerence</code>、<code>AtomicMarkableReference</code>；</li><li>数组类型：<br><code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code></li><li>属性原子修改器（Updater）：<br><code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicReferenceFieldUpdater</code>                                             </li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中常用注解</title>
      <link href="/2019/08/27/SpringBoot%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/08/27/SpringBoot%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot中常用注解"><a href="#SpringBoot中常用注解" class="headerlink" title="SpringBoot中常用注解"></a>SpringBoot中常用注解</h2><h3 id="Transient-注解"><a href="#Transient-注解" class="headerlink" title="@Transient 注解"></a>@Transient 注解</h3><p>实体类中使用了@Table注解后，想要添加表中不存在字段，就要使用@Transient这个注解了。在网上找的方法是要将这个注解添加到自定义字段的get方法上，这样做了之后程序报错，最后试了将该注解添加到定义该字段的头部即可</p><p>例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Id</span><span class="token annotation punctuation">@Access</span><span class="token punctuation">(</span>AccessType<span class="token punctuation">.</span>PROPERTY<span class="token punctuation">)</span><span class="token annotation punctuation">@Length</span><span class="token punctuation">(</span>max<span class="token operator">=</span>IDGenerator<span class="token punctuation">.</span>LEN<span class="token punctuation">)</span><span class="token annotation punctuation">@MetaProperty</span><span class="token punctuation">(</span>messageKey<span class="token operator">=</span><span class="token string">"property.fdId"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String fdId<span class="token punctuation">;</span><span class="token annotation punctuation">@Access</span><span class="token punctuation">(</span>AccessType<span class="token punctuation">.</span>PROPERTY<span class="token punctuation">)</span><span class="token annotation punctuation">@MetaProperty</span><span class="token punctuation">(</span>messageKey<span class="token operator">=</span><span class="token string">"property.fdTenantId"</span><span class="token punctuation">)</span><span class="token keyword">private</span> Integer fdTenantId<span class="token punctuation">;</span><span class="token annotation punctuation">@Transient</span><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> extendProps <span class="token operator">=</span> newHashMap<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><a id="more"></a><h3 id="Access注解"><a href="#Access注解" class="headerlink" title="@Access注解"></a>@Access注解</h3><p>• JPA规范中可以通过@Access注解的来指定实体类的访问策略</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/***Usedtospecifyanaccesstypetobeappliedtoanentityclass,*mappedsuperclass,orembeddableclass,ortoaspecificattribute*ofsuchaclass.**@sinceJavaPersistence2.0*/</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>TYPE<span class="token punctuation">,</span>METHOD<span class="token punctuation">,</span>FIELD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Access</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/***(Required)Specificationoffield-orproperty-basedaccess.*/</span><span class="token function">AccessTypevalue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>• @Access注解中可以接收两种AccessType类型的值：AccessType.FIELD和AccessType.PROPERTY。</p><ul><li>AccessType.FIELD指通过类中的字段来获取对应的表字段信息。此时，JPA只关注类中的字段名，并转换为对应的表字段信息，而不会读取getter方法和setter方法上的表字段注解信息。</li><li>AccessType.PROPERTY指通过类中的getter方法和setter方法来获取对应的表字段信息。此时，JPA只关注类中getter方法和setter方法上的表字段注解信息，并转换为对应的表字段信息。</li></ul><p>JPA的关联规则可以根据喜好而任选其一进行配置使用，在对应生成表字段信息时没有区别。从@Access注解的@Target配置信息中可知其可以配置在类，字段或方法上。以此来满足不同场景下表字段信息的扫描规则需求</p><h3 id="MappedSuperClass-注解"><a href="#MappedSuperClass-注解" class="headerlink" title="@MappedSuperClass 注解"></a>@MappedSuperClass 注解</h3><p>这个注解表示在父类上面的，用来标识父类</p><p>基于代码复用和模型分离的思想，在项目开发中使用JPA的@MappedSuperclass注解将实体类的多个属性分别封装到不同的非实体类中。例如，数据库表中都需要id来表示编号，id是这些映射实体类的通用的属性，交给jpa统一生成主键id编号，那么使用一个父类来封装这些通用属性，并用@MappedSuperclas标识。</p><p><strong>注意:</strong><br>    1. 标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。<br>    2. 标注为@MappedSuperclass的类不能再标注@Entity或@Table注解，也无需实现序列化接口。</p><h3 id="Convert-注解"><a href="#Convert-注解" class="headerlink" title="@Convert 注解"></a>@Convert 注解</h3><p>用于数据库属性类型与java存储的类型做转换，例如枚举类型，在存储到数据库时或者在数据库取出来时，不用手动转换。</p><p>如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysPortalCustomizePage</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractPortalCustomizeEntity</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 是否默认页面     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> fdDefault <span class="token operator">=</span> Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 是否为默认页面     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> fdIsNavPage <span class="token operator">=</span> Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 被复制页面ID     */</span>    <span class="token keyword">private</span> String fdPageId<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 父级页面ID     */</span>    <span class="token keyword">private</span> String fdParentPageId<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 自定义页面名称     */</span>    <span class="token keyword">private</span> String fdPageName<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 页面自定义类型     */</span>    <span class="token annotation punctuation">@Convert</span><span class="token punctuation">(</span>converter <span class="token operator">=</span> CustomizePageType<span class="token punctuation">.</span>Converter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> CustomizePageType fdType<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">enum</span> CustomizePageType <span class="token keyword">implements</span> <span class="token class-name">IEnum</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 用户自定义的     */</span>    <span class="token function">CUSTOMIZED</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"sys-portal:enum.customPageType.customized"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/**     *复制的     */</span>    <span class="token function">COPYED</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"sys-portal:enum.customPageType.copyed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer value<span class="token punctuation">;</span>    <span class="token keyword">private</span> String messageKey<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getMessageKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> messageKey<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Converter</span>            <span class="token keyword">extends</span> <span class="token class-name">IEnum<span class="token punctuation">.</span>Converter</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> CustomizePageType<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Lombok-注解"><a href="#Lombok-注解" class="headerlink" title="Lombok 注解"></a>Lombok 注解</h3><p><strong><em>@Data</em></strong><br>    使用这个注解，就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，注解后在编译时会自动加进去</p><p><strong><em>@AllArgsConstructor</em></strong><br>    使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</p><p><strong><em>@NoArgsConstructor</em></strong><br>    使用后创建一个无参构造函数</p><p><strong><em>@Builder</em></strong><br>    关于Builder较为复杂一些，Builder的作用之一是为了解决在某个类有很多构造函数的情况，也省去写很多构造函数的麻烦，在设计模式中的思想是：用一个内部类去实例化一个对象，避免一个类出现过多构造函数</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysPortalCustomizePage</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractPortalCustomizeEntity</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 是否默认页面     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> fdDefault <span class="token operator">=</span> Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 是否为默认页面     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> fdIsNavPage <span class="token operator">=</span> Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 被复制页面ID     */</span>    <span class="token keyword">private</span> String fdPageId<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 父级页面ID     */</span>    <span class="token keyword">private</span> String fdParentPageId<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 自定义页面名称     */</span>    <span class="token keyword">private</span> String fdPageName<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 页面自定义类型     */</span>    <span class="token annotation punctuation">@Convert</span><span class="token punctuation">(</span>converter <span class="token operator">=</span> CustomizePageType<span class="token punctuation">.</span>Converter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> CustomizePageType fdType<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第20题:有效括号</title>
      <link href="/2019/08/02/LeetCode%E7%AC%AC20%E9%A2%98%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2019/08/02/LeetCode%E7%AC%AC20%E9%A2%98%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode第20题-有效括号"><a href="#LeetCode第20题-有效括号" class="headerlink" title="LeetCode第20题:有效括号"></a>LeetCode第20题:有效括号</h2><p><a href="https://lishangzhi.github.io/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88/">数据结构：栈</a>  </p><h3 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h3><p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><a id="more"></a><p>示例 1:<br><code>输入: &quot;()&quot;输出: true</code><br>示例 2:<br><code>输入: &quot;()[]{}&quot;输出: true</code><br>示例 3:<br><code>输入: &quot;(]&quot;输出: false</code><br>示例 4:<br><code>输入: &quot;([)]&quot;输出: false</code><br>示例 5:<br><code>输入: &quot;{[]}&quot;输出: true</code></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>关于有效括号表达式的一个有趣属性是有效表达式的子表达式也应该是有效表达式。（不是每个子表达式）例如<br><img src="/medias/article/images/2019/8/2/1.png" alt></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>初始化栈 S。</li><li>一次处理表达式的每个括号。</li><li>如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 子表达式。</li><li>如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。</li><li>如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。<br>我们来看一下该算法的动画演示，然后转到实现部分。</li></ol><p><img src="/medias/article/images/2019/8/2/STACK-1.png" alt><br><img src="/medias/article/images/2019/8/2/STACK-2.png" alt><br><img src="/medias/article/images/2019/8/2/STACK-3.png" alt><br><img src="/medias/article/images/2019/8/2/STACK-4.png" alt><br><img src="/medias/article/images/2019/8/2/STACK-5.png" alt><br>以此类推</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span> mappings<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> topElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'#'</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>topElement <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: bool        """</span>        <span class="token comment" spellcheck="true"># The stack to keep track of opening brackets.</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># Hash map for keeping track of mappings. This keeps the code very clean.</span>        <span class="token comment" spellcheck="true"># Also makes adding more types of parenthesis easier</span>        mapping <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">")"</span><span class="token punctuation">:</span> <span class="token string">"("</span><span class="token punctuation">,</span> <span class="token string">"}"</span><span class="token punctuation">:</span> <span class="token string">"{"</span><span class="token punctuation">,</span> <span class="token string">"]"</span><span class="token punctuation">:</span> <span class="token string">"["</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true"># For every bracket in the expression.</span>        <span class="token keyword">for</span> char <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># If the character is an closing bracket</span>            <span class="token keyword">if</span> char <span class="token keyword">in</span> mapping<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># Pop the topmost element from the stack, if it is non empty</span>                <span class="token comment" spellcheck="true"># Otherwise assign a dummy value of '#' to the top_element variable</span>                top_element <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> stack <span class="token keyword">else</span> <span class="token string">'#'</span>                <span class="token comment" spellcheck="true"># The mapping for the opening bracket in our hash and the top</span>                <span class="token comment" spellcheck="true"># element of the stack don't match, return False</span>                <span class="token keyword">if</span> mapping<span class="token punctuation">[</span>char<span class="token punctuation">]</span> <span class="token operator">!=</span> top_element<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># We have an opening bracket, simply push it onto the stack.</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>char<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># In the end, if the stack is empty, then we have a valid expression.</span>        <span class="token comment" spellcheck="true"># The stack won't be empty for cases like ((()</span>        <span class="token keyword">return</span> <span class="token operator">not</span> stack</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 中心扩散 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot配置加载顺序</title>
      <link href="/2019/08/01/SpringBoot%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
      <url>/2019/08/01/SpringBoot%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot配置加载顺序"><a href="#SpringBoot配置加载顺序" class="headerlink" title="SpringBoot配置加载顺序"></a>SpringBoot配置加载顺序</h2><blockquote><p>昨天被loback日志折腾一宿,发现问题、定位问题、处理问题一路心酸，原因在于对SpringBoot配置的加载顺序不了解，这边相对复盘下处理过程</p></blockquote><ul><li><ol><li>核心工程包中定义了 <code>logback-config.xml</code> </li></ol></li><li><ol start="2"><li>项目启动工程包中指定日志配置 <code>loback.config:classpath:logback-config.xml</code> 即：<code>System.setProperty(&quot;loback.config&quot;,&quot;classpath:logback-config.xml&quot;)</code></li></ol></li><li><ol start="3"><li>服务项目启动以来启动工程 自定义配置加载失效 <code>System.setProperty(&quot;loback.config&quot;,&quot;classpath:logback-aip.xml&quot;)</code></li></ol></li></ul><a id="more"></a><h3 id="基础配置方式"><a href="#基础配置方式" class="headerlink" title="基础配置方式"></a>基础配置方式</h3><p><strong>可以使用以下几种方式来加载配置</strong><br>1、<code>properties</code>文件<br>2、<code>YAML</code>文件<br>3、系统环境变量<br>4、命令行参数<br>等…一些常用的配置方式</p><p><strong>Spring Beans 里面直接使用这些配置文件中加载的值</strong><br>1、使用 <code>@Value</code> 注解直接注入对应的值，这能获取到 <code>Spring</code> 中 <code>Environment</code> 的值；<br>2、使用 <code>@ConfigurationProperties</code> 注解把对应的值绑定到一个对象；<br>3、直接获取注入 <code>Environment</code> 进行获取；<br>配置属性的方式很多，<code>Spring boot</code>使用了一种独有的 <code>PropertySource</code> 可以很方便的覆盖属性的值。</p><h3 id="配置属性加载的顺序"><a href="#配置属性加载的顺序" class="headerlink" title="配置属性加载的顺序"></a>配置属性加载的顺序</h3><p>1、开发者工具 <code>Devtools</code> 全局配置参数；</p><p>2、单元测试上的 <code>@TestPropertySource</code> 注解指定的参数；</p><p>3、单元测试上的 <code>@SpringBootTest</code> 注解指定的参数；</p><p>4、命令行指定的参数，如 <code>java -jar springboot.jar -Dlogging.config=classpath:config/logback-spring.xml</code>；</p><p>5、命令行中的 <code>SPRING_APPLICATION_JSONJSON</code> 指定参数, 如 <code>java -Dspring.application.json=&#39;{&quot;logging.config&quot;:&quot;config/logback-spring.xml&quot;}&#39; -jar springboot.jar</code></p><p>6、<code>ServletConfig</code> 初始化参数；</p><p>7、<code>ServletContext</code> 初始化参数；</p><p>8、JNDI参数（如 <code>java:comp/env/spring.application.json</code>）；</p><p>9、Java系统参数（来源：<code>System.getProperties()</code>）；</p><p>10、操作系统环境变量参数；</p><p>11、<code>RandomValuePropertySource</code> 随机数，仅匹配：<code>ramdom.*</code>；</p><p>12、JAR包外面的配置文件参数（<code>application-{profile}.properties（YAML）</code>）</p><p>13、JAR包里面的配置文件参数（<code>application-{profile}.properties（YAML）</code>）</p><p>14、JAR包外面的配置文件参数（<code>application.properties（YAML）</code>）</p><p>15、JAR包里面的配置文件参数（<code>application.properties（YAML）</code>）</p><p>16、<code>@Configuration</code>配置文件上 <code>@PropertySource</code> 注解加载的参数；</p><p>17、默认参数（通过 <code>SpringApplication.setDefaultProperties</code> 指定）；</p><p><font color="red"><strong>数字小的优先级越高，即数字小的会覆盖数字大的参数值，我们来实践下，验证以上配置参数的加载顺序</strong></font></p><h3 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h3><p>1、开发者工具 <code>Devtools</code> 全局配置参数<br><img src="/medias/article/images/2019/8/1/1.png" alt><br>2、在主应用程序中添加 Java 系统参数</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> CommandLineRunner <span class="token function">commandLineRunner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"logging.config"</span><span class="token punctuation">,</span> <span class="token string">"config/logback-spring.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3、在 application.properties 文件中添加属性。<br><code>logging.config:config/logback-spring.xml</code><br>根据以上参数动态调整，发现参数会被正确被覆盖。了解了 Spring Boot 各种配置的加载顺序，如果配置被覆盖了我们就知道是什么问题了。</p><h4 id="loback-配置拓展"><a href="#loback-配置拓展" class="headerlink" title="loback 配置拓展"></a>loback 配置拓展</h4><p><code>&lt;include resource=&quot;logback-oper.xml&quot; optional=&quot;true&quot;/&gt;</code> 在loback配置文件上指定对应应用配置加载<br><img src="/medias/article/images/2019/8/1/2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：哈希表</title>
      <link href="/2019/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2019/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构：哈希表"><a href="#数据结构：哈希表" class="headerlink" title="数据结构：哈希表"></a>数据结构：哈希表</h2><p>哈希表存储的是由键（key）和值（value）组成的数据<br><img src="/medias/article/images/2019/7/26/1.png" alt><br>例如，我们将每个人的性别作为数据进行存储，键为人名，值为对应的性别。<br><img src="/medias/article/images/2019/7/26/2.png" alt><br>此处准备了6个箱子（即长度为6的数组）来存储数据。假设我们需要查询Ally的性别，由于不知道Ally的数据存储在哪个箱子里，所以只能从头开始查询。这个操作便叫作“线性查找”（线性查找的讲解在3-1节）。<br><img src="/medias/article/images/2019/7/26/3.png" alt><br>0号箱子中存储的键是Joe而不是Ally。<br><img src="/medias/article/images/2019/7/26/4.png" alt><br>1号箱子中的也不是Ally。<br>同样，2号、3号箱子中的也都不是Ally。<br>查找到4号箱子的时候，发现其中数据的键为<br><img src="/medias/article/images/2019/7/26/7.jpg" alt><br>Ally。把键对应的值取出，我们就知道Ally的性别为女（F）了。<br>数据量越多，线性查找耗费的时间就越长。由此可知：由于数据的查询较为耗时，所以此处并不适合使用数组来存储数据。<br>但使用哈希表便可以解决这个问题。首先准备好数组，这次我们用5个箱子的数组来存储数据。<br>尝试把Joe存进去。<br><img src="/medias/article/images/2019/7/26/8.jpg" alt><br>使用哈希函数（Hash）计算Joe的键，也就是字符串“Joe”的哈希值。得到的结果为4928<br><img src="/medias/article/images/2019/7/26/9.jpg" alt><br>将得到的哈希值除以数组的长度5，求得其余数。这样的求余运算叫作“mod运算”。此处mod运算的结果为3。<br><img src="/medias/article/images/2019/7/26/10.jpg" alt><br>因此，我们将Joe的数据存进数组的3号箱子中。重复前面的操作，将其他数据也存进数组中。<br><img src="/medias/article/images/2019/7/26/11.jpg" alt><br>Sue键的哈希值为7291, mod 5的结果为1，将Sue的数据存进1号箱中。<br>Dan键的哈希值为1539, mod 5的结果为4，将Dan的数据存进4号箱中。<br><img src="/medias/article/images/2019/7/26/14.png" alt><br>Nell键的哈希值为6276, mod 5的结果为1。本应将其存进数组的1号箱中，但此时1号箱中已经存储了Sue的数据。这种存储位置重复了的情况便叫作“冲突”。<br><img src="/medias/article/images/2019/7/26/15.png" alt><br>遇到这种情况，可使用链表在已有数据的后面继续存储新的数据。<br><img src="/medias/article/images/2019/7/26/16.png" alt><br>Ally键的哈希值为9143, mod 5的结果为3。本应将其存储在数组的3号箱中，但3号箱中已经有了Joe的数据，所以使用链表，在其后面存储Ally的数据。<br>Bob键的哈希值为5278, mod 5的结果为3。本应将其存储在数组的3号箱中，但3号箱中已经有了Joe和Ally的数据，所以使用链表，在Ally的后面继续存储Bob的数据。<br>像这样存储完所有数据，哈希表也就制作完成了。<br>接下来讲解数据的查询方法。假设我们要查询Dan的性别。<br>为了知道Dan存储在哪个箱子里，首先需要算出Dan键的哈希值，然后对其进行mod运算。最后得到的结果为4，于是我们知道了它存储在4号箱中。<br>查看4号箱可知，其中的数据的键与Dan一致，于是取出对应的值。由此我们便知道了Dan的性别为男（M）。<br><img src="/medias/article/images/2019/7/26/21.png" alt><br>那么，想要查询Ally的性别时该怎么做呢？为了找到它的存储位置，先要算出Ally键的哈希值，再对其进行mod运算。最终得到的结果为3。<br><img src="/medias/article/images/2019/7/26/22.png" alt><br>然而3号箱中数据的键是Joe而不是Ally。此时便需要对Joe所在的链表进行线性查找。<br><img src="/medias/article/images/2019/7/26/23.png" alt><br>于是我们找到了键为Ally的数据。取出其对应的值，便知道了Ally的性别为女（F）。<br><img src="/medias/article/images/2019/7/26/24.png" alt></p><a id="more"></a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。<br>如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。</p><h3 id="1-补充说明"><a href="#1-补充说明" class="headerlink" title="1. 补充说明"></a>1. 补充说明</h3><h4 id="1-1-链地址法"><a href="#1-1-链地址法" class="headerlink" title="1.1 链地址法"></a>1.1 链地址法</h4><p>在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据来解决冲突。这种方法被称为“链地址法”。</p><h4 id="1-2-开放地址法"><a href="#1-2-开放地址法" class="headerlink" title="1.2 开放地址法"></a>1.2 开放地址法</h4><p>除了链地址法以外，还有几种解决冲突的方法。其中，应用较为广泛的是“开放地址法”。这种方法是指当冲突发生时，立刻计算出一个候补地址（数组上的位置）并将数据存进去。<br>如果仍然有冲突，便继续计算下一个候补地址，直到有空地址为止。可以通过多次使用哈希函数或“线性探测法”等方法计算候补地址。</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：队列</title>
      <link href="/2019/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%98%9F%E5%88%97/"/>
      <url>/2019/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构-队列"><a href="#数据结构-队列" class="headerlink" title="数据结构:队列"></a>数据结构:队列</h2><p>队列中的数据也呈线性排列。虽然与栈有些相似，但队列中添加和删除数据的操作分别是在两端进行的。就和“队列”这个名字一样，把它想象成排成一队的人更容易理解。在队列中，处理总是从第一名开始往后进行，而新来的人只能排在队尾</p><p>这就是队列的概念图。现在队列中只有数据Blue<br><img src="/medias/article/images/2019/7/25/1.jpg" alt><br>然后，队列中添加了数据Green<br><img src="/medias/article/images/2019/7/25/2.jpg" alt><br>紧接着，数据Red也入队了<br><img src="/medias/article/images/2019/7/25/3.jpg" alt><br>从队列中取出（删除）数据时，是从最下面，也就是最早入队的数据开始的。这里取出的是Blue<br><img src="/medias/article/images/2019/7/25/4.png" alt><br>如果再进行一次出队操作，取出的就是Green了<br><img src="/medias/article/images/2019/7/25/5.jpg" alt><br>像队列这种最先进去的数据最先被取来，即“先进先出”的结构，我们称为First In First Out，简称FIFO</p><a id="more"></a><p>与栈类似，队列中可以操作数据的位置也有一定的限制。在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问</p><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>“先来的数据先处理”是一种很常见的思路，所以队列的应用范围非常广泛。广度优先搜索算法，通常就会从搜索候补中选择最早的数据作为下一个顶点。此时，在候补顶点的管理上就可以使用队列。</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：栈</title>
      <link href="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88/"/>
      <url>/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构：栈"><a href="#数据结构：栈" class="headerlink" title="数据结构：栈"></a>数据结构：栈</h2><p>栈也是一种数据呈现线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。栈就像是一摞书，拿到的新书时我们会把它放在书堆的最上面，取书的时候也只能从最上面的新书开始取<br><img src="/medias/article/images/2019/7/24/1.jpg" alt></p><p>如:现在存储在栈中的只有数据Blue<br><img src="/medias/article/images/2019/7/24/2.jpg" alt><br>然后，栈中增加数据Green<br><img src="/medias/article/images/2019/7/24/3.jpg" alt><br>数据Red入栈<br><img src="/medias/article/images/2019/7/24/3.jpg" alt><br>从栈中取出数据时，是从最上面，也就是从最新的数据取出的，这里取出的是Red<br><img src="/medias/article/images/2019/7/24/4.png" alt></p><a id="more"></a><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><p>像栈这种最后添加的数据最先被取出，即“后进先出”的结构，我们称为Last In First Out，简称LIFO。<br>与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行</p><h4 id="1-1-应用示例"><a href="#1-1-应用示例" class="headerlink" title="1.1 应用示例"></a>1.1 应用示例</h4><p>栈只能在一端操作这一点看起来似乎十分不便，但在只需要访问最新数据时，使用它就比较方便了。<br>比如，规定（AB（C（DE）F）（G（（H）I J）K））这一串字符中括号的处理方式如下：首先从左边开始读取字符，读到左括号就将其入栈，读到右括号就将栈顶的左括号出栈。此时，出栈的左括号便与当前读取的右括号相匹配。通过这种处理方式，我们就能得知配对括号的具体位置</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：数组</title>
      <link href="/2019/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%B0%E7%BB%84/"/>
      <url>/2019/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构：数组"><a href="#数据结构：数组" class="headerlink" title="数据结构：数组"></a>数据结构：数组</h2><p>数组也是数据呈现线性排列的一种数据结。与前面一篇文章 <a href="https://lishangzhi.github.io/2019/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%93%BE%E8%A1%A8/">数据结构：链表</a><br>在数组中，访问数据十分简单，而添加数据和删除数据比较耗工夫<br><img src="/medias/article/images/2019/7/23/1.png" alt><br>数据按顺序存储在内存的连续空间内<br><img src="/medias/article/images/2019/7/23/2.jpg" alt><br>由于数据是存储在连续空间内的，所以每个数据的内存地址（在内存上的位置）都可以通过数组下标算出，我们也就可以借此直接访问目标数据（这叫作“随机访问”）<br><img src="/medias/article/images/2019/7/23/3.jpg" alt><br>比如现在我们想要访问Red。如果使用指针就只能从头开始查找，但在数组中，只需要指定a[2]，便能直接访问Red;但是，如果想在任意位置上添加或者删除数据，数组的操作就要比链表复杂多了。这里我们尝试将Green添加到第2个位置;首先，在数组的末尾确保需要增加的存储空间<br><br><img src="/medias/article/images/2019/7/23/4.jpg" alt><br>为了给新数据腾出位置，要把已有数据一个个移开。首先把Red往后移,然后把Yellow往后移,<br><img src="/medias/article/images/2019/7/23/5.jpg" alt><br>最后在空出来的位置上写入Green,添加数据的操作就完成了<br><img src="/medias/article/images/2019/7/23/6.jpg" alt><br>反过来，如果想要删除Green……首先，删掉目标数据（在这里指Green）,然后把后面的数据一个个往空位移。先把Yellow往前移,接下来移动Red,最后再删掉多余的空间。这样一来Green便被删掉了<br><img src="/medias/article/images/2019/7/23/7.jpg" alt></p><a id="more"></a><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><p>假设数组中有n个数据，由于访问数据时使用的是随机访问（通过下标可计算出内存地址），所以需要的运行时间仅为恒定的O（1）。<br>但另一方面，想要向数组中添加新数据时，必须把目标位置后面的数据一个个移开。所以，如果在数组头部添加数据，就需要O（n）的时间。删除操作同理</p><h3 id="2-补充说明"><a href="#2-补充说明" class="headerlink" title="2. 补充说明"></a>2. 补充说明</h3><p>在链表和数组中，数据都是线性地排成一列。在链表中访问数据较为复杂，添加和删除数据较为简单；而在数组中访问数据比较简单，添加和删除数据却比较复杂。<br>我们可以根据哪种操作较为频繁来决定使用哪种数据结构<br><img src="/medias/article/images/2019/7/23/8.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构:链表</title>
      <link href="/2019/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构:链表"></a>数据结构:链表</h2><p>链表是数据结构之一，其中的数据呈现线性排列。在链表中，数据的添加和删除较为方便，就是访问比较耗时</p><p><img src="/medias/article/images/2019/7/22/2.png" alt><br>这是链表的概念图。Bule、Yellow、Red这3个字符串作为数据被存储在链表中。每个数据都有1个“指针”，它指向下一个数据的内存地址<br><img src="/medias/article/images/2019/7/22/3.png" alt><br>在链表中，数据一般都是分散存储内存中的，无需存储在连续空间内<br><img src="/medias/article/images/2019/7/22/4.jpg" alt><br>因为数据都是分散存储的，所以想要访问数据，只能从第一个数据开始，顺着指针的指向一一往下访问(这边是顺序访问)。比如想要找到Red着一数据，就得从Blue开始访问<br><br>这之后，要经过Yellow,我们才能找到Red<br><br>如果想要添加数据，只需要改变添加位置前后的指针指向就可以了，比如，在Blue和Yellow之间添加Green<br><br><img src="/medias/article/images/2019/7/22/5.jpg" alt><br>将Blue的指针指向位置变成Green,然后把Green的指针指向Yellow<br><img src="/medias/article/images/2019/7/22/6.jpg" alt><br>数据的删除也一样，只要改变指针的指向就可以，比如删除Yello<br><img src="/medias/article/images/2019/7/22/6.jpg" alt><br>这时候，只需要把Green指针指向的位置从Yellow变成Red,删除就完成了，虽然Yellow本身还存在内存中，但是不管从哪里都无法访问这个数据，所以也就没特意去删除的必要<br><img src="/medias/article/images/2019/7/22/7.jpg" alt></p><a id="more"></a><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><ul><li>对链表的操作所需的运行时间到底是对少呢？我们把链表中的数据量记为n,访问数据时，访问数据时，需要从链表头部开始(线性查找)，如果目标数据在链表最后的话，需要的时间就是O(n).</li><li>另外，添加数据只需要更改两个指针的指向，所以耗时的时间与n无关。如果已经达到添加数据的位置，那么添加操作只需要花费0(1)的时间。删除数据同样也只需O(1)的时间</li></ul><h3 id="2-补充说明"><a href="#2-补充说明" class="headerlink" title="2. 补充说明"></a>2. 补充说明</h3><p>  上述模型链表是最基本的一中链表。除此之外还有还存在几种拓展方便的链表。</p><ul><li>案例中，如果我们在链表尾部使用指针，并且让它指向链表头部的数据，将链表变成环形。这便是”循环链表”,也叫”环形链表”.“循环链表”没有头部和尾部的概念，<code>要想保存数据固定和最新数据时候通常会使用这种链表</code><br><img src="/medias/article/images/2019/7/22/8.jpg" alt></li><li>另外上面提到的链表都只有一个指针，我们可以把指针设定为两个，并让他们分别指向前后数据，这就是“双向链表”，使用这种链表不仅仅可以从前往后，还可以从后往前遍历数据，十分方便<br><img src="/medias/article/images/2019/7/22/9.jpg" alt></li></ul><p>但是双向链表存在两个缺点：</p><ol><li>指针数会导致存储空间的需求增加</li><li>添加或删除时需要改变更多的指针的指向</li></ol>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中SPI机制</title>
      <link href="/2019/07/20/SpringBoot%E4%B8%ADSPI%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/20/SpringBoot%E4%B8%ADSPI%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot中SPI机制"><a href="#SpringBoot中SPI机制" class="headerlink" title="SpringBoot中SPI机制"></a>SpringBoot中SPI机制</h2><h3 id="一、从java类加载机制说起"><a href="#一、从java类加载机制说起" class="headerlink" title="一、从java类加载机制说起"></a>一、从java类加载机制说起</h3><p>java中的类加载器负载加载来自文件系统、网络或者其他来源的类文件。<code>jvm</code>的类加载器默认使用的是双亲委派模式。三种默认的类加载器<code>Bootstrap ClassLoader</code>、<code>Extension ClassLoader</code>和<code>System ClassLoader（Application ClassLoader）</code>每一个中类加载器都确定了从哪一些位置加载文件。于此同时我们也可以通过继承<code>java.lang.classloader</code>实现自己的类加载器</p><a id="more"></a><ol><li><code>Bootstrap ClassLoader</code>：负责加载JDK自带的<code>rt.jar</code>包中的类文件，是所有类加载的父类 </li><li><code>Extension ClassLoader</code>：负责加载java的扩展类库从<code>jre/lib/ect</code>目录或者<code>java.ext.dirs</code>系统属性指定的目录下加载类，是<code>System ClassLoader</code>的父类加载器 </li><li><code>System ClassLoader</code>：负责从<code>classpath</code>环境变量中加载类文件</li></ol><p><img src="/medias/article/images/2019/7/20/1.png" alt="java类加载结构"></p><h4 id="1-双亲委派模型"><a href="#1-双亲委派模型" class="headerlink" title="1.双亲委派模型"></a>1.双亲委派模型</h4><p>原理：当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的<code>BootstrapClassLoader</code>，只有当父加载器无法完成加载任务时，才会尝试自己来加载</p><p>具体：根据双亲委派模式，在加载类文件的时候，子类加载器首先将加载请求委托给它的父加载器，父加载器会检测自己是否已经加载过类，如果已经加载则加载过程结束，如果没有加载的话则请求继续向上传递直<code>Bootstrap ClassLoader</code>。如果请求向上委托过程中，如果始终没有检测到该类已经加载，则Bootstrap ClassLoader开始尝试从其对应路劲中加载该类文件，如果失败则由子类加载器继续尝试加载，直至发起加载请求的子加载器为止</p><p>采用双亲委派模式可以保证类型加载的安全性，不管是哪个加载器加载这个类，最终都是委托给顶层的<code>BootstrapClassLoader</code>来加载的，只有父类无法加载自己猜尝试加载，这样就可以保证任何的类加载器最终得到的都是同样一个Object对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，检查该类是否已经被加载，如果从JVM缓存中找到该类，则直接返回</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 遵循双亲委派的模型，首先会通过递归从父加载器开始找，</span>            <span class="token comment" spellcheck="true">// 直到父类加载器是BootstrapClassLoader为止</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果还找不到，尝试通过findClass方法去寻找</span>            <span class="token comment" spellcheck="true">// findClass是留给开发者自己实现的，也就是说</span>            <span class="token comment" spellcheck="true">// 自定义类加载器时，重写此方法即可</span>           c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-双亲委派模型缺陷"><a href="#2-双亲委派模型缺陷" class="headerlink" title="2.双亲委派模型缺陷"></a>2.双亲委派模型缺陷</h4><ul><li>在双亲委派模型中，子类加载器可以使用父类加载器已经加载的类，而父类加载器无法使用子类加载器已经加载的。这就导致了双亲委派模型并不能解决所有的类加载器问题。</li></ul><p>案例：<br><code>Java 提供了很多服务提供者接口(Service Provider Interface，SPI)，允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JNDI、JAXP 等，这些SPI的接口由核心类库提供，却由第三方实现，这样就存在一个问题：SPI 的接口是 Java 核心库的一部分，是由BootstrapClassLoader加载的；SPI实现的Java类一般是由AppClassLoader来加载的。BootstrapClassLoader是无法找到 SPI 的实现类的，因为它只加载Java的核心库。它也不能代理给AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题</code></p><h4 id="3-使用线程上下文类加载器加载"><a href="#3-使用线程上下文类加载器加载" class="headerlink" title="3.使用线程上下文类加载器加载"></a>3.使用线程上下文类加载器加载</h4><ul><li>如果不做任何的设置，Java应用的线程的上下文类加载器默认就是<code>AppClassLoader</code>。在核心类库使用SPI接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到SPI实现的类。线程上下文类加载器在很多SPI的实现中都会用到</li><li>通常我们可以通过<code>Thread.currentThread().getClassLoader()</code>和<code>Thread.currentThread().getContextClassLoader()</code>获取线程上下文类加载器</li></ul><h4 id="4-使用类加载器加载资源文件，比如jar包"><a href="#4-使用类加载器加载资源文件，比如jar包" class="headerlink" title="4.使用类加载器加载资源文件，比如jar包"></a>4.使用类加载器加载资源文件，比如jar包</h4><p>类加载器除了加载<code>class</code>外，还有一个非常重要功能，就是加载资源，它可以从jar包中读取任何资源文件，比如，<code>ClassLoader.getResources(String name)</code>方法就是用于读取jar包中的资源文件</p><h3 id="二、spring中SPI机制实现"><a href="#二、spring中SPI机制实现" class="headerlink" title="二、spring中SPI机制实现"></a>二、spring中SPI机制实现</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取资源的方法</span><span class="token keyword">public</span> Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> <span class="token function">getResources</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span>Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Enumeration</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getBootstrapResources</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">findResources</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CompoundEnumeration</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到<code>BootstrapClassLoader</code>，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的jar包，就如同加载class一样，最后会扫描所有的jar包，找到符合条件的资源文件。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用线程上下文类加载器加载资源</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Array.class的完整路径</span>    String name <span class="token operator">=</span> <span class="token string">"java/sql/Array.class"</span><span class="token punctuation">;</span>    Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> urls <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        URL url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1-SPI机制"><a href="#1-SPI机制" class="headerlink" title="1.SPI机制"></a>1.SPI机制</h4><p><strong>(SPI思想)</strong></p><ul><li>SPI的全名为<code>Service Provider Interface</code>.这个是针对厂商或者插件的</li><li>SPI的思想：系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<strong>java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制</strong></li></ul><p><strong>(2)SPI约定</strong></p><ul><li>当服务的提供者，提供了服务接口的一种实现之后，在jar包的<code>META-INF/services/</code>目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。通过这个约定，就不需要把服务放在代码中了，通过模块被装配的时候就可以发现服务类了</li></ul><h4 id="2-SPI使用案例"><a href="#2-SPI使用案例" class="headerlink" title="2.SPI使用案例"></a>2.SPI使用案例</h4><p><code>common-logging</code> apache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现， 发现日志提供商是通过扫描 META-INF/services/org.apache.commons.logging.LogFactory配置文件，通过读取该文件的内容找到日志提工商实现类。只要我们的日志实现里包含了这个文件，并在文件里制定 LogFactory工厂接口的实现类即可</p><h4 id="3-Springboot中的类SPI扩展机制"><a href="#3-Springboot中的类SPI扩展机制" class="headerlink" title="3.Springboot中的类SPI扩展机制"></a>3.Springboot中的类SPI扩展机制</h4><ul><li>在<code>springboot</code>的自动装配过程中，最终会加载<code>META-INF/spring.factories</code>文件，而加载的过程是由<code>SpringFactoriesLoader</code>加载的。从CLASSPATH下的每个Jar包中搜寻所有META-INF/spring.factories配置文件，然后将解析<code>properties</code>文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在<code>Classpath</code>下的jar包中<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String FACTORIES_RESOURCE_LOCATION <span class="token operator">=</span> <span class="token string">"META-INF/spring.factories"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// spring.factories文件的格式为：key=value1,value2,value3</span><span class="token comment" spellcheck="true">// 从所有的jar包中找到META-INF/spring.factories文件</span><span class="token comment" spellcheck="true">// 然后从文件中解析出key=factoryClass类名称的所有value值</span><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factoryClass<span class="token punctuation">,</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>  String factoryClassName <span class="token operator">=</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 取得资源文件的URL</span>  Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> urls <span class="token operator">=</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> null <span class="token operator">?</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span> <span class="token operator">:</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 遍历所有的URL</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      URL url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span>      Properties properties <span class="token operator">=</span> PropertiesLoaderUtils<span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String factoryClassNames <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>factoryClassName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 组装数据，并返回</span>      result<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span>factoryClassNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性及使用(二)</title>
      <link href="/2019/07/17/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8-%E4%BA%8C/"/>
      <url>/2019/07/17/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>扩展注解的支持</li><li>Base64</li><li>JavaFX</li><li>其它<ul><li>JDBC4.2规范</li><li>更好的类型推测机制</li><li>HashMap性能提升</li><li>IO/NIO 的改进</li><li>JavaScript引擎Nashorn</li><li>并发（Concurrency）</li><li>类依赖分析器jdeps</li><li>JVM的PermGen空间被移除</li></ul></li></ul><a id="more"></a><h3 id="扩展注解的支持"><a href="#扩展注解的支持" class="headerlink" title="扩展注解的支持"></a>扩展注解的支持</h3><p> Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Annotations</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>      <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_PARAMETER <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">NonEmpty</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token annotation punctuation">@NonEmpty</span> Object <span class="token punctuation">{</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@NonEmpty</span> Exception <span class="token punctuation">{</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">final</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NonEmpty</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token annotation punctuation">@NonEmpty</span> Collection<span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p> 在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>StandardCharsets<span class="token punctuation">;</span> <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Base64<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base64s</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">final</span> String text <span class="token operator">=</span> <span class="token string">"Base64 finally in Java 8!"</span><span class="token punctuation">;</span>         <span class="token keyword">final</span> String encoded <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">final</span> String decoded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p> 程序在控制台上输出了编码后的字符与解码后的字符：</p><pre><code>  QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==  Base64 finally in Java 8!</code></pre><p> <code>Base64</code>类同时还提供了对<code>URL</code>、<code>MIME</code>友好的编码器与解码器（<code>Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder()</code>）。</p><h3 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h3><p> JavaFX是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考JavaFX中文文档。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="1-JDBC4-2规范"><a href="#1-JDBC4-2规范" class="headerlink" title="1. JDBC4.2规范"></a>1. JDBC4.2规范</h4><p> JDBC4.2主要有以下几点改动：</p><ul><li><p>增加了对<code>REF Cursor</code>的支持</p></li><li><p>修改返回值大小范围（<code>update count</code>）</p></li><li><p>增加了<code>java.sql.DriverAction</code>接口</p></li><li><p>增加了<code>java.sql.SQLType</code>接口</p></li><li><p>增加了<code>java.sql.JDBCtype</code>枚举</p></li><li><p>对<code>java.time</code>包时间类型的支持</p><h4 id="2-更好的类型推测机制"><a href="#2-更好的类型推测机制" class="headerlink" title="2. 更好的类型推测机制"></a>2. 更好的类型推测机制</h4><p>Java 8在类型推测方面有了很大的提高。在很多情况下，编译器可以推测出确定的参数类型，这样就能使代码更整洁。让我们看一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> null<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> T <span class="token function">getOrDefault</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> T defaultValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> value <span class="token operator">:</span> defaultValue<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里是Value<string>类型的用法。</string></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TypeInference</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> Value<span class="token operator">&lt;</span>String<span class="token operator">></span> value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       value<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token string">"22"</span><span class="token punctuation">,</span> Value<span class="token punctuation">.</span><span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Value.defaultValue()</code>的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是<code>Value.&lt;String&gt;defaultValue()</code>。</p></li></ul><h4 id="3-HashMap性能提升"><a href="#3-HashMap性能提升" class="headerlink" title="3. HashMap性能提升"></a>3. HashMap性能提升</h4><p> Java8中，HashMap内部实现又引入了红黑树，使得HashMap的总体性能相较于Java7有比较明显的提升。以下是对Hash均匀和不均匀的情况下的性能对比</p><h5 id="1-Hash较均匀的情况"><a href="#1-Hash较均匀的情况" class="headerlink" title="(1). Hash较均匀的情况"></a>(1). Hash较均匀的情况</h5><p> Hash较均匀时的性能对比<br> Hash较均匀时的性能对比</p><h5 id="2-Hash极不均匀的情况"><a href="#2-Hash极不均匀的情况" class="headerlink" title="(2). Hash极不均匀的情况"></a>(2). Hash极不均匀的情况</h5><p> Hash极不均匀时的性能对比<br> Hash极不均匀时的性能对比</p><h4 id="4-IO-NIO-的改进"><a href="#4-IO-NIO-的改进" class="headerlink" title="4. IO/NIO 的改进"></a>4. IO/NIO 的改进</h4><p> Java8 对IO/NIO也做了一些改进。主要包括：改进了<code>java.nio.charset.Charset</code>的实现，使编码和解码的效率得以提升，也精简了<code>jre/lib/charsets.jar</code>包；优化了<code>String(byte[], *)</code>构造方法和<code>String.getBytes()</code>方法的性能；还增加了一些新的<code>IO/NIO</code>方法，使用这些方法可以从文件或者输入流中获取流（<code>java.util.stream.Stream</code>），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。</p><p> 新增的 API 如下：</p><ul><li><p><code>BufferedReader.line()</code>: 返回文本行的流Stream<string></string></p></li><li><p><code>File.lines(Path, Charset)</code>: 返回文本行的流Stream<string></string></p></li><li><p><code>File.list(Path)</code>: 遍历当前目录下的文件和目录</p></li><li><p><code>File.walk(Path, int, FileVisitOption)</code>: 遍历某一个目录下的所有文件和指定深度的子目录</p></li><li><p><code>File.find(Path, int, BiPredicate, FileVisitOption...)</code>: 查找相应的文件</p><p>下面就是用流式操作列出当前目录下的所有文件和目录：</p><pre class=" language-java"><code class="language-java">Files<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="5-JavaScript引擎Nashorn"><a href="#5-JavaScript引擎Nashorn" class="headerlink" title="5. JavaScript引擎Nashorn"></a>5. JavaScript引擎Nashorn</h4><p>Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。<code>Nashorn javascript</code>引擎只是<code>javax.script.ScriptEngine</code>另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子：</p><pre class=" language-java"><code class="language-java">ScriptEngineManager manager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ScriptEngine engine <span class="token operator">=</span> manager<span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>engine<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result:"</span> <span class="token operator">+</span> engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"function f(){return 1;}; f() + 1;"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出如下：</p><pre class=" language-java"><code class="language-java">jdk<span class="token punctuation">.</span>nashorn<span class="token punctuation">.</span>api<span class="token punctuation">.</span>scripting<span class="token punctuation">.</span>NashornScriptEngineResult<span class="token operator">:</span> <span class="token number">2</span></code></pre></li></ul><h4 id="6-并发（Concurrency）"><a href="#6-并发（Concurrency）" class="headerlink" title="6. 并发（Concurrency）"></a>6. 并发（Concurrency）</h4><p> 在新增Stream机制与Lambda的基础之上，在<code>java.util.concurrent.ConcurrentHashMap</code>中加入了一些新方法来支持聚集操作。同时也在<code>java.util.concurrent.ForkJoinPool</code>类中加入了一些新方法来支持共有资源池（<code>common pool</code>）（请查看我们关于Java 并发的免费课程）。</p><p> 新增的<code>java.util.concurrent.locks.StampedLock</code>类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的<code>java.util.concurrent.locks.ReadWriteLock</code>类的替代者）。</p><p> 在<code>java.util.concurrent.atomic</code>包中还增加了下面这些类：</p><ul><li><p>DoubleAccumulator</p></li><li><p>DoubleAdder</p></li><li><p>LongAccumulator</p></li><li><p>LongAdder</p><h4 id="7-类依赖分析器jdeps"><a href="#7-类依赖分析器jdeps" class="headerlink" title="7. 类依赖分析器jdeps"></a>7. 类依赖分析器jdeps</h4><p>Jdeps是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，jdeps会输出到控制台。</p><p>作为例子，让我们看看现在很流行的Spring框架的库的依赖关系报告。为了让报告短一些，我们只分析一个<code>jar: org.springframework.core-3.0.5.RELEASE.jar</code>.</p><p><code>jdeps org.springframework.core-3.0.5.RELEASE.jar</code>这个命令输出内容很多，我们只看其中的一部分，这些依赖关系根绝包来分组，如果依赖关系在classpath里找不到，就会显示not found.</p><pre class=" language-java"><code class="language-java">C<span class="token operator">:</span>\Program Files\Java\jdk1<span class="token number">.8</span><span class="token punctuation">.</span><span class="token number">0</span>\jre\lib\rt<span class="token punctuation">.</span>jar org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span><span class="token function">core</span> <span class="token punctuation">(</span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">)</span>    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>io    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>util    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent    <span class="token operator">-</span><span class="token operator">></span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>logging                         not found    <span class="token operator">-</span><span class="token operator">></span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>asm                            not found    <span class="token operator">-</span><span class="token operator">></span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>asm<span class="token punctuation">.</span>commons                    not found org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span><span class="token function">annotation</span> <span class="token punctuation">(</span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">)</span>    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>util</code></pre><h5 id="8-JVM的PermGen空间被移除"><a href="#8-JVM的PermGen空间被移除" class="headerlink" title="8. JVM的PermGen空间被移除"></a>8. JVM的PermGen空间被移除</h5><p><code>PermGen</code>空间被移除了，取而代之的是<code>Metaspace（JEP 122）</code>。JVM选项<code>-XX:PermSize</code>与<code>-XX:MaxPermSize</code>分别被<code>-XX:MetaSpaceSize</code>与<code>-XX:MaxMetaspaceSize</code>所代替。</p><p>参考文档：<br><a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">What’s New in JDK 8</a><br><a href="http://www.importnew.com/11908.html" target="_blank" rel="noopener">Java 8新特性终极指南</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性及使用(一)</title>
      <link href="/2019/07/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8-%E4%B8%80/"/>
      <url>/2019/07/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>接口默认方法和静态方法</li><li>Lambda 表达式</li><li>函数式接口</li><li>方法引用</li><li>Stream</li><li>Optional</li><li>Date/Time API</li><li>重复注解</li></ul><h2 id="一、接口默认方法和静态方法"><a href="#一、接口默认方法和静态方法" class="headerlink" title="一、接口默认方法和静态方法"></a>一、接口默认方法和静态方法</h2><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p><a id="more"></a><h3 id="1-接口默认方法"><a href="#1-接口默认方法" class="headerlink" title="1. 接口默认方法"></a>1. 接口默认方法</h3><p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or</span>    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Defaulable</code>接口用关键字<code>default</code>声明了一个默认方法<code>notRequired()</code>，<code>Defaulable</code>接口的实现者之一<code>DefaultableImpl</code>实现了这个接口，并且让默认方法保持原样。<code>Defaulable</code>接口的另一个实现者<code>OverridableImpl</code>用自己的方法覆盖了默认方法。</p><h4 id="1-多重继承的冲突说明"><a href="#1-多重继承的冲突说明" class="headerlink" title="(1). 多重继承的冲突说明"></a>(1). 多重继承的冲突说明</h4><p>由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下：</p><p>一个声明在类里面的方法优先于任何默认方法<br>优先选取最具体的实现<br>public interface A {</p><pre><code>default void hello() {    System.out.println(&quot;Hello A&quot;);}</code></pre><p>}public interface B extends A {</p><pre><code>default void hello() {    System.out.println(&quot;Hello B&quot;);}</code></pre><p>}public class C implements A, B {</p><pre><code>public static void main(String[] args) {    new C().hello(); // 输出 Hello B}</code></pre><p>}</p><h4 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="(2). 优缺点"></a>(2). 优缺点</h4><ul><li>优点: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</li><li>缺点: 使得接口作为协议，类作为具体实现的界限开始变得有点模糊。<h4 id="3-接口默认方法不能重载Object类的任何方法"><a href="#3-接口默认方法不能重载Object类的任何方法" class="headerlink" title="(3). 接口默认方法不能重载Object类的任何方法"></a>(3). 接口默认方法不能重载Object类的任何方法</h4>接口不能提供对<code>Object</code>类的任何方法的默认实现。简单地讲，每一个<code>java</code>类都是<code>Object</code>的子类，也都继承了它类中的<code>equals()/hashCode()/toString()</code>方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。</li></ul><p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到<code>java.util.Collection</code>接口中去：<code>stream()，parallelStream()</code>，<code>forEach()</code>，<code>removeIf()</code>等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。</p><h3 id="2-接口静态方法"><a href="#2-接口静态方法" class="headerlink" title="2. 接口静态方法"></a>2. 接口静态方法</h3><p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用<code>static</code>关键字，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StaticInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是Java8接口中的静态方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面的一小段代码是上面静态方法的使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StaticInterface<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 这是Java8接口中的静态方法!</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Java</code>支持一个实现类可以实现多个接口，如果多个接口中存在同样的<code>static</code>方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。</p><h2 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h2><p><code>Lambda</code>表达式（也称为闭包）是整个<code>Java 8</code>发行版中最受期待的在<code>Java</code>语言层面上的改变，<code>Lambda</code>允许把函数作为一个方法的参数（即：行为参数化，函数作为参数传递进方法中）。</p><p>一个<code>Lambda</code>可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。</p><p>首先看看在老版本的Java中是如何排列字符串的：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">,</span> <span class="token string">"anna"</span><span class="token punctuation">,</span> <span class="token string">"mike"</span><span class="token punctuation">,</span> <span class="token string">"xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>只需要给静态方法<code>Collections.sort</code>传入一个<code>List</code>对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给<code>sort</code>方法。<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于函数体只有一行代码的，你可以去掉大括号{}以及<code>return</code>关键字，但是你还可以写得更短点：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p><code>Lambda</code>表达式是如何在Java的类型系统中表示的呢？每一个<code>Lambda</code>表达式都对应一个类型，通常是接口类型。而函数式接口是指仅仅只包含一个抽象方法的接口，每一个该类型的<code>Lambda</code>表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将<code>Lambda</code>表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加<code>@FunctionalInterface</code>注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><p>示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>F<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    T <span class="token function">convert</span><span class="token punctuation">(</span>F from<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> converter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>Integer converted <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><p>注：如果<code>@FunctionalInterface</code>如果没有指定，上面的代码也是对的。</p><p><code>Java8 API</code>包含了很多内建的函数式接口，在老<code>Java</code>中常用到的比如<code>Comparator</code>或者<code>Runnable</code>接口，这些接口都增加了<code>@FunctionalInterface</code>注解以便能用在<code>Lambda</code>上。</p><p><code>Java8 API</code>同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自<code>Google Guava</code>库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到<code>lambda</code>上使用的。</p><h3 id="1-Comparator-比较器接口"><a href="#1-Comparator-比较器接口" class="headerlink" title="1. Comparator (比较器接口)"></a>1. Comparator (比较器接口)</h3><p><code>Comparator</code>是老<code>Java</code>中的经典接口， <code>Java 8</code>在此之上添加了多种默认方法。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>T o1<span class="token punctuation">,</span> T o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Comparator<span class="token operator">&lt;</span>Person<span class="token operator">></span> comparator <span class="token operator">=</span> <span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> p1<span class="token punctuation">.</span>firstName<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>Person p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Doe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Person p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token string">"Wonderland"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// > 0</span>comparator<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// &lt; 0</span></code></pre><h3 id="2-Consumer-消费型接口"><a href="#2-Consumer-消费型接口" class="headerlink" title="2. Consumer (消费型接口)"></a>2. Consumer (消费型接口)</h3><p><code>Consumer</code>接口表示执行在单个参数上的操作。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Consumer<span class="token operator">&lt;</span>Person<span class="token operator">></span> greeter <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>greeter<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Luke"</span><span class="token punctuation">,</span> <span class="token string">"Skywalker"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>更多的Consumer接口<br><code>BiConsumer：void accept(T t, U u);</code>: 接受两个参数的二元函数<br><code>DoubleConsumer：void accept(double value);</code>: 接受一个double参数的一元函数<br><code>IntConsumer：void accept(int value);</code>: 接受一个int参数的一元函数<br><code>LongConsumer：void accept(long value);</code>: 接受一个long参数的一元函数<br><code>ObjDoubleConsumer：void accept(T t, double value);</code>: 接受一个泛型参数一个double参数的二元函数<br><code>ObjIntConsumer：void accept(T t, int value);</code>: 接受一个泛型参数一个int参数的二元函数<br><code>ObjLongConsumer：void accept(T t, long value);</code>: 接受一个泛型参数一个long参数的二元函数</p><h3 id="3-Supplier-供应型接口"><a href="#3-Supplier-供应型接口" class="headerlink" title="3. Supplier (供应型接口)"></a>3. Supplier (供应型接口)</h3><p><code>Supplier</code>接口是不需要参数并返回一个任意范型的值。其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同<code>Consumer</code>相反，是一个只声明了返回值，不需要参数的函数。也就是说<code>Supplier</code>其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力，因为我们常见的场景中不止是要<code>consume（Consumer）</code>或者是简单的<code>map（Function）</code>，还包括了new这个动作。而<code>Supplier</code>就表达了这种能力。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Supplier<span class="token operator">&lt;</span>Person<span class="token operator">></span> personSupplier <span class="token operator">=</span> Person<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">;</span>personSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// new Person</span></code></pre><p>更多Supplier接口<br><code>BooleanSupplier：boolean getAsBoolean();</code>: 返回boolean的无参函数<br><code>DoubleSupplier：double getAsDouble();</code>: 返回double的无参函数<br><code>IntSupplier：int getAsInt();</code>: 返回int的无参函数<br><code>LongSupplier：long getAsLong();</code>: 返回long的无参函数</p><h3 id="4-Predicate-断言型接口"><a href="#4-Predicate-断言型接口" class="headerlink" title="4. Predicate (断言型接口)"></a>4. Predicate (断言型接口)</h3><p><code>Predicate</code>接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将<code>Predicate</code>组合成其他复杂的逻辑（比如：与，或，非）。<code>Stream</code>的<code>filter</code>方法就是接受Predicate作为入参的。这个具体在后面使用Stream的时候再分析深入。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>predicate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// true</span>predicate<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// false</span>Predicate<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> nonNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>nonNull<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> isNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>isNull<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isEmpty <span class="token operator">=</span> String<span class="token operator">:</span><span class="token operator">:</span>isEmpty<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isNotEmpty <span class="token operator">=</span> isEmpty<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>更多的Predicate接口<br><code>BiPredicate：boolean test(T t, U u);</code>: 接受两个参数的二元断言函数<br><code>DoublePredicate：boolean test(double value);</code>: 入参为double的断言函数<br><code>IntPredicate：boolean test(int value);</code>: 入参为int的断言函数<br><code>LongPredicate：boolean test(long value);</code>: 入参为long的断言函数</p><h4 id="5-Function-功能型接口"><a href="#5-Function-功能型接口" class="headerlink" title="5. Function (功能型接口)"></a>5. Function (功能型接口)</h4><p><code>Function</code>接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法<code>（compose, andThen）</code>。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> <span class="token punctuation">{</span>    R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> toInteger <span class="token operator">=</span> Integer<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">;</span>Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> backToString <span class="token operator">=</span> toInteger<span class="token punctuation">.</span><span class="token function">andThen</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">)</span><span class="token punctuation">;</span>backToString<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "123"</span></code></pre><p>更多的Function接口<br><code>BiFunction ：R apply(T t, U u);</code>: 接受两个参数，返回一个值，代表一个二元函数；<br><code>DoubleFunction ：R apply(double value);</code>: 只处理double类型的一元函数；<br><code>IntFunction ：R apply(int value);</code>: 只处理int参数的一元函数；<br><code>LongFunction ：R apply(long value);</code>: 只处理long参数的一元函数；<br><code>ToDoubleFunction：double applyAsDouble(T value);</code>: 返回double的一元函数；<br><code>ToDoubleBiFunction：double applyAsDouble(T t, U u);</code>: 返回double的二元函数；<br><code>ToIntFunction：int applyAsInt(T value);</code>: 返回int的一元函数；<br><code>ToIntBiFunction：int applyAsInt(T t, U u);</code>: 返回int的二元函数；<br><code>ToLongFunction：long applyAsLong(T value);</code>: 返回long的一元函数；<br><code>ToLongBiFunction：long applyAsLong(T t, U u);</code>: 返回long的二元函数；<br><code>DoubleToIntFunction：int applyAsInt(double value);</code>: 接受double返回int的一元函数；<br><code>DoubleToLongFunction：long applyAsLong(double value);</code>: 接受double返回long的一元函数；<br><code>IntToDoubleFunction：double applyAsDouble(int value);</code>: 接受int返回double的一元函数；<br><code>IntToLongFunction：long applyAsLong(int value);</code>: 接受int返回long的一元函数；<br><code>LongToDoubleFunction：double applyAsDouble(long value);</code>: 接受long返回double的一元函数；<br><code>LongToIntFunction：int applyAsInt(long value);</code>: 接受long返回int的一元函数；</p><h3 id="6-Operator"><a href="#6-Operator" class="headerlink" title="6. Operator"></a>6. Operator</h3><p><code>Operator</code>其实就是<code>Function</code>，函数有时候也叫作算子。算子在<code>Java8</code>中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。算子<code>Operator</code>包括：<code>UnaryOperator</code>和<code>BinaryOperator</code>。分别对应单（一）元算子和二元算子。</p><p>算子的接口声明如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UnaryOperator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> UnaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t <span class="token operator">-</span><span class="token operator">></span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BinaryOperator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">BiFunction</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token punctuation">,</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">minBy</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">maxBy</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Operator只需声明一个泛型参数T即可。对应的使用示例如下：</p><pre class=" language-java"><code class="language-java">UnaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> increment <span class="token operator">=</span> x <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"递增:"</span> <span class="token operator">+</span> increment<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 递增:3</span>BinaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> add <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"相加:"</span> <span class="token operator">+</span> add<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 相加:5</span>BinaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> min <span class="token operator">=</span> BinaryOperator<span class="token punctuation">.</span><span class="token function">minBy</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> o1 <span class="token operator">-</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最小值:"</span> <span class="token operator">+</span> min<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 最小值:2</span></code></pre><h4 id="更多的Operator接口"><a href="#更多的Operator接口" class="headerlink" title="更多的Operator接口"></a>更多的Operator接口</h4><ul><li><code>LongUnaryOperator：long applyAsLong(long operand);</code>: 对long类型做操作的一元算子</li><li><code>IntUnaryOperator：int applyAsInt(int operand);</code>: 对int类型做操作的一元算子</li><li><code>DoubleUnaryOperator：double applyAsDouble(double operand);</code>: 对double类型做操作的一元算子</li><li><code>DoubleBinaryOperator：double applyAsDouble(double left, double right);</code>: 对double类型做操作的二元算子</li><li><code>IntBinaryOperator：int applyAsInt(int left, int right);</code>: 对int类型做操作的二元算子</li><li><code>LongBinaryOperator：long applyAsLong(long left, long right);</code>: 对long类型做操作的二元算子</li></ul><h3 id="7-其它函数式接口"><a href="#7-其它函数式接口" class="headerlink" title="7.其它函数式接口"></a>7.其它函数式接口</h3><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher</li><li>java.lang.reflect.InvocationHandler</li><li>java.beans.PropertyChangeListener</li><li>java.awt.event.ActionListener</li><li>javax.swing.event.ChangeListener</li></ul><h2 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在学习了<code>Lambda</code>表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在<code>Java8</code>中，我们可以直接通过方法引用来简写<code>Lambda</code>表达式中已经存在的方法。</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种特性就叫做方法引用<code>(Method Reference)</code>。</p><p>方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p><p>注意: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号::。</p><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><p>方法引用的标准形式是：类名::方法名。（注意：只需要写方法名，不需要写括号）</p><p>有以下四种形式的方法引用：</p><ul><li>引用静态方法: <code>ContainingClass::staticMethodName</code></li><li>引用某个对象的实例方法: <code>containingObject::instanceMethodName</code></li><li>引用某个类型的任意对象的实例方法:<code>ContainingType::methodName</code></li><li>引用构造方法: <code>ClassName::new</code></li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    LocalDate birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> LocalDate birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> LocalDate <span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareByAge</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodReferenceTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Person<span class="token punctuation">[</span><span class="token punctuation">]</span> pArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用匿名类</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用lambda表达式</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用方法引用，引用的是类的静态方法</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> Person<span class="token operator">:</span><span class="token operator">:</span>compareByAge<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、Stream"><a href="#五、Stream" class="headerlink" title="五、Stream"></a>五、Stream</h2><p><code>Java8</code>添加的<code>Stream API(java.util.stream)</code>把真正的函数式编程风格引入到<code>Java</code>中。这是目前为止对<code>Java</code>类库最好的补充，因为<code>Stream API</code>可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括``filter、map、flatMap、peel、distinct、sorted、limit和substream<code>。终止操作包括</code>forEach、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst<code>和</code>findAny<code>。</code>java.util.stream.Collectors`是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。</p><h3 id="1-一些重要方法说明"><a href="#1-一些重要方法说明" class="headerlink" title="1. 一些重要方法说明"></a>1. 一些重要方法说明</h3><ul><li>stream: 返回数据流，集合作为其源</li><li>parallelStream: 返回并行数据流， 集合作为其源</li><li>filter: 方法用于过滤出满足条件的元素</li><li>map: 方法用于映射每个元素对应的结果</li><li>forEach: 方法遍历该流中的每个元素</li><li>limit: 方法用于减少流的大小</li><li>sorted: 方法用来对流中的元素进行排序</li><li>anyMatch: 是否存在任意一个元素满足条件（返回布尔值）</li><li>allMatch: 是否所有元素都满足条件（返回布尔值）</li><li>noneMatch: 是否所有元素都不满足条件（返回布尔值）</li><li>collect: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li></ul><h3 id="2-一些使用示例"><a href="#2-一些使用示例" class="headerlink" title="2. 一些使用示例"></a>2. 一些使用示例</h3><h4 id="1-Filter-过滤"><a href="#1-Filter-过滤" class="headerlink" title="(1). Filter 过滤"></a>(1). Filter 过滤</h4><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="2-Sort-排序"><a href="#2-Sort-排序" class="headerlink" title="(2). Sort 排序"></a>(2). Sort 排序</h4><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-Map-映射"><a href="#3-Map-映射" class="headerlink" title="(3). Map 映射"></a>(3). Map 映射</h4><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="4-Match-匹配"><a href="#4-Match-匹配" class="headerlink" title="(4). Match 匹配"></a>(4). Match 匹配</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> anyStartsWithA <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>anyStartsWithA<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// true</span><span class="token keyword">boolean</span> allStartsWithA <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>allStartsWithA<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// false</span><span class="token keyword">boolean</span> noneStartsWithZ <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>noneStartsWithZ<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// true</span></code></pre><h4 id="5-Count-计数"><a href="#5-Count-计数" class="headerlink" title="(5). Count 计数"></a>(5). Count 计数</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> startsWithB <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>startsWithB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3</span></code></pre><h4 id="6-Reduce-规约"><a href="#6-Reduce-规约" class="headerlink" title="(6). Reduce 规约"></a>(6). Reduce 规约</h4><p>这是一个最终操作，允许通过指定的函数来将stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的。代码如下:</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> reduced <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>reduced<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="六、Optional"><a href="#六、Optional" class="headerlink" title="六、Optional"></a>六、Optional</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，<code>Google</code>公司著名的<code>Guava</code>项目引入了<code>Optional</code>类，<code>Guava</code>通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到<code>Google Guava</code>的启发，<code>Optional</code>类已经成为<code>Java 8</code>类库的一部分。</p><p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果<code>Optional</code>类的实例为非空值的话，<code>isPresent()</code>返回true，否从返回false。为了防止<code>Optional</code>为空值，<code>orElseGet()</code>方法通过回调函数来产生一个默认值。map()函数对当前Optional的值进行转化，然后返回一个新的Optional实例。orElse()方法和orElseGet()方法类似，但是orElse接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p><pre><code>Full Name is set? falseFull Name: [none]Hey Stranger!</code></pre><p>让我们来看看另一个例子：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是程序的输出：</p><pre class=" language-java"><code class="language-java">First Name is set<span class="token operator">?</span> <span class="token boolean">true</span>First Name<span class="token operator">:</span> TomHey Tom<span class="token operator">!</span></code></pre><h2 id="七、Date-Time-API"><a href="#七、Date-Time-API" class="headerlink" title="七、Date/Time API"></a>七、Date/Time API</h2><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p><h3 id="1-Clock-时钟"><a href="#1-Clock-时钟" class="headerlink" title="1. Clock 时钟"></a>1. Clock 时钟</h3><p><code>Clock</code>类提供了访问当前日期和时间的方法，<code>Clock</code>是时区敏感的，可以用来取代<code>System.currentTimeMillis()</code>来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。代码如下:</p><pre class=" language-java"><code class="language-java">Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> millis <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Instant instant <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">instant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// legacy java.util.Date</span></code></pre><h3 id="2-Timezones-时区"><a href="#2-Timezones-时区" class="headerlink" title="2. Timezones 时区"></a>2. Timezones 时区</h3><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">getAvailableZoneIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// prints all available timezone ids</span>ZoneId zone1 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ZoneId zone2 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Brazil/East"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone1<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone2<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=+01:00]</span><span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=-03:00]</span></code></pre><h3 id="3-LocalTime-本地时间"><a href="#3-LocalTime-本地时间" class="headerlink" title="3. LocalTime 本地时间"></a>3. LocalTime 本地时间</h3><p>LocalTime定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下:</p><pre class=" language-java"><code class="language-java">LocalTime now1 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone1<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime now2 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>now2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token keyword">long</span> hoursBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> minutesBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hoursBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// -3</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minutesBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// -239</span>LocalTime提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下<span class="token operator">:</span>LocalTime late <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>late<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 23:59:59</span>DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofLocalizedTime</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>SHORT<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime leetTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"13:37"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetTime<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 13:37</span></code></pre><h3 id="4-LocalDate-本地日期"><a href="#4-LocalDate-本地日期" class="headerlink" title="4. LocalDate 本地日期"></a>4. LocalDate 本地日期</h3><p><code>LocalDate</code>表示了一个确切的日期，比如2014-03-11。该对象值是不可变的，用起来和<code>LocalTime</code>基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate tomorrow <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate yesterday <span class="token operator">=</span> tomorrow<span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate independenceDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>JULY<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DayOfWeek dayOfWeek <span class="token operator">=</span> independenceDay<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FRIDAY</span></code></pre><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下:</p><pre class=" language-java"><code class="language-java">DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofLocalizedDate</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate xmas <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"24.12.2014"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>xmas<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2014-12-24</span></code></pre><h3 id="5-LocalDateTime-本地日期时间"><a href="#5-LocalDateTime-本地日期时间" class="headerlink" title="5. LocalDateTime 本地日期时间"></a>5. LocalDateTime 本地日期时间</h3><p><code>LocalDateTime</code>同时表示了时间和日期，相当于前两节内容合并到一个对象上了。<code>LocalDateTime</code>和<code>LocalTime</code>还有<code>LocalDate</code>一样，都是不可变的。<code>LocalDateTime</code>提供了一些能访问具体字段的方法。代码如下:</p><pre class=" language-java"><code class="language-java">LocalDateTime sylvester <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DayOfWeek dayOfWeek <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// WEDNESDAY</span>Month month <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// DECEMBER</span><span class="token keyword">long</span> minuteOfDay <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>ChronoField<span class="token punctuation">.</span>MINUTE_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minuteOfDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1439</span></code></pre><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。代码如下:</p><pre class=" language-java"><code class="language-java">Instant instant <span class="token operator">=</span> sylvester        <span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>legacyDate<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Wed Dec 31 23:59:59 CET 2014</span></code></pre><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下:</p><pre class=" language-java"><code class="language-java">DateTimeFormatter formatter <span class="token operator">=</span>    DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd, yyyy - HH:mm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDateTime parsed <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"Nov 03, 2014 - 07:13"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>String string <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parsed<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Nov 03, 2014 - 07:13</span></code></pre><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。</p><p>关于<code>Java8</code>中日期API更多的使用示例可以参考<code>Java 8</code>中关于日期和时间API的20个使用示例。</p><h2 id="八、重复注解"><a href="#八、重复注解" class="headerlink" title="八、重复注解"></a>八、重复注解</h2><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。<code>Java 8</code>打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p><p>重复注解机制本身必须用<code>@Repeatable</code>注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Repeatable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RepeatingAnnotations</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filters</span> <span class="token punctuation">{</span>        Filter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Filters<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>        String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filterable</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Filter filter<span class="token operator">:</span> Filterable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Filter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>正如我们看到的，这里有个使用<code>@Repeatable(Filters.class)</code>注解的注解类<code>Filter</code>，<code>Filters</code>仅仅是<code>Filter</code>注解的数组，但<code>Java</code>编译器并不想让程序员意识到<code>Filters</code>的存在。这样，接口<code>Filterable</code>就拥有了两次<code>Filter</code>（并没有提到<code>Filter</code>）注解。</p><p>同时，反射相关的API提供了新的函数<code>getAnnotationsByType()</code>来返回重复注解的类型（请注意<code>Filterable.class.getAnnotation(Filters.class)</code>经编译器处理后将会返回<code>Filters</code>的实例）。</p>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中的@AliasFor标签</title>
      <link href="/2019/07/15/Spring%E4%B8%AD%E7%9A%84-AliasFor%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/07/15/Spring%E4%B8%AD%E7%9A%84-AliasFor%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring中的-AliasFor标签"><a href="#Spring中的-AliasFor标签" class="headerlink" title="Spring中的@AliasFor标签"></a>Spring中的@AliasFor标签</h2><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/aliasfor.png" alt><br>在<code>Spring</code>的众多注解中，经常会发现很多注解的不同属性起着相同的作用，比如<code>@RequestMapping</code>的<code>value</code>属性和<code>path</code>属性，这就需要做一些基本的限制，比如<code>value</code>和<code>path</code>的值不能冲突，比如任意设置<code>value</code>或者设置<code>path</code>属性的值，都能够通过另一个属性来获取值等等。为了统一处理这些情况，<code>Spring</code>创建了<code>@AliasFor</code>标签。</p><a id="more"></a><h3 id="1-1-AliasFor有几种使用方式"><a href="#1-1-AliasFor有几种使用方式" class="headerlink" title="1.1 @AliasFor有几种使用方式"></a>1.1 @AliasFor有几种使用方式</h3><h4 id="1-1-1在同一个注解内显示使用"><a href="#1-1-1在同一个注解内显示使用" class="headerlink" title="1.1.1在同一个注解内显示使用**"></a>1.1.1在同一个注解内显示使用**</h4><ul><li>比如在@RequestMapping中的使用示例：<br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/RequestMapping.png" alt></li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Mapping</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">RequestMapping</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><ul><li><p>又比如@ContextConfiguration注解中的value和locations属性:<br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/contextConfiguration.png" alt></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ContextConfiguration</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"locations"</span><span class="token punctuation">)</span>  String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>  String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">locations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre></li></ul><p>在同一个注解中成对使用即可，比如示例代码中，value和path就是互为别名。但是要注意一点，@AliasFor标签有一些使用限制，但是这应该能想到的，比如要求互为别名的属性属性值类型，默认值，都是相同的，互为别名的注解必须成对出现，比如value属性添加了@AliasFor(“path”)，那么path属性就必须添加@AliasFor(“value”)，另外还有一点，互为别名的属性必须定义默认值。</p><h4 id="1-1-2-显示的覆盖元注解中的属性"><a href="#1-1-2-显示的覆盖元注解中的属性" class="headerlink" title="1.1.2 显示的覆盖元注解中的属性"></a>1.1.2 显示的覆盖元注解中的属性</h4><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/contextConfiguration.png" alt></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringJUnit4ClassRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> AopConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopUtilsTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><p>这段代码是一个非常熟悉的基于<code>JavaConfig</code>的<code>Spring</code>测试代码；假如现在我有个癖好，我觉得每次写<code>@ContextConfiguration(classes = AopConfig.class)</code>太麻烦了，我想写得简单一点，我就可以定义一个这样的标签,使用我们的STC：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">STC</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"classes"</span><span class="token punctuation">,</span> annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">cs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>正常运行；<br>这就是<code>@AliasFor</code>标签的第二种用法，显示的为元注解中的属性起别名；这时候也有一些限制，比如属性类型，属性默认值必须相同；当然，在这种使用情况下，<code>@AliasFor</code>只能为作为当前注解的元注解起别名；</p><h4 id="1-1-3-在一个注解中隐式声明别名"><a href="#1-1-3-在一个注解中隐式声明别名" class="headerlink" title="1.1.3 在一个注解中隐式声明别名"></a>1.1.3 在一个注解中隐式声明别名</h4><p>这种使用方式和第二种使用方式比较相似，我们直接使用Spring官方文档的例子：</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@ContextConfiguration</span> <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MyTestConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"locations"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"locations"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">groovyScripts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"locations"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">xmlFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>可以看到，在<code>MyTestConfig</code>注解中，为<code>value</code>，<code>groovyScripts</code>，<code>xmlFiles</code>都定义了别名<code>@AliasFor(annotation = ContextConfiguration.class, attribute = “locations”)</code>，所以，其实在这个注解中，<code>value</code>、<code>groovyScripts</code>和<code>xmlFiles</code>也互为别名，这个就是所谓的在统一注解中的隐式别名方式；</p><h4 id="1-1-4-别名的传递"><a href="#1-1-4-别名的传递" class="headerlink" title="1.1.4 别名的传递"></a>1.1.4 别名的传递</h4><p>@AliasFor注解是允许别名之间的传递的，简单理解，如果A是B的别名，并且B是C的别名，那么A是C的别名；</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@MyTestConfig</span> <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">GroovyOrXmlTestConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> MyTestConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"groovyScripts"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">groovy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"locations"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">xml</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ol><li>GroovyOrXmlTestConfig把 @MyTestConfig（参考上一个案例）作为元注解；</li><li>定义了groovy属性，并作为MyTestConfig中的groovyScripts属性的别名；</li><li>定义了xml属性，并作为ContextConfiguration中的locations属性的别名；</li><li>因为MyTestConfig中的groovyScripts属性本身就是ContextConfiguration中的locations属性的别名；所以xml属性和groovy属性也互为别名；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 内置容器优化</title>
      <link href="/2019/07/14/SpringBoot%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8undertow%E4%BC%98%E5%8C%96/"/>
      <url>/2019/07/14/SpringBoot%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8undertow%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot容器调整为-Undertow"><a href="#SpringBoot容器调整为-Undertow" class="headerlink" title="SpringBoot容器调整为 Undertow"></a>SpringBoot容器调整为 Undertow</h2><p><img src="http://undertow.io/images/undertow_banner.png" alt><br>Spring Boot内嵌容器支持Tomcat、Jetty、Undertow。为什么选择Undertow？</p><p>这里有一篇文章，时间 2017年1月26日发布的：</p><p><a href="https://examples.javacodegeeks.com/enterprise-java/spring/tomcat-vs-jetty-vs-undertow-comparison-of-spring-boot-embedded-servlet-containers/" target="_blank" rel="noopener">Tomcat vs. Jetty vs. Undertow: Comparison of Spring Boot Embedded Servlet Containers</a>.</p><a id="more"></a><p>这篇文章详细测试了Spring Boot应用在三种容器下的性能和内存使用，内含完整的测试代码和测试流程。证明了Undertow在性能和内存使用上是最好的。</p><p>在Spring Boot中使用 Undertow 而不是 Tomcat</p><h3 id="1-1-什么是-undertow"><a href="#1-1-什么是-undertow" class="headerlink" title="1.1 什么是 undertow?"></a>1.1 什么是 undertow?</h3><blockquote><p>Undertow 是一个采用 Java 开发的灵活的高性能 Web 服务器，提供包括阻塞和基于 NIO 的非堵塞机制。Undertow 是红帽公司的开源产品，是 Wildfly 默认的 Web 服务器。Undertow 提供一个基础的架构用来构建 Web 服务器，这是一个完全为嵌入式设计的项目，提供易用的构建器 API，完全兼容 Java EE Servlet 3.1 和低级非堵塞的处理器。</p></blockquote><h3 id="1-2-配置maven依赖"><a href="#1-2-配置maven依赖" class="headerlink" title="1.2 配置maven依赖"></a>1.2 配置maven依赖</h3><p><code>Maven示例</code></p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- Undertow Web 容器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-undertow<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="1-3-编写配置文件"><a href="#1-3-编写配置文件" class="headerlink" title="1.3 编写配置文件"></a>1.3 编写配置文件</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">undertow</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程</span>    <span class="token comment" spellcheck="true"># 不要设置过大，如果过大，启动项目会报错：打开文件数过多</span>    <span class="token key atrule">io-threads</span><span class="token punctuation">:</span> <span class="token number">8</span>    <span class="token comment" spellcheck="true"># 阻塞任务线程池, 当执行类似servlet请求阻塞IO操作, undertow会从这个线程池中取得线程</span>    <span class="token comment" spellcheck="true"># 它的值设置取决于系统线程执行任务的阻塞系数，默认值是IO线程数*8</span>    <span class="token key atrule">worker-threads</span><span class="token punctuation">:</span> <span class="token number">64</span>    <span class="token comment" spellcheck="true"># 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理</span>    <span class="token comment" spellcheck="true"># 每块buffer的空间大小,越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可</span>    <span class="token key atrule">buffer-size</span><span class="token punctuation">:</span> <span class="token number">1024</span>    <span class="token comment" spellcheck="true"># 是否分配的直接内存(NIO直接分配的堆外内存)</span>    <span class="token key atrule">direct-buffers</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h3 id="1-4-源码查看"><a href="#1-4-源码查看" class="headerlink" title="1.4 源码查看"></a>1.4 源码查看</h3><p><a href="https://github.com/undertow-io/undertow/blob/master/core/src/main/java/io/undertow/Undertow.java" target="_blank" rel="noopener">Undertow.java</a></p><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/undertow.png" alt></p><pre class=" language-java"><code class="language-java">ioThreads <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>workerThreads <span class="token operator">=</span> ioThreads <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//smaller than 64mb of ram we use 512b buffers</span><span class="token keyword">if</span> <span class="token punctuation">(</span>maxMemory <span class="token operator">&lt;</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use 512b buffers</span>    directBuffers <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    bufferSize <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>maxMemory <span class="token operator">&lt;</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use 1k buffers</span>    directBuffers <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    bufferSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use 16k buffers for best performance</span>    <span class="token comment" spellcheck="true">//as 16k is generally the max amount of data that can be sent in a single write() call</span>    directBuffers <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    bufferSize <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">-</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//the 20 is to allow some space for protocol headers, see UNDERTOW-1209</span><span class="token punctuation">}</span></code></pre><p>很显然，Undertow认为它的运用场景是在IO密集型的系统应用中，并且认为多核机器是一个比较容易满足的点，Undertow初始化假想应用的阻塞系数在0.8~0.9之间，所以阻塞线程数直接乘了个8，当然，如果对应用较精确的估测阻塞系数，可以配置上去。</p>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> undertow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 60 题：排列组合问题</title>
      <link href="/2019/07/11/LeetCode%20%E7%AC%AC%2060%20%E9%A2%98%EF%BC%9A%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/11/LeetCode%20%E7%AC%AC%2060%20%E9%A2%98%EF%BC%9A%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-第-60-题：第k个排列"><a href="#LeetCode-第-60-题：第k个排列" class="headerlink" title="LeetCode 第 60 题：第k个排列"></a>LeetCode 第 60 题：第k个排列</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>给出集合 <code>[1,2,3,…,n]</code>，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：<br><code>&quot;123&quot;   &quot;132&quot;   &quot;213&quot;   &quot;231&quot;   &quot;312&quot;   &quot;321&quot;</code><br>给定 n 和 k，返回第 k 个排列。</p><a id="more"></a><p>说明：</p><ul><li>给定 n 的范围是<code>[1, 9]</code>。</li><li>给定 k 的范围是<code>[1,  n!]</code>。</li></ul><p>示例 1:</p><pre><code>输入: n = 3, k = 3输出: &quot;213&quot;</code></pre><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>核心公式：</p><p>当前位置字符 = ((k - 1) % n!) / (n - 1)! 由于排列是按顺序的，那么第k个排列是可以计算出来的</p><p>比如:</p><ul><li><p><code>n=3</code>时。在所有<code>3！= 6</code>个排列中，第一个字符是按照<code>（3-1）！</code>个一组排列的，也就是<code>123,132（（3-1）！）</code>。</p></li><li><p><code>n=4</code>也一样<code>1234,1243,1324,1342,1423,1432（（4-1）！）</code>。 </p></li></ul><p>那么就可以根据这个规律设计核心公式，前提是在程序设计上需要一个基本字符串。比如当n=3，k=3时第一个字符所在位置为2，是针对123这个字符串来说的，在把2提出后，源字符串应该改写为13.根据这两点不断递归得到结果</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeetCode60</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成基本字符串     *     * @param n     * @param k     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPermutation</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuffer baseStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuffer str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> baseStr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">doCount</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> baseStr<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据公式生成字符串     *     * @param n     * @param k     * @param baseStr     * @param str     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> StringBuffer <span class="token function">doCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> StringBuffer baseStr<span class="token punctuation">,</span> StringBuffer str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>baseStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer fac <span class="token operator">=</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> k <span class="token operator">/</span> fac<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当前位置的字符</span>        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>baseStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        baseStr<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">doCount</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">%</span> fac<span class="token punctuation">,</span> baseStr<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 阶乘计算公式     *     * @param n     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fac <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fac <span class="token operator">*=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> fac<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>LeetCode60<span class="token punctuation">.</span><span class="token function">getPermutation</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 98 题：验证二叉搜索树</title>
      <link href="/2019/07/09/LeetCode%20%E7%AC%AC%2098%20%E9%A2%98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2019/07/09/LeetCode%20%E7%AC%AC%2098%20%E9%A2%98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-第-98-题：验证二叉搜索树"><a href="#LeetCode-第-98-题：验证二叉搜索树" class="headerlink" title="LeetCode 第 98 题：验证二叉搜索树"></a>LeetCode 第 98 题：验证二叉搜索树</h2><p><strong>题目</strong><br><code>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</code></p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong><em>示例 1:</em></strong></p><pre><code>输入:    2   / \  1   3输出: true</code></pre><a id="more"></a><p><strong><em>示例 2:</em></strong></p><pre><code>输入:    5   / \  1   4     / \    3   6输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> val<span class="token punctuation">;</span>  TreeNode left<span class="token punctuation">;</span>  TreeNode right<span class="token punctuation">;</span>  <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    val <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>乍一看，这是一个平凡的问题。只需要遍历整棵树，检查<code>node.right.val &gt; node.val</code>和 <code>node.left.val &lt; node.val</code>对每个结点是否成立。<br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/9/1.png" alt></p><p>问题是，这种方法并不总是正确。不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点。例如:<br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/9/2.png" alt></p><p>这意味着我们需要在遍历树的同时保留结点的上界与下界，子啊比较时不仅比较子结点的值，也要与上下界比较。 </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: lishangzhi * @Date: 2019/7/9 * @Description: &lt;验证二叉搜索树> * @link https://leetcode-cn.com/problems/validate-binary-search-tree/ */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeetCode90</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> pre <span class="token operator">=</span> Long<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 验证二叉树     *     * @param root     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 验证左边树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//验证右边树</span>                <span class="token keyword">return</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试案例     *     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LeetCode90 leetCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LeetCode90</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 模拟二叉树数据</span>        TreeNode treeNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        TreeNode treeNode = new TreeNode(5);</span><span class="token comment" spellcheck="true">//        treeNode.right = new TreeNode(1);</span><span class="token comment" spellcheck="true">//        treeNode.left = new TreeNode(4);</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//        treeNode.right.left = new TreeNode(3);</span><span class="token comment" spellcheck="true">//        treeNode.right.right = new TreeNode(6);</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetCode<span class="token punctuation">.</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的五种依赖注入方式</title>
      <link href="/2019/07/08/Spring%E7%9A%84%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/07/08/Spring%E7%9A%84%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring的五种依赖注入方式"><a href="#Spring的五种依赖注入方式" class="headerlink" title="Spring的五种依赖注入方式"></a>Spring的五种依赖注入方式</h2><blockquote><p><font size="1">Java开发中，某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做</font></p></blockquote><a id="more"></a><p><strong>Spring有多种依赖注入的形式，下面介绍spring进行DI的方式</strong></p><h3 id="一-Autowired：自动装配"><a href="#一-Autowired：自动装配" class="headerlink" title="一 @Autowired：自动装配"></a>一 @Autowired：自动装配</h3><p>前面已经比较过<code>@Autowired</code>和<code>@Resource</code>的区别<br><a href="https://lishangzhi.github.io/2019/07/08/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/">@Autowired和@Resource的区别?</a></p><p>@Autowired默认是根据参数类型进行自动装配，且必须有一个Bean候选者注入<font color="red">默认required=true，如果允许出现0个Bean候选者需要设置属性“required=false”</font>，“required”属性含义和@Required一样，只是@Required只适用于基于XML配置的setter注入方式,只能打在setting方法上</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Autowired</span>   <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="二-setter-方法注入"><a href="#二-setter-方法注入" class="headerlink" title="二 setter 方法注入"></a>二 setter 方法注入</h3><p>这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个IDao对象，那么就可以定义一个private的IDao成员变量，然后创建IDao的set方法（这是ioc的注入入口）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象 iDao</span>    <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一定要写被注入对象的set方法   </span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setiDao</span><span class="token punctuation">(</span>IDao iDao<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>iDao <span class="token operator">=</span> iDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        iDao<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="三-构造器注入"><a href="#三-构造器注入" class="headerlink" title="三 构造器注入"></a>三 构造器注入</h3><p>这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象SpringDao</span>    <span class="token keyword">private</span>  SpringDao springDao<span class="token punctuation">;</span>    <span class="token keyword">private</span>  User user<span class="token punctuation">;</span>    <span class="token keyword">private</span>  <span class="token function">SpringAction</span><span class="token punctuation">(</span>SpringDao springDao<span class="token punctuation">,</span>User user<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>springDao <span class="token operator">=</span>springDao<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法调用springDao和user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span>  <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"iByte"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        springDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="四-静态工厂的方法注入"><a href="#四-静态工厂的方法注入" class="headerlink" title="四 静态工厂的方法注入"></a>四 静态工厂的方法注入</h3><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaoFactory</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//静态工厂  </span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FactoryDao <span class="token function">getStaticFactoryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StaticFacotryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象  </span>    privateFactoryDaostaticFactoryDao<span class="token punctuation">;</span>    <span class="token function">publicvoidstaticFactoryOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        staticFactoryDao<span class="token punctuation">.</span><span class="token function">saveFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//注入对象的set方法  </span>    <span class="token function">publicvoidsetStaticFactoryDao</span><span class="token punctuation">(</span>FactoryDaostaticFactoryDao<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>staticFactoryDao<span class="token operator">=</span>staticFactoryDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="四-实例工厂的方法注入"><a href="#四-实例工厂的方法注入" class="headerlink" title="四 实例工厂的方法注入"></a>四 实例工厂的方法注入</h3><p>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例</p>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依赖注入 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired和@Resource的区别</title>
      <link href="/2019/07/07/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/07/07/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Autowired和-Resource的区别是什么"><a href="#Autowired和-Resource的区别是什么" class="headerlink" title="@Autowired和@Resource的区别是什么?"></a>@Autowired和@Resource的区别是什么?</h2><blockquote><p><font size="1">最近在实现NLP意图匹配时候接口实现，默认支持了采用图灵nlp,采用云问nlp,百度nlp和公司内部自研的nlp; 基础接口都一样实现方式不一样而已,在定义完NLPWrapedService接口后统一,四个实现类全部实现NLPWrapedService，在注入的时候采用<code>@Autowired</code>在业务端确定Nlp类型后AI端无法注入指定的实现类，后续调整为@Resource;顺便查了相关资料补充下</font></p></blockquote><a id="more"></a><p>用途：做bean的注入时使用</p><p><strong>背景</strong>：</p><ul><li><code>@Autowired</code> 属于Spring的注解　<code>org.springframework.beans.factory.annotation.Autowired</code></li><li><code>@Resource</code>　不属于Spring的注解，JDK1.6支持的注解　<code>javax.annotation.Resource</code></li></ul><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/8/1.png" alt="@Autowired" title="@Autowired.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/8/2.png" alt="@Resource" title="@Resource.png"></p><p><strong>共同点</strong>：</p><ul><li>装配bean. 写在字段上,或写在<code>setter</code>方法</li></ul><p><strong>不同点</strong>：</p><ul><li><p><code>@Autowired</code>  默认按类型装配,依赖对象必须存在，如果要允许null值，可以设置它的required属性为false<br><code>@Autowired(required=false)</code>也可以使用名称装配，配合@Qualifier注解</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Autowired</span>   <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li><li><p><code>@Resource</code>  默认按名称进行装配，通过name属性进行指定</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 下面两种@Resource只要使用一种即可</span>  <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>  <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于字段上</span>  <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setIDao</span><span class="token punctuation">(</span>IDao iDao<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 用于属性的setter方法上</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>iDao <span class="token operator">=</span> iDao<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><table><thead><tr><th>注入方式</th><th>API文档说明</th></tr></thead><tbody><tr><td>*.annotation.Autowired</td><td>【Spring】<a href="https://docs.spring.io/spring/docs/current/javadoc-api/" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/javadoc-api/</a></td></tr><tr><td>*.annotation.Resource</td><td>【JDK1.8】<a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/index.html</a></td></tr></tbody></table><br><p><strong>注意</strong><br>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><p>@Resource装配顺序：</p><p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p><p>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p><p>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p><p>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p>]]></content>
      
      
      <categories>
          
          <category> Java Notes </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 5 题：最长回文子串</title>
      <link href="/2019/07/04/LeetCode%20%E7%AC%AC%205%20%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/07/04/LeetCode%20%E7%AC%AC%205%20%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-第-5-题：最长回文子串"><a href="#LeetCode-第-5-题：最长回文子串" class="headerlink" title="LeetCode 第 5 题：最长回文子串"></a>LeetCode 第 5 题：最长回文子串</h2><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p></blockquote><pre><code>示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><a id="more"></a><p>回文串可分为奇数回文串和偶数回文串。它们的区别是：奇数回文串关于它的“中点”满足“中心对称”，偶数回文串关于它“中间的两个点”满足“中心对称”。</p><h3 id="方法一：暴力匹配-（Brute-Force）"><a href="#方法一：暴力匹配-（Brute-Force）" class="headerlink" title="方法一：暴力匹配 （Brute Force）"></a>方法一：暴力匹配 （Brute Force）</h3><p>暴力解法虽然时间复杂度高，但是思路清晰、编写简单，因为编写的正确性高，完全可以使用暴力匹配算法检验我们编写的算法的正确性。<br>（这里就不展示暴力匹配的写法了，实际上是我很懒。）</p><h3 id="方法二：中心扩散法"><a href="#方法二：中心扩散法" class="headerlink" title="方法二：中心扩散法"></a>方法二：中心扩散法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>            start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            end <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> L <span class="token operator">=</span> left<span class="token punctuation">,</span> R <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        L<span class="token operator">--</span><span class="token punctuation">;</span>        R<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="方法三：动态规划（推荐）"><a href="#方法三：动态规划（推荐）" class="headerlink" title="方法三：动态规划（推荐）"></a>方法三：动态规划（推荐）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> longestPalindrome <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        String longestPalindromeStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// abcdedcba</span>        <span class="token comment" spellcheck="true">//   l   r</span>        <span class="token comment" spellcheck="true">// 如果 dp[l, r] = true 那么 dp[l + 1, r - 1] 也一定为 true</span>        <span class="token comment" spellcheck="true">// 关键在这里：[l + 1, r - 1] 一定至少有 2 个元素才有判断的必要</span>        <span class="token comment" spellcheck="true">// 因为如果 [l + 1, r - 1] 只有一个元素，不用判断，一定是回文串</span>        <span class="token comment" spellcheck="true">// 如果 [l + 1, r - 1] 表示的区间为空，不用判断，也一定是回文串</span>        <span class="token comment" spellcheck="true">// [l + 1, r - 1] 一定至少有 2 个元素 等价于 l + 1 &lt; r - 1，即 r - l >  2</span>        <span class="token comment" spellcheck="true">// 写代码的时候这样写：如果 [l + 1, r - 1]  的元素小于等于 1 个，即 r - l &lt;=  2 ，就不用做判断了</span>        <span class="token comment" spellcheck="true">// 因为只有 1 个字符的情况在最开始做了判断</span>        <span class="token comment" spellcheck="true">// 左边界一定要比右边界小，因此右边界从 1 开始</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 区间应该慢慢放大</span>                <span class="token comment" spellcheck="true">// 状态转移方程：如果头尾字符相等并且中间也是回文</span>                <span class="token comment" spellcheck="true">// 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可</span>                <span class="token comment" spellcheck="true">// 否则要继续看收缩以后的区间的回文性</span>                <span class="token comment" spellcheck="true">// 重点理解 or 的短路性质在这里的作用</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> longestPalindrome<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        longestPalindrome <span class="token operator">=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                        longestPalindromeStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> longestPalindromeStr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 中心扩散 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第148题：排序链表</title>
      <link href="/2019/07/03/LeetCode%E7%AC%AC148%E9%A2%98%EF%BC%9A%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/03/LeetCode%E7%AC%AC148%E9%A2%98%EF%BC%9A%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode第148题：排序链表"><a href="#LeetCode第148题：排序链表" class="headerlink" title="LeetCode第148题：排序链表"></a>LeetCode第148题：排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><pre class=" language-$xslt"><code class="language-$xslt">示例 1:输入: 4->2->1->3输出: 1->2->3->4示例 2:输入: -1->5->3->4->0输出: -1->0->3->4->5</code></pre><h3 id="“单链表”自底向上实现”归并排序”"><a href="#“单链表”自底向上实现”归并排序”" class="headerlink" title="“单链表”自底向上实现”归并排序”"></a>“单链表”自底向上实现”归并排序”</h3><a id="more"></a><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/1.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-1" title="配图-1.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/2.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-2" title="配图-2.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/3.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-3" title="配图-3.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/4.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-4" title="配图-4.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/5.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-5" title="配图-5.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/6.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-6" title="配图-6.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/7.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-7" title="配图-7.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/8.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-8" title="配图-8.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/9.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-9" title="配图-9.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/10.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-10" title="配图-10.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/11.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-11" title="配图-11.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/12.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-12" title="配图-12.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/13.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-13" title="配图-13.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/14.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-14" title="配图-14.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/15.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-15" title="配图-15.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/16.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-16" title="配图-16.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/17.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-17" title="配图-17.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/18.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-18" title="配图-18.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/19.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-19" title="配图-19.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/20.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-20" title="配图-20.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/21.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-21" title="配图-21.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/22.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-22" title="配图-22.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/23.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-23" title="配图-23.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/24.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-24" title="配图-24.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>lishangzhi<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: lishangzhi * @Date: 2019/7/3 * @Description: &lt;自下而上进行归并> */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Definition for singly-linked list.     * public class ListNode {     *     int val;     *     ListNode next;     *     ListNode(int x) { val = x; }     * }     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这里设置 64 ，是一个绰绰有余的数字，可以满足结点数量为 2^64 这么多的单链表的排序</span>        ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历到的最大的 counter 数组的索引</span>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 先把当前元素暂存起来，马上我们就要把它放到 counter 数组合适的位置上</span>            ListNode carryNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// curNode 指针马上后移，方便下次处理</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 拿出的节点就和原来的链表没有关系了，我们在 counter 数组中完成排序，所以要切断它和原链表的关系</span>            carryNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 尝试从 counter 数组 0 号索引开始放置</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 只要非空当前位置非空，就进行一次 merge，merge 以后尝试放到下一格，如果下一格非空就继续合并</span>            <span class="token comment" spellcheck="true">// 合并以后再尝试放到下一格，直到下一格为空，直接放在那个为空的下一格就好</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode newMergeNode <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>carryNode<span class="token punctuation">,</span> counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                carryNode <span class="token operator">=</span> newMergeNode<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 遇到了空，就把 carryNode 放在数组的这个位置上</span>            counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> carryNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 记录最多使用到 counter 数组的第几位，最后合并的时候要用上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> maxIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历整个 count 数组，将它们全部归并，这个操作就和归并 n 个有序单链表是一样的了，我们这里采用两两归并</span>        ListNode res <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 归并两个已经排好序的单链表，是我们非常熟悉的操作了，可以递归完成，也可以穿针引线，这里我们递归完成     *     * @param l1 顺序存放的单链表1     * @param l2 顺序存放的单链表2     * @return 合并以后的单链表     */</span>    <span class="token keyword">private</span> ListNode <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义长度为5的单链表</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        MergeSort solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MergeSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode sortList <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sortList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="题目地址"><a href="#题目地址" class="headerlink" title=" 题目地址   "></a> 题目地址   </h2><p> <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">LeetCode第148题：排序链表.</a>    </p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 44 题：通配符匹配</title>
      <link href="/2019/07/02/LeetCode%20%E7%AC%AC44%E9%A2%98%EF%BC%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/07/02/LeetCode%20%E7%AC%AC44%E9%A2%98%EF%BC%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><pre><code>说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</code></pre><a id="more"></a><pre><code>示例 1:输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre><pre><code>示例 2:输入:s = &quot;aa&quot;p = &quot;*&quot;输出: true解释: &#39;*&#39; 可以匹配任意字符串。</code></pre><pre><code>示例 3:输入:s = &quot;cb&quot;p = &quot;?a&quot;输出: false解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。</code></pre><pre><code>示例 4:输入:s = &quot;adceb&quot;p = &quot;*a*b&quot;输出: true解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.</code></pre><pre><code>示例 5:输入:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;输入: false</code></pre><h2 id="LeetCode-第-44-题：通配符匹配"><a href="#LeetCode-第-44-题：通配符匹配" class="headerlink" title="LeetCode 第 44 题：通配符匹配"></a>LeetCode 第 44 题：通配符匹配</h2><h3 id="思路一-利用两个指针进行遍历"><a href="#思路一-利用两个指针进行遍历" class="headerlink" title="思路一: 利用两个指针进行遍历"></a>思路一: 利用两个指针进行遍历</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sn <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pn <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> match <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                start <span class="token operator">=</span> j<span class="token punctuation">;</span>                match <span class="token operator">=</span> i<span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                match<span class="token operator">++</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> match<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="思路二-动态规划"><a href="#思路二-动态规划" class="headerlink" title="思路二: 动态规划"></a>思路二: 动态规划</h3><p><code>dp[i][j]</code>表示<code>s</code>到<code>i</code>位置,<code>p</code>到<code>j</code>位置是否匹配!</p><p>初始化:<br><code>dp[0][0]</code>:什么都没有,所以为true<br>第一行<code>dp[0][j]</code>,换句话说,<code>s</code>为空,与<code>p</code>匹配,所以只要<code>p</code>开始为<code>*</code>才为<code>true</code><br>第一列<code>dp[i][0]</code>,当然全部为<code>False</code><br>动态方程:</p><p>如果<code>(s[i] == p[j] || p[j] == &quot;?&quot;)</code> &amp;&amp; <code>dp[i-1][j-1] ,有dp[i][j] = true</code></p><p>如果<code>p[j] == &quot;*&quot; &amp;&amp; (dp[i-1][j] = true || dp[i][j-1] = true)</code>有<code>dp[i][j] = true</code></p><h5 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h5><p>​    <code>dp[i-1][j]</code>,表示<code>*</code>代表是空字符,例如<code>ab,ab*</code></p><p>​    <code>dp[i][j-1]</code>,表示<code>*</code>代表非空任何字符,例如<code>abcd,ab*</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 多一维的空间，因为求 dp[len - 1][j] 的时候需要知道 dp[len][j] 的情况，</span>        <span class="token comment" spellcheck="true">// 多一维的话，就可以把 对 dp[len - 1][j] 也写进循环了</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// dp[len][len] 代表两个空串是否匹配了，"" 和 "" ，当然是 true 了。</span>        dp<span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从 len 开始减少</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// dp[text.length()][pattern.length()] 已经进行了初始化</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//相比之前增加了判断是否等于 *</span>                <span class="token keyword">boolean</span> first_match <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">||</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span> <span class="token operator">||</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//将 * 跳过 和将字符匹配一个并且 pattern 不变两种情况</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> first_match <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> first_match <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="题目地址"><a href="#题目地址" class="headerlink" title=" 题目地址   "></a> 题目地址   </h2><p> <a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">LeetCode 第 44 题：通配符匹配.</a>                    </p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 557 题：反转字符串中的单词</title>
      <link href="/2019/07/01/LeetCode%20%E7%AC%AC557%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/"/>
      <url>/2019/07/01/LeetCode%20%E7%AC%AC557%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目地址</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">LeetCode 第 557 题：反转字符串中的单词.</a></td><td><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/557-fan-zhuan-zi-fu-chuan-zhong-de-dan-ci-iii-ti-j/" target="_blank" rel="noopener">字符串处理</a></td></tr></tbody></table><h2 id="LeetCode-第-557-题：反转字符串中的单词"><a href="#LeetCode-第-557-题：反转字符串中的单词" class="headerlink" title="LeetCode 第 557 题：反转字符串中的单词"></a>LeetCode 第 557 题：反转字符串中的单词</h2><ul><li>空间设想<br><img src="http://ptyodd4up.bkt.clouddn.com/leecode711.png" alt="空间设想" title="设想.jpg"></li></ul><h3 id="一-利用StringBuffer-reverse-方法"><a href="#一-利用StringBuffer-reverse-方法" class="headerlink" title="一 . 利用StringBuffer reverse()方法"></a>一 . 利用StringBuffer reverse()方法</h3><ol><li>令n为旧字符序列的长度，即在执行反向方法之前字符串缓冲区中包含的字符序列。</li><li>新字符序列中索引k处的字符等于旧字符序列中索引n-k-1处的字符</li></ol><a id="more"></a><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String soure<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String target <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//字符串拆分成数组</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> soure<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 利用StringBuffer.reverse() 将字符逆序</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> temp<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                target <span class="token operator">=</span> target <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                target <span class="token operator">=</span> target <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="二-利用数组双指针思想"><a href="#二-利用数组双指针思想" class="headerlink" title="二 . 利用数组双指针思想"></a>二 . 利用数组双指针思想</h3><ol><li>划分子数组</li><li>子数组双指针交换；</li><li>生成字符串</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将字符串转化为数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">char</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                    l<span class="token operator">++</span><span class="token punctuation">;</span>                    r<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                r <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            l<span class="token operator">++</span><span class="token punctuation">;</span>            r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>两次的执行结果</p></blockquote><p><img src="http://ptyodd4up.bkt.clouddn.com/leecode712.png" alt="执行结果比较" title="执行结果比较.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
