<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构:链表</title>
      <link href="/2019/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构:链表"></a>数据结构:链表</h2><p>链表是数据结构之一，其中的数据呈现线性排列。在链表中，数据的添加和删除较为方便，就是访问比较耗时</p><p><img src="/medias/article/images/2019/7/22/2.png" alt><br>这是链表的概念图。Bule、Yellow、Red这3个字符串作为数据被存储在链表中。每个数据都有1个“指针”，它指向下一个数据的内存地址<br><img src="/medias/article/images/2019/7/22/3.png" alt><br>在链表中，数据一般都是分散存储内存中的，无需存储在连续空间内<br><img src="/medias/article/images/2019/7/22/4.jpg" alt><br>因为数据都是分散存储的，所以想要访问数据，只能从第一个数据开始，顺着指针的指向一一往下访问(这边是顺序访问)。比如想要找到Red着一数据，就得从Blue开始访问<br><br>这之后，要经过Yellow,我们才能找到Red<br><br>如果想要添加数据，只需要改变添加位置前后的指针指向就可以了，比如，在Blue和Yellow之间添加Green<br><br><img src="/medias/article/images/2019/7/22/5.jpg" alt><br>将Blue的指针指向位置变成Green,然后把Green的指针指向Yellow<br><img src="/medias/article/images/2019/7/22/6.jpg" alt><br>数据的删除也一样，只要改变指针的指向就可以，比如删除Yello<br><img src="/medias/article/images/2019/7/22/6.jpg" alt><br>这时候，只需要把Green指针指向的位置从Yellow变成Red,删除就完成了，虽然Yellow本身还存在内存中，但是不管从哪里都无法访问这个数据，所以也就没特意去删除的必要<br><img src="/medias/article/images/2019/7/22/7.jpg" alt></p><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><ul><li>对链表的操作所需的运行时间到底是对少呢？我们把链表中的数据量记为n,访问数据时，访问数据时，需要从链表头部开始(线性查找)，如果目标数据在链表最后的话，需要的时间就是O(n).</li><li>另外，添加数据只需要更改两个指针的指向，所以耗时的时间与n无关。如果已经达到添加数据的位置，那么添加操作只需要花费0(1)的时间。删除数据同样也只需O(1)的时间</li></ul><h3 id="2-补充说明"><a href="#2-补充说明" class="headerlink" title="2. 补充说明"></a>2. 补充说明</h3><p>  上述模型链表是最基本的一中链表。除此之外还有还存在几种拓展方便的链表。</p><ul><li>案例中，如果我们在链表尾部使用指针，并且让它指向链表头部的数据，将链表变成环形。这便是”循环链表”,也叫”环形链表”.“循环链表”没有头部和尾部的概念，<code>要想保存数据固定和最新数据时候通常会使用这种链表</code><br><img src="/medias/article/images/2019/7/22/8.jpg" alt></li><li>另外上面提到的链表都只有一个指针，我们可以把指针设定为两个，并让他们分别指向前后数据，这就是“双向链表”，使用这种链表不仅仅可以从前往后，还可以从后往前遍历数据，十分方便<br><img src="/medias/article/images/2019/7/22/9.jpg" alt></li></ul><p>但是双向链表存在两个缺点：</p><ol><li>指针数会导致存储空间的需求增加</li><li>添加或删除时需要改变更多的指针的指向</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中SPI机制</title>
      <link href="/2019/07/20/SpringBoot%E4%B8%ADSPI%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/20/SpringBoot%E4%B8%ADSPI%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot中SPI机制"><a href="#SpringBoot中SPI机制" class="headerlink" title="SpringBoot中SPI机制"></a>SpringBoot中SPI机制</h2><h3 id="一、从java类加载机制说起"><a href="#一、从java类加载机制说起" class="headerlink" title="一、从java类加载机制说起"></a>一、从java类加载机制说起</h3><p>java中的类加载器负载加载来自文件系统、网络或者其他来源的类文件。<code>jvm</code>的类加载器默认使用的是双亲委派模式。三种默认的类加载器<code>Bootstrap ClassLoader</code>、<code>Extension ClassLoader</code>和<code>System ClassLoader（Application ClassLoader）</code>每一个中类加载器都确定了从哪一些位置加载文件。于此同时我们也可以通过继承<code>java.lang.classloader</code>实现自己的类加载器</p><ol><li><code>Bootstrap ClassLoader</code>：负责加载JDK自带的<code>rt.jar</code>包中的类文件，是所有类加载的父类 </li><li><code>Extension ClassLoader</code>：负责加载java的扩展类库从<code>jre/lib/ect</code>目录或者<code>java.ext.dirs</code>系统属性指定的目录下加载类，是<code>System ClassLoader</code>的父类加载器 </li><li><code>System ClassLoader</code>：负责从<code>classpath</code>环境变量中加载类文件</li></ol><p><img src="/medias/article/images/2019/7/20/1.png" alt="java类加载结构"></p><h4 id="1-双亲委派模型"><a href="#1-双亲委派模型" class="headerlink" title="1.双亲委派模型"></a>1.双亲委派模型</h4><p>原理：当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的<code>BootstrapClassLoader</code>，只有当父加载器无法完成加载任务时，才会尝试自己来加载</p><p>具体：根据双亲委派模式，在加载类文件的时候，子类加载器首先将加载请求委托给它的父加载器，父加载器会检测自己是否已经加载过类，如果已经加载则加载过程结束，如果没有加载的话则请求继续向上传递直<code>Bootstrap ClassLoader</code>。如果请求向上委托过程中，如果始终没有检测到该类已经加载，则Bootstrap ClassLoader开始尝试从其对应路劲中加载该类文件，如果失败则由子类加载器继续尝试加载，直至发起加载请求的子加载器为止</p><p>采用双亲委派模式可以保证类型加载的安全性，不管是哪个加载器加载这个类，最终都是委托给顶层的<code>BootstrapClassLoader</code>来加载的，只有父类无法加载自己猜尝试加载，这样就可以保证任何的类加载器最终得到的都是同样一个Object对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，检查该类是否已经被加载，如果从JVM缓存中找到该类，则直接返回</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 遵循双亲委派的模型，首先会通过递归从父加载器开始找，</span>            <span class="token comment" spellcheck="true">// 直到父类加载器是BootstrapClassLoader为止</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果还找不到，尝试通过findClass方法去寻找</span>            <span class="token comment" spellcheck="true">// findClass是留给开发者自己实现的，也就是说</span>            <span class="token comment" spellcheck="true">// 自定义类加载器时，重写此方法即可</span>           c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-双亲委派模型缺陷"><a href="#2-双亲委派模型缺陷" class="headerlink" title="2.双亲委派模型缺陷"></a>2.双亲委派模型缺陷</h4><ul><li>在双亲委派模型中，子类加载器可以使用父类加载器已经加载的类，而父类加载器无法使用子类加载器已经加载的。这就导致了双亲委派模型并不能解决所有的类加载器问题。</li></ul><p>案例：<br><code>Java 提供了很多服务提供者接口(Service Provider Interface，SPI)，允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JNDI、JAXP 等，这些SPI的接口由核心类库提供，却由第三方实现，这样就存在一个问题：SPI 的接口是 Java 核心库的一部分，是由BootstrapClassLoader加载的；SPI实现的Java类一般是由AppClassLoader来加载的。BootstrapClassLoader是无法找到 SPI 的实现类的，因为它只加载Java的核心库。它也不能代理给AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题</code></p><h4 id="3-使用线程上下文类加载器加载"><a href="#3-使用线程上下文类加载器加载" class="headerlink" title="3.使用线程上下文类加载器加载"></a>3.使用线程上下文类加载器加载</h4><ul><li>如果不做任何的设置，Java应用的线程的上下文类加载器默认就是<code>AppClassLoader</code>。在核心类库使用SPI接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到SPI实现的类。线程上下文类加载器在很多SPI的实现中都会用到</li><li>通常我们可以通过<code>Thread.currentThread().getClassLoader()</code>和<code>Thread.currentThread().getContextClassLoader()</code>获取线程上下文类加载器</li></ul><h4 id="4-使用类加载器加载资源文件，比如jar包"><a href="#4-使用类加载器加载资源文件，比如jar包" class="headerlink" title="4.使用类加载器加载资源文件，比如jar包"></a>4.使用类加载器加载资源文件，比如jar包</h4><p>类加载器除了加载<code>class</code>外，还有一个非常重要功能，就是加载资源，它可以从jar包中读取任何资源文件，比如，<code>ClassLoader.getResources(String name)</code>方法就是用于读取jar包中的资源文件</p><h3 id="二、spring中SPI机制实现"><a href="#二、spring中SPI机制实现" class="headerlink" title="二、spring中SPI机制实现"></a>二、spring中SPI机制实现</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取资源的方法</span><span class="token keyword">public</span> Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> <span class="token function">getResources</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span>Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Enumeration</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getBootstrapResources</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">findResources</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CompoundEnumeration</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到<code>BootstrapClassLoader</code>，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的jar包，就如同加载class一样，最后会扫描所有的jar包，找到符合条件的资源文件。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用线程上下文类加载器加载资源</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Array.class的完整路径</span>    String name <span class="token operator">=</span> <span class="token string">"java/sql/Array.class"</span><span class="token punctuation">;</span>    Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> urls <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        URL url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1-SPI机制"><a href="#1-SPI机制" class="headerlink" title="1.SPI机制"></a>1.SPI机制</h4><p><strong>(SPI思想)</strong></p><ul><li>SPI的全名为<code>Service Provider Interface</code>.这个是针对厂商或者插件的</li><li>SPI的思想：系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<strong>java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制</strong></li></ul><p><strong>(2)SPI约定</strong></p><ul><li>当服务的提供者，提供了服务接口的一种实现之后，在jar包的<code>META-INF/services/</code>目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。通过这个约定，就不需要把服务放在代码中了，通过模块被装配的时候就可以发现服务类了</li></ul><h4 id="2-SPI使用案例"><a href="#2-SPI使用案例" class="headerlink" title="2.SPI使用案例"></a>2.SPI使用案例</h4><p><code>common-logging</code> apache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现， 发现日志提供商是通过扫描 META-INF/services/org.apache.commons.logging.LogFactory配置文件，通过读取该文件的内容找到日志提工商实现类。只要我们的日志实现里包含了这个文件，并在文件里制定 LogFactory工厂接口的实现类即可</p><h4 id="3-Springboot中的类SPI扩展机制"><a href="#3-Springboot中的类SPI扩展机制" class="headerlink" title="3.Springboot中的类SPI扩展机制"></a>3.Springboot中的类SPI扩展机制</h4><ul><li>在<code>springboot</code>的自动装配过程中，最终会加载<code>META-INF/spring.factories</code>文件，而加载的过程是由<code>SpringFactoriesLoader</code>加载的。从CLASSPATH下的每个Jar包中搜寻所有META-INF/spring.factories配置文件，然后将解析<code>properties</code>文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在<code>Classpath</code>下的jar包中<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String FACTORIES_RESOURCE_LOCATION <span class="token operator">=</span> <span class="token string">"META-INF/spring.factories"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// spring.factories文件的格式为：key=value1,value2,value3</span><span class="token comment" spellcheck="true">// 从所有的jar包中找到META-INF/spring.factories文件</span><span class="token comment" spellcheck="true">// 然后从文件中解析出key=factoryClass类名称的所有value值</span><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factoryClass<span class="token punctuation">,</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>  String factoryClassName <span class="token operator">=</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 取得资源文件的URL</span>  Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> urls <span class="token operator">=</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> null <span class="token operator">?</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span> <span class="token operator">:</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 遍历所有的URL</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      URL url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span>      Properties properties <span class="token operator">=</span> PropertiesLoaderUtils<span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String factoryClassNames <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>factoryClassName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 组装数据，并返回</span>      result<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span>factoryClassNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性及使用(二)</title>
      <link href="/2019/07/17/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8-%E4%BA%8C/"/>
      <url>/2019/07/17/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>扩展注解的支持</li><li>Base64</li><li>JavaFX</li><li>其它<ul><li>JDBC4.2规范</li><li>更好的类型推测机制</li><li>HashMap性能提升</li><li>IO/NIO 的改进</li><li>JavaScript引擎Nashorn</li><li>并发（Concurrency）</li><li>类依赖分析器jdeps</li><li>JVM的PermGen空间被移除</li></ul></li></ul><h3 id="扩展注解的支持"><a href="#扩展注解的支持" class="headerlink" title="扩展注解的支持"></a>扩展注解的支持</h3><p> Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>  <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Annotations</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>      <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_PARAMETER <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">NonEmpty</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token annotation punctuation">@NonEmpty</span> Object <span class="token punctuation">{</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@NonEmpty</span> Exception <span class="token punctuation">{</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">final</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NonEmpty</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token annotation punctuation">@NonEmpty</span> Collection<span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p> 在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>StandardCharsets<span class="token punctuation">;</span> <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Base64<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base64s</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">final</span> String text <span class="token operator">=</span> <span class="token string">"Base64 finally in Java 8!"</span><span class="token punctuation">;</span>         <span class="token keyword">final</span> String encoded <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">final</span> String decoded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p> 程序在控制台上输出了编码后的字符与解码后的字符：</p><pre><code>  QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==  Base64 finally in Java 8!</code></pre><p> <code>Base64</code>类同时还提供了对<code>URL</code>、<code>MIME</code>友好的编码器与解码器（<code>Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder()</code>）。</p><h3 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h3><p> JavaFX是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考JavaFX中文文档。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="1-JDBC4-2规范"><a href="#1-JDBC4-2规范" class="headerlink" title="1. JDBC4.2规范"></a>1. JDBC4.2规范</h4><p> JDBC4.2主要有以下几点改动：</p><ul><li><p>增加了对<code>REF Cursor</code>的支持</p></li><li><p>修改返回值大小范围（<code>update count</code>）</p></li><li><p>增加了<code>java.sql.DriverAction</code>接口</p></li><li><p>增加了<code>java.sql.SQLType</code>接口</p></li><li><p>增加了<code>java.sql.JDBCtype</code>枚举</p></li><li><p>对<code>java.time</code>包时间类型的支持</p><h4 id="2-更好的类型推测机制"><a href="#2-更好的类型推测机制" class="headerlink" title="2. 更好的类型推测机制"></a>2. 更好的类型推测机制</h4><p>Java 8在类型推测方面有了很大的提高。在很多情况下，编译器可以推测出确定的参数类型，这样就能使代码更整洁。让我们看一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> null<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> T <span class="token function">getOrDefault</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> T defaultValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> value <span class="token operator">:</span> defaultValue<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里是Value<string>类型的用法。</string></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TypeInference</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> Value<span class="token operator">&lt;</span>String<span class="token operator">></span> value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       value<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token string">"22"</span><span class="token punctuation">,</span> Value<span class="token punctuation">.</span><span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Value.defaultValue()</code>的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是<code>Value.&lt;String&gt;defaultValue()</code>。</p></li></ul><h4 id="3-HashMap性能提升"><a href="#3-HashMap性能提升" class="headerlink" title="3. HashMap性能提升"></a>3. HashMap性能提升</h4><p> Java8中，HashMap内部实现又引入了红黑树，使得HashMap的总体性能相较于Java7有比较明显的提升。以下是对Hash均匀和不均匀的情况下的性能对比</p><h5 id="1-Hash较均匀的情况"><a href="#1-Hash较均匀的情况" class="headerlink" title="(1). Hash较均匀的情况"></a>(1). Hash较均匀的情况</h5><p> Hash较均匀时的性能对比<br> Hash较均匀时的性能对比</p><h5 id="2-Hash极不均匀的情况"><a href="#2-Hash极不均匀的情况" class="headerlink" title="(2). Hash极不均匀的情况"></a>(2). Hash极不均匀的情况</h5><p> Hash极不均匀时的性能对比<br> Hash极不均匀时的性能对比</p><h4 id="4-IO-NIO-的改进"><a href="#4-IO-NIO-的改进" class="headerlink" title="4. IO/NIO 的改进"></a>4. IO/NIO 的改进</h4><p> Java8 对IO/NIO也做了一些改进。主要包括：改进了<code>java.nio.charset.Charset</code>的实现，使编码和解码的效率得以提升，也精简了<code>jre/lib/charsets.jar</code>包；优化了<code>String(byte[], *)</code>构造方法和<code>String.getBytes()</code>方法的性能；还增加了一些新的<code>IO/NIO</code>方法，使用这些方法可以从文件或者输入流中获取流（<code>java.util.stream.Stream</code>），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。</p><p> 新增的 API 如下：</p><ul><li><p><code>BufferedReader.line()</code>: 返回文本行的流Stream<string></string></p></li><li><p><code>File.lines(Path, Charset)</code>: 返回文本行的流Stream<string></string></p></li><li><p><code>File.list(Path)</code>: 遍历当前目录下的文件和目录</p></li><li><p><code>File.walk(Path, int, FileVisitOption)</code>: 遍历某一个目录下的所有文件和指定深度的子目录</p></li><li><p><code>File.find(Path, int, BiPredicate, FileVisitOption...)</code>: 查找相应的文件</p><p>下面就是用流式操作列出当前目录下的所有文件和目录：</p><pre class=" language-java"><code class="language-java">Files<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="5-JavaScript引擎Nashorn"><a href="#5-JavaScript引擎Nashorn" class="headerlink" title="5. JavaScript引擎Nashorn"></a>5. JavaScript引擎Nashorn</h4><p>Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。<code>Nashorn javascript</code>引擎只是<code>javax.script.ScriptEngine</code>另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子：</p><pre class=" language-java"><code class="language-java">ScriptEngineManager manager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ScriptEngine engine <span class="token operator">=</span> manager<span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>engine<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result:"</span> <span class="token operator">+</span> engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"function f(){return 1;}; f() + 1;"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出如下：</p><pre class=" language-java"><code class="language-java">jdk<span class="token punctuation">.</span>nashorn<span class="token punctuation">.</span>api<span class="token punctuation">.</span>scripting<span class="token punctuation">.</span>NashornScriptEngineResult<span class="token operator">:</span> <span class="token number">2</span></code></pre></li></ul><h4 id="6-并发（Concurrency）"><a href="#6-并发（Concurrency）" class="headerlink" title="6. 并发（Concurrency）"></a>6. 并发（Concurrency）</h4><p> 在新增Stream机制与Lambda的基础之上，在<code>java.util.concurrent.ConcurrentHashMap</code>中加入了一些新方法来支持聚集操作。同时也在<code>java.util.concurrent.ForkJoinPool</code>类中加入了一些新方法来支持共有资源池（<code>common pool</code>）（请查看我们关于Java 并发的免费课程）。</p><p> 新增的<code>java.util.concurrent.locks.StampedLock</code>类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的<code>java.util.concurrent.locks.ReadWriteLock</code>类的替代者）。</p><p> 在<code>java.util.concurrent.atomic</code>包中还增加了下面这些类：</p><ul><li><p>DoubleAccumulator</p></li><li><p>DoubleAdder</p></li><li><p>LongAccumulator</p></li><li><p>LongAdder</p><h4 id="7-类依赖分析器jdeps"><a href="#7-类依赖分析器jdeps" class="headerlink" title="7. 类依赖分析器jdeps"></a>7. 类依赖分析器jdeps</h4><p>Jdeps是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，jdeps会输出到控制台。</p><p>作为例子，让我们看看现在很流行的Spring框架的库的依赖关系报告。为了让报告短一些，我们只分析一个<code>jar: org.springframework.core-3.0.5.RELEASE.jar</code>.</p><p><code>jdeps org.springframework.core-3.0.5.RELEASE.jar</code>这个命令输出内容很多，我们只看其中的一部分，这些依赖关系根绝包来分组，如果依赖关系在classpath里找不到，就会显示not found.</p><pre class=" language-java"><code class="language-java">C<span class="token operator">:</span>\Program Files\Java\jdk1<span class="token number">.8</span><span class="token punctuation">.</span><span class="token number">0</span>\jre\lib\rt<span class="token punctuation">.</span>jar org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span><span class="token function">core</span> <span class="token punctuation">(</span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">)</span>    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>io    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>util    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent    <span class="token operator">-</span><span class="token operator">></span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>logging                         not found    <span class="token operator">-</span><span class="token operator">></span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>asm                            not found    <span class="token operator">-</span><span class="token operator">></span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>asm<span class="token punctuation">.</span>commons                    not found org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span><span class="token function">annotation</span> <span class="token punctuation">(</span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">)</span>    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect    <span class="token operator">-</span><span class="token operator">></span> java<span class="token punctuation">.</span>util</code></pre><h5 id="8-JVM的PermGen空间被移除"><a href="#8-JVM的PermGen空间被移除" class="headerlink" title="8. JVM的PermGen空间被移除"></a>8. JVM的PermGen空间被移除</h5><p><code>PermGen</code>空间被移除了，取而代之的是<code>Metaspace（JEP 122）</code>。JVM选项<code>-XX:PermSize</code>与<code>-XX:MaxPermSize</code>分别被<code>-XX:MetaSpaceSize</code>与<code>-XX:MaxMetaspaceSize</code>所代替。</p><p>参考文档：<br><a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">What’s New in JDK 8</a><br><a href="http://www.importnew.com/11908.html" target="_blank" rel="noopener">Java 8新特性终极指南</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性及使用(一)</title>
      <link href="/2019/07/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8-%E4%B8%80/"/>
      <url>/2019/07/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>接口默认方法和静态方法</li><li>Lambda 表达式</li><li>函数式接口</li><li>方法引用</li><li>Stream</li><li>Optional</li><li>Date/Time API</li><li>重复注解</li></ul><h2 id="一、接口默认方法和静态方法"><a href="#一、接口默认方法和静态方法" class="headerlink" title="一、接口默认方法和静态方法"></a>一、接口默认方法和静态方法</h2><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p><h3 id="1-接口默认方法"><a href="#1-接口默认方法" class="headerlink" title="1. 接口默认方法"></a>1. 接口默认方法</h3><p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or</span>    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Defaulable</code>接口用关键字<code>default</code>声明了一个默认方法<code>notRequired()</code>，<code>Defaulable</code>接口的实现者之一<code>DefaultableImpl</code>实现了这个接口，并且让默认方法保持原样。<code>Defaulable</code>接口的另一个实现者<code>OverridableImpl</code>用自己的方法覆盖了默认方法。</p><h4 id="1-多重继承的冲突说明"><a href="#1-多重继承的冲突说明" class="headerlink" title="(1). 多重继承的冲突说明"></a>(1). 多重继承的冲突说明</h4><p>由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下：</p><p>一个声明在类里面的方法优先于任何默认方法<br>优先选取最具体的实现<br>public interface A {</p><pre><code>default void hello() {    System.out.println(&quot;Hello A&quot;);}</code></pre><p>}public interface B extends A {</p><pre><code>default void hello() {    System.out.println(&quot;Hello B&quot;);}</code></pre><p>}public class C implements A, B {</p><pre><code>public static void main(String[] args) {    new C().hello(); // 输出 Hello B}</code></pre><p>}</p><h4 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="(2). 优缺点"></a>(2). 优缺点</h4><ul><li>优点: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</li><li>缺点: 使得接口作为协议，类作为具体实现的界限开始变得有点模糊。<h4 id="3-接口默认方法不能重载Object类的任何方法"><a href="#3-接口默认方法不能重载Object类的任何方法" class="headerlink" title="(3). 接口默认方法不能重载Object类的任何方法"></a>(3). 接口默认方法不能重载Object类的任何方法</h4>接口不能提供对<code>Object</code>类的任何方法的默认实现。简单地讲，每一个<code>java</code>类都是<code>Object</code>的子类，也都继承了它类中的<code>equals()/hashCode()/toString()</code>方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。</li></ul><p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到<code>java.util.Collection</code>接口中去：<code>stream()，parallelStream()</code>，<code>forEach()</code>，<code>removeIf()</code>等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。</p><h3 id="2-接口静态方法"><a href="#2-接口静态方法" class="headerlink" title="2. 接口静态方法"></a>2. 接口静态方法</h3><p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用<code>static</code>关键字，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StaticInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是Java8接口中的静态方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面的一小段代码是上面静态方法的使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StaticInterface<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 这是Java8接口中的静态方法!</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Java</code>支持一个实现类可以实现多个接口，如果多个接口中存在同样的<code>static</code>方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。</p><h2 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h2><p><code>Lambda</code>表达式（也称为闭包）是整个<code>Java 8</code>发行版中最受期待的在<code>Java</code>语言层面上的改变，<code>Lambda</code>允许把函数作为一个方法的参数（即：行为参数化，函数作为参数传递进方法中）。</p><p>一个<code>Lambda</code>可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。</p><p>首先看看在老版本的Java中是如何排列字符串的：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">,</span> <span class="token string">"anna"</span><span class="token punctuation">,</span> <span class="token string">"mike"</span><span class="token punctuation">,</span> <span class="token string">"xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>只需要给静态方法<code>Collections.sort</code>传入一个<code>List</code>对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给<code>sort</code>方法。<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于函数体只有一行代码的，你可以去掉大括号{}以及<code>return</code>关键字，但是你还可以写得更短点：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p><code>Lambda</code>表达式是如何在Java的类型系统中表示的呢？每一个<code>Lambda</code>表达式都对应一个类型，通常是接口类型。而函数式接口是指仅仅只包含一个抽象方法的接口，每一个该类型的<code>Lambda</code>表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将<code>Lambda</code>表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加<code>@FunctionalInterface</code>注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><p>示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>F<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    T <span class="token function">convert</span><span class="token punctuation">(</span>F from<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> converter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>Integer converted <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><p>注：如果<code>@FunctionalInterface</code>如果没有指定，上面的代码也是对的。</p><p><code>Java8 API</code>包含了很多内建的函数式接口，在老<code>Java</code>中常用到的比如<code>Comparator</code>或者<code>Runnable</code>接口，这些接口都增加了<code>@FunctionalInterface</code>注解以便能用在<code>Lambda</code>上。</p><p><code>Java8 API</code>同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自<code>Google Guava</code>库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到<code>lambda</code>上使用的。</p><h3 id="1-Comparator-比较器接口"><a href="#1-Comparator-比较器接口" class="headerlink" title="1. Comparator (比较器接口)"></a>1. Comparator (比较器接口)</h3><p><code>Comparator</code>是老<code>Java</code>中的经典接口， <code>Java 8</code>在此之上添加了多种默认方法。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>T o1<span class="token punctuation">,</span> T o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Comparator<span class="token operator">&lt;</span>Person<span class="token operator">></span> comparator <span class="token operator">=</span> <span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> p1<span class="token punctuation">.</span>firstName<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>Person p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Doe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Person p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token string">"Wonderland"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// > 0</span>comparator<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// &lt; 0</span></code></pre><h3 id="2-Consumer-消费型接口"><a href="#2-Consumer-消费型接口" class="headerlink" title="2. Consumer (消费型接口)"></a>2. Consumer (消费型接口)</h3><p><code>Consumer</code>接口表示执行在单个参数上的操作。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Consumer<span class="token operator">&lt;</span>Person<span class="token operator">></span> greeter <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>greeter<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Luke"</span><span class="token punctuation">,</span> <span class="token string">"Skywalker"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>更多的Consumer接口<br><code>BiConsumer：void accept(T t, U u);</code>: 接受两个参数的二元函数<br><code>DoubleConsumer：void accept(double value);</code>: 接受一个double参数的一元函数<br><code>IntConsumer：void accept(int value);</code>: 接受一个int参数的一元函数<br><code>LongConsumer：void accept(long value);</code>: 接受一个long参数的一元函数<br><code>ObjDoubleConsumer：void accept(T t, double value);</code>: 接受一个泛型参数一个double参数的二元函数<br><code>ObjIntConsumer：void accept(T t, int value);</code>: 接受一个泛型参数一个int参数的二元函数<br><code>ObjLongConsumer：void accept(T t, long value);</code>: 接受一个泛型参数一个long参数的二元函数</p><h3 id="3-Supplier-供应型接口"><a href="#3-Supplier-供应型接口" class="headerlink" title="3. Supplier (供应型接口)"></a>3. Supplier (供应型接口)</h3><p><code>Supplier</code>接口是不需要参数并返回一个任意范型的值。其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同<code>Consumer</code>相反，是一个只声明了返回值，不需要参数的函数。也就是说<code>Supplier</code>其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力，因为我们常见的场景中不止是要<code>consume（Consumer）</code>或者是简单的<code>map（Function）</code>，还包括了new这个动作。而<code>Supplier</code>就表达了这种能力。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Supplier<span class="token operator">&lt;</span>Person<span class="token operator">></span> personSupplier <span class="token operator">=</span> Person<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">;</span>personSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// new Person</span></code></pre><p>更多Supplier接口<br><code>BooleanSupplier：boolean getAsBoolean();</code>: 返回boolean的无参函数<br><code>DoubleSupplier：double getAsDouble();</code>: 返回double的无参函数<br><code>IntSupplier：int getAsInt();</code>: 返回int的无参函数<br><code>LongSupplier：long getAsLong();</code>: 返回long的无参函数</p><h3 id="4-Predicate-断言型接口"><a href="#4-Predicate-断言型接口" class="headerlink" title="4. Predicate (断言型接口)"></a>4. Predicate (断言型接口)</h3><p><code>Predicate</code>接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将<code>Predicate</code>组合成其他复杂的逻辑（比如：与，或，非）。<code>Stream</code>的<code>filter</code>方法就是接受Predicate作为入参的。这个具体在后面使用Stream的时候再分析深入。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>predicate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// true</span>predicate<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// false</span>Predicate<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> nonNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>nonNull<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> isNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>isNull<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isEmpty <span class="token operator">=</span> String<span class="token operator">:</span><span class="token operator">:</span>isEmpty<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isNotEmpty <span class="token operator">=</span> isEmpty<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>更多的Predicate接口<br><code>BiPredicate：boolean test(T t, U u);</code>: 接受两个参数的二元断言函数<br><code>DoublePredicate：boolean test(double value);</code>: 入参为double的断言函数<br><code>IntPredicate：boolean test(int value);</code>: 入参为int的断言函数<br><code>LongPredicate：boolean test(long value);</code>: 入参为long的断言函数</p><h4 id="5-Function-功能型接口"><a href="#5-Function-功能型接口" class="headerlink" title="5. Function (功能型接口)"></a>5. Function (功能型接口)</h4><p><code>Function</code>接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法<code>（compose, andThen）</code>。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> <span class="token punctuation">{</span>    R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> toInteger <span class="token operator">=</span> Integer<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">;</span>Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> backToString <span class="token operator">=</span> toInteger<span class="token punctuation">.</span><span class="token function">andThen</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">)</span><span class="token punctuation">;</span>backToString<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "123"</span></code></pre><p>更多的Function接口<br><code>BiFunction ：R apply(T t, U u);</code>: 接受两个参数，返回一个值，代表一个二元函数；<br><code>DoubleFunction ：R apply(double value);</code>: 只处理double类型的一元函数；<br><code>IntFunction ：R apply(int value);</code>: 只处理int参数的一元函数；<br><code>LongFunction ：R apply(long value);</code>: 只处理long参数的一元函数；<br><code>ToDoubleFunction：double applyAsDouble(T value);</code>: 返回double的一元函数；<br><code>ToDoubleBiFunction：double applyAsDouble(T t, U u);</code>: 返回double的二元函数；<br><code>ToIntFunction：int applyAsInt(T value);</code>: 返回int的一元函数；<br><code>ToIntBiFunction：int applyAsInt(T t, U u);</code>: 返回int的二元函数；<br><code>ToLongFunction：long applyAsLong(T value);</code>: 返回long的一元函数；<br><code>ToLongBiFunction：long applyAsLong(T t, U u);</code>: 返回long的二元函数；<br><code>DoubleToIntFunction：int applyAsInt(double value);</code>: 接受double返回int的一元函数；<br><code>DoubleToLongFunction：long applyAsLong(double value);</code>: 接受double返回long的一元函数；<br><code>IntToDoubleFunction：double applyAsDouble(int value);</code>: 接受int返回double的一元函数；<br><code>IntToLongFunction：long applyAsLong(int value);</code>: 接受int返回long的一元函数；<br><code>LongToDoubleFunction：double applyAsDouble(long value);</code>: 接受long返回double的一元函数；<br><code>LongToIntFunction：int applyAsInt(long value);</code>: 接受long返回int的一元函数；</p><h3 id="6-Operator"><a href="#6-Operator" class="headerlink" title="6. Operator"></a>6. Operator</h3><p><code>Operator</code>其实就是<code>Function</code>，函数有时候也叫作算子。算子在<code>Java8</code>中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。算子<code>Operator</code>包括：<code>UnaryOperator</code>和<code>BinaryOperator</code>。分别对应单（一）元算子和二元算子。</p><p>算子的接口声明如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UnaryOperator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> UnaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t <span class="token operator">-</span><span class="token operator">></span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BinaryOperator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">BiFunction</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token punctuation">,</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">minBy</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">maxBy</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Operator只需声明一个泛型参数T即可。对应的使用示例如下：</p><pre class=" language-java"><code class="language-java">UnaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> increment <span class="token operator">=</span> x <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"递增:"</span> <span class="token operator">+</span> increment<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 递增:3</span>BinaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> add <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"相加:"</span> <span class="token operator">+</span> add<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 相加:5</span>BinaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> min <span class="token operator">=</span> BinaryOperator<span class="token punctuation">.</span><span class="token function">minBy</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> o1 <span class="token operator">-</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最小值:"</span> <span class="token operator">+</span> min<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 最小值:2</span></code></pre><h4 id="更多的Operator接口"><a href="#更多的Operator接口" class="headerlink" title="更多的Operator接口"></a>更多的Operator接口</h4><ul><li><code>LongUnaryOperator：long applyAsLong(long operand);</code>: 对long类型做操作的一元算子</li><li><code>IntUnaryOperator：int applyAsInt(int operand);</code>: 对int类型做操作的一元算子</li><li><code>DoubleUnaryOperator：double applyAsDouble(double operand);</code>: 对double类型做操作的一元算子</li><li><code>DoubleBinaryOperator：double applyAsDouble(double left, double right);</code>: 对double类型做操作的二元算子</li><li><code>IntBinaryOperator：int applyAsInt(int left, int right);</code>: 对int类型做操作的二元算子</li><li><code>LongBinaryOperator：long applyAsLong(long left, long right);</code>: 对long类型做操作的二元算子</li></ul><h3 id="7-其它函数式接口"><a href="#7-其它函数式接口" class="headerlink" title="7.其它函数式接口"></a>7.其它函数式接口</h3><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher</li><li>java.lang.reflect.InvocationHandler</li><li>java.beans.PropertyChangeListener</li><li>java.awt.event.ActionListener</li><li>javax.swing.event.ChangeListener</li></ul><h2 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在学习了<code>Lambda</code>表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在<code>Java8</code>中，我们可以直接通过方法引用来简写<code>Lambda</code>表达式中已经存在的方法。</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种特性就叫做方法引用<code>(Method Reference)</code>。</p><p>方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p><p>注意: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号::。</p><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><p>方法引用的标准形式是：类名::方法名。（注意：只需要写方法名，不需要写括号）</p><p>有以下四种形式的方法引用：</p><ul><li>引用静态方法: <code>ContainingClass::staticMethodName</code></li><li>引用某个对象的实例方法: <code>containingObject::instanceMethodName</code></li><li>引用某个类型的任意对象的实例方法:<code>ContainingType::methodName</code></li><li>引用构造方法: <code>ClassName::new</code></li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    LocalDate birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> LocalDate birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> LocalDate <span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareByAge</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodReferenceTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Person<span class="token punctuation">[</span><span class="token punctuation">]</span> pArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用匿名类</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用lambda表达式</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用方法引用，引用的是类的静态方法</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> Person<span class="token operator">:</span><span class="token operator">:</span>compareByAge<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、Stream"><a href="#五、Stream" class="headerlink" title="五、Stream"></a>五、Stream</h2><p><code>Java8</code>添加的<code>Stream API(java.util.stream)</code>把真正的函数式编程风格引入到<code>Java</code>中。这是目前为止对<code>Java</code>类库最好的补充，因为<code>Stream API</code>可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括``filter、map、flatMap、peel、distinct、sorted、limit和substream<code>。终止操作包括</code>forEach、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst<code>和</code>findAny<code>。</code>java.util.stream.Collectors`是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。</p><h3 id="1-一些重要方法说明"><a href="#1-一些重要方法说明" class="headerlink" title="1. 一些重要方法说明"></a>1. 一些重要方法说明</h3><ul><li>stream: 返回数据流，集合作为其源</li><li>parallelStream: 返回并行数据流， 集合作为其源</li><li>filter: 方法用于过滤出满足条件的元素</li><li>map: 方法用于映射每个元素对应的结果</li><li>forEach: 方法遍历该流中的每个元素</li><li>limit: 方法用于减少流的大小</li><li>sorted: 方法用来对流中的元素进行排序</li><li>anyMatch: 是否存在任意一个元素满足条件（返回布尔值）</li><li>allMatch: 是否所有元素都满足条件（返回布尔值）</li><li>noneMatch: 是否所有元素都不满足条件（返回布尔值）</li><li>collect: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li></ul><h3 id="2-一些使用示例"><a href="#2-一些使用示例" class="headerlink" title="2. 一些使用示例"></a>2. 一些使用示例</h3><h4 id="1-Filter-过滤"><a href="#1-Filter-过滤" class="headerlink" title="(1). Filter 过滤"></a>(1). Filter 过滤</h4><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="2-Sort-排序"><a href="#2-Sort-排序" class="headerlink" title="(2). Sort 排序"></a>(2). Sort 排序</h4><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-Map-映射"><a href="#3-Map-映射" class="headerlink" title="(3). Map 映射"></a>(3). Map 映射</h4><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="4-Match-匹配"><a href="#4-Match-匹配" class="headerlink" title="(4). Match 匹配"></a>(4). Match 匹配</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> anyStartsWithA <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>anyStartsWithA<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// true</span><span class="token keyword">boolean</span> allStartsWithA <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>allStartsWithA<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// false</span><span class="token keyword">boolean</span> noneStartsWithZ <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>noneStartsWithZ<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// true</span></code></pre><h4 id="5-Count-计数"><a href="#5-Count-计数" class="headerlink" title="(5). Count 计数"></a>(5). Count 计数</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> startsWithB <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>startsWithB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3</span></code></pre><h4 id="6-Reduce-规约"><a href="#6-Reduce-规约" class="headerlink" title="(6). Reduce 规约"></a>(6). Reduce 规约</h4><p>这是一个最终操作，允许通过指定的函数来将stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的。代码如下:</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> reduced <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>reduced<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="六、Optional"><a href="#六、Optional" class="headerlink" title="六、Optional"></a>六、Optional</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，<code>Google</code>公司著名的<code>Guava</code>项目引入了<code>Optional</code>类，<code>Guava</code>通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到<code>Google Guava</code>的启发，<code>Optional</code>类已经成为<code>Java 8</code>类库的一部分。</p><p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果<code>Optional</code>类的实例为非空值的话，<code>isPresent()</code>返回true，否从返回false。为了防止<code>Optional</code>为空值，<code>orElseGet()</code>方法通过回调函数来产生一个默认值。map()函数对当前Optional的值进行转化，然后返回一个新的Optional实例。orElse()方法和orElseGet()方法类似，但是orElse接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p><pre><code>Full Name is set? falseFull Name: [none]Hey Stranger!</code></pre><p>让我们来看看另一个例子：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是程序的输出：</p><pre class=" language-java"><code class="language-java">First Name is set<span class="token operator">?</span> <span class="token boolean">true</span>First Name<span class="token operator">:</span> TomHey Tom<span class="token operator">!</span></code></pre><h2 id="七、Date-Time-API"><a href="#七、Date-Time-API" class="headerlink" title="七、Date/Time API"></a>七、Date/Time API</h2><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p><h3 id="1-Clock-时钟"><a href="#1-Clock-时钟" class="headerlink" title="1. Clock 时钟"></a>1. Clock 时钟</h3><p><code>Clock</code>类提供了访问当前日期和时间的方法，<code>Clock</code>是时区敏感的，可以用来取代<code>System.currentTimeMillis()</code>来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。代码如下:</p><pre class=" language-java"><code class="language-java">Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> millis <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Instant instant <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">instant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// legacy java.util.Date</span></code></pre><h3 id="2-Timezones-时区"><a href="#2-Timezones-时区" class="headerlink" title="2. Timezones 时区"></a>2. Timezones 时区</h3><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">getAvailableZoneIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// prints all available timezone ids</span>ZoneId zone1 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ZoneId zone2 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Brazil/East"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone1<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone2<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=+01:00]</span><span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=-03:00]</span></code></pre><h3 id="3-LocalTime-本地时间"><a href="#3-LocalTime-本地时间" class="headerlink" title="3. LocalTime 本地时间"></a>3. LocalTime 本地时间</h3><p>LocalTime定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下:</p><pre class=" language-java"><code class="language-java">LocalTime now1 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone1<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime now2 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>now2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token keyword">long</span> hoursBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> minutesBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hoursBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// -3</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minutesBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// -239</span>LocalTime提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下<span class="token operator">:</span>LocalTime late <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>late<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 23:59:59</span>DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofLocalizedTime</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>SHORT<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime leetTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"13:37"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetTime<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 13:37</span></code></pre><h3 id="4-LocalDate-本地日期"><a href="#4-LocalDate-本地日期" class="headerlink" title="4. LocalDate 本地日期"></a>4. LocalDate 本地日期</h3><p><code>LocalDate</code>表示了一个确切的日期，比如2014-03-11。该对象值是不可变的，用起来和<code>LocalTime</code>基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate tomorrow <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate yesterday <span class="token operator">=</span> tomorrow<span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate independenceDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>JULY<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DayOfWeek dayOfWeek <span class="token operator">=</span> independenceDay<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FRIDAY</span></code></pre><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下:</p><pre class=" language-java"><code class="language-java">DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofLocalizedDate</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate xmas <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"24.12.2014"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>xmas<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2014-12-24</span></code></pre><h3 id="5-LocalDateTime-本地日期时间"><a href="#5-LocalDateTime-本地日期时间" class="headerlink" title="5. LocalDateTime 本地日期时间"></a>5. LocalDateTime 本地日期时间</h3><p><code>LocalDateTime</code>同时表示了时间和日期，相当于前两节内容合并到一个对象上了。<code>LocalDateTime</code>和<code>LocalTime</code>还有<code>LocalDate</code>一样，都是不可变的。<code>LocalDateTime</code>提供了一些能访问具体字段的方法。代码如下:</p><pre class=" language-java"><code class="language-java">LocalDateTime sylvester <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DayOfWeek dayOfWeek <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// WEDNESDAY</span>Month month <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// DECEMBER</span><span class="token keyword">long</span> minuteOfDay <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>ChronoField<span class="token punctuation">.</span>MINUTE_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minuteOfDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1439</span></code></pre><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。代码如下:</p><pre class=" language-java"><code class="language-java">Instant instant <span class="token operator">=</span> sylvester        <span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>legacyDate<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Wed Dec 31 23:59:59 CET 2014</span></code></pre><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下:</p><pre class=" language-java"><code class="language-java">DateTimeFormatter formatter <span class="token operator">=</span>    DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd, yyyy - HH:mm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDateTime parsed <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"Nov 03, 2014 - 07:13"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>String string <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parsed<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Nov 03, 2014 - 07:13</span></code></pre><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。</p><p>关于<code>Java8</code>中日期API更多的使用示例可以参考<code>Java 8</code>中关于日期和时间API的20个使用示例。</p><h2 id="八、重复注解"><a href="#八、重复注解" class="headerlink" title="八、重复注解"></a>八、重复注解</h2><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。<code>Java 8</code>打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p><p>重复注解机制本身必须用<code>@Repeatable</code>注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Repeatable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RepeatingAnnotations</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filters</span> <span class="token punctuation">{</span>        Filter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Filters<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>        String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filterable</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Filter filter<span class="token operator">:</span> Filterable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Filter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>正如我们看到的，这里有个使用<code>@Repeatable(Filters.class)</code>注解的注解类<code>Filter</code>，<code>Filters</code>仅仅是<code>Filter</code>注解的数组，但<code>Java</code>编译器并不想让程序员意识到<code>Filters</code>的存在。这样，接口<code>Filterable</code>就拥有了两次<code>Filter</code>（并没有提到<code>Filter</code>）注解。</p><p>同时，反射相关的API提供了新的函数<code>getAnnotationsByType()</code>来返回重复注解的类型（请注意<code>Filterable.class.getAnnotation(Filters.class)</code>经编译器处理后将会返回<code>Filters</code>的实例）。</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中的@AliasFor标签</title>
      <link href="/2019/07/15/Spring%E4%B8%AD%E7%9A%84-AliasFor%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/07/15/Spring%E4%B8%AD%E7%9A%84-AliasFor%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring中的-AliasFor标签"><a href="#Spring中的-AliasFor标签" class="headerlink" title="Spring中的@AliasFor标签"></a>Spring中的@AliasFor标签</h2><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/aliasfor.png" alt><br>在<code>Spring</code>的众多注解中，经常会发现很多注解的不同属性起着相同的作用，比如<code>@RequestMapping</code>的<code>value</code>属性和<code>path</code>属性，这就需要做一些基本的限制，比如<code>value</code>和<code>path</code>的值不能冲突，比如任意设置<code>value</code>或者设置<code>path</code>属性的值，都能够通过另一个属性来获取值等等。为了统一处理这些情况，<code>Spring</code>创建了<code>@AliasFor</code>标签。</p><h3 id="1-1-AliasFor有几种使用方式"><a href="#1-1-AliasFor有几种使用方式" class="headerlink" title="1.1 @AliasFor有几种使用方式"></a>1.1 @AliasFor有几种使用方式</h3><h4 id="1-1-1在同一个注解内显示使用"><a href="#1-1-1在同一个注解内显示使用" class="headerlink" title="1.1.1在同一个注解内显示使用**"></a>1.1.1在同一个注解内显示使用**</h4><ul><li>比如在@RequestMapping中的使用示例：<br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/RequestMapping.png" alt></li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Mapping</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">RequestMapping</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><ul><li><p>又比如@ContextConfiguration注解中的value和locations属性:<br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/contextConfiguration.png" alt></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ContextConfiguration</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"locations"</span><span class="token punctuation">)</span>  String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>  String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">locations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre></li></ul><p>在同一个注解中成对使用即可，比如示例代码中，value和path就是互为别名。但是要注意一点，@AliasFor标签有一些使用限制，但是这应该能想到的，比如要求互为别名的属性属性值类型，默认值，都是相同的，互为别名的注解必须成对出现，比如value属性添加了@AliasFor(“path”)，那么path属性就必须添加@AliasFor(“value”)，另外还有一点，互为别名的属性必须定义默认值。</p><h4 id="1-1-2-显示的覆盖元注解中的属性"><a href="#1-1-2-显示的覆盖元注解中的属性" class="headerlink" title="1.1.2 显示的覆盖元注解中的属性"></a>1.1.2 显示的覆盖元注解中的属性</h4><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/contextConfiguration.png" alt></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringJUnit4ClassRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> AopConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopUtilsTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><p>这段代码是一个非常熟悉的基于<code>JavaConfig</code>的<code>Spring</code>测试代码；假如现在我有个癖好，我觉得每次写<code>@ContextConfiguration(classes = AopConfig.class)</code>太麻烦了，我想写得简单一点，我就可以定义一个这样的标签,使用我们的STC：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">STC</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"classes"</span><span class="token punctuation">,</span> annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">cs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>正常运行；<br>这就是<code>@AliasFor</code>标签的第二种用法，显示的为元注解中的属性起别名；这时候也有一些限制，比如属性类型，属性默认值必须相同；当然，在这种使用情况下，<code>@AliasFor</code>只能为作为当前注解的元注解起别名；</p><h4 id="1-1-3-在一个注解中隐式声明别名"><a href="#1-1-3-在一个注解中隐式声明别名" class="headerlink" title="1.1.3 在一个注解中隐式声明别名"></a>1.1.3 在一个注解中隐式声明别名</h4><p>这种使用方式和第二种使用方式比较相似，我们直接使用Spring官方文档的例子：</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@ContextConfiguration</span> <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MyTestConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"locations"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"locations"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">groovyScripts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"locations"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">xmlFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>可以看到，在<code>MyTestConfig</code>注解中，为<code>value</code>，<code>groovyScripts</code>，<code>xmlFiles</code>都定义了别名<code>@AliasFor(annotation = ContextConfiguration.class, attribute = “locations”)</code>，所以，其实在这个注解中，<code>value</code>、<code>groovyScripts</code>和<code>xmlFiles</code>也互为别名，这个就是所谓的在统一注解中的隐式别名方式；</p><h4 id="1-1-4-别名的传递"><a href="#1-1-4-别名的传递" class="headerlink" title="1.1.4 别名的传递"></a>1.1.4 别名的传递</h4><p>@AliasFor注解是允许别名之间的传递的，简单理解，如果A是B的别名，并且B是C的别名，那么A是C的别名；</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@MyTestConfig</span> <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">GroovyOrXmlTestConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> MyTestConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"groovyScripts"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">groovy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ContextConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"locations"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">xml</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ol><li>GroovyOrXmlTestConfig把 @MyTestConfig（参考上一个案例）作为元注解；</li><li>定义了groovy属性，并作为MyTestConfig中的groovyScripts属性的别名；</li><li>定义了xml属性，并作为ContextConfiguration中的locations属性的别名；</li><li>因为MyTestConfig中的groovyScripts属性本身就是ContextConfiguration中的locations属性的别名；所以xml属性和groovy属性也互为别名；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 内置容器优化</title>
      <link href="/2019/07/14/SpringBoot%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8undertow%E4%BC%98%E5%8C%96/"/>
      <url>/2019/07/14/SpringBoot%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8undertow%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot容器调整为-Undertow"><a href="#SpringBoot容器调整为-Undertow" class="headerlink" title="SpringBoot容器调整为 Undertow"></a>SpringBoot容器调整为 Undertow</h2><p><img src="http://undertow.io/images/undertow_banner.png" alt><br>Spring Boot内嵌容器支持Tomcat、Jetty、Undertow。为什么选择Undertow？</p><p>这里有一篇文章，时间 2017年1月26日发布的：</p><p><a href="https://examples.javacodegeeks.com/enterprise-java/spring/tomcat-vs-jetty-vs-undertow-comparison-of-spring-boot-embedded-servlet-containers/" target="_blank" rel="noopener">Tomcat vs. Jetty vs. Undertow: Comparison of Spring Boot Embedded Servlet Containers</a>.</p><p>这篇文章详细测试了Spring Boot应用在三种容器下的性能和内存使用，内含完整的测试代码和测试流程。证明了Undertow在性能和内存使用上是最好的。</p><p>在Spring Boot中使用 Undertow 而不是 Tomcat</p><h3 id="1-1-什么是-undertow"><a href="#1-1-什么是-undertow" class="headerlink" title="1.1 什么是 undertow?"></a>1.1 什么是 undertow?</h3><blockquote><p>Undertow 是一个采用 Java 开发的灵活的高性能 Web 服务器，提供包括阻塞和基于 NIO 的非堵塞机制。Undertow 是红帽公司的开源产品，是 Wildfly 默认的 Web 服务器。Undertow 提供一个基础的架构用来构建 Web 服务器，这是一个完全为嵌入式设计的项目，提供易用的构建器 API，完全兼容 Java EE Servlet 3.1 和低级非堵塞的处理器。</p></blockquote><h3 id="1-2-配置maven依赖"><a href="#1-2-配置maven依赖" class="headerlink" title="1.2 配置maven依赖"></a>1.2 配置maven依赖</h3><p><code>Maven示例</code></p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- Undertow Web 容器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-undertow<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="1-3-编写配置文件"><a href="#1-3-编写配置文件" class="headerlink" title="1.3 编写配置文件"></a>1.3 编写配置文件</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">undertow</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程</span>    <span class="token comment" spellcheck="true"># 不要设置过大，如果过大，启动项目会报错：打开文件数过多</span>    <span class="token key atrule">io-threads</span><span class="token punctuation">:</span> <span class="token number">8</span>    <span class="token comment" spellcheck="true"># 阻塞任务线程池, 当执行类似servlet请求阻塞IO操作, undertow会从这个线程池中取得线程</span>    <span class="token comment" spellcheck="true"># 它的值设置取决于系统线程执行任务的阻塞系数，默认值是IO线程数*8</span>    <span class="token key atrule">worker-threads</span><span class="token punctuation">:</span> <span class="token number">64</span>    <span class="token comment" spellcheck="true"># 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理</span>    <span class="token comment" spellcheck="true"># 每块buffer的空间大小,越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可</span>    <span class="token key atrule">buffer-size</span><span class="token punctuation">:</span> <span class="token number">1024</span>    <span class="token comment" spellcheck="true"># 是否分配的直接内存(NIO直接分配的堆外内存)</span>    <span class="token key atrule">direct-buffers</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h3 id="1-4-源码查看"><a href="#1-4-源码查看" class="headerlink" title="1.4 源码查看"></a>1.4 源码查看</h3><p><a href="https://github.com/undertow-io/undertow/blob/master/core/src/main/java/io/undertow/Undertow.java" target="_blank" rel="noopener">Undertow.java</a></p><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/15/undertow.png" alt></p><pre class=" language-java"><code class="language-java">ioThreads <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>workerThreads <span class="token operator">=</span> ioThreads <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//smaller than 64mb of ram we use 512b buffers</span><span class="token keyword">if</span> <span class="token punctuation">(</span>maxMemory <span class="token operator">&lt;</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use 512b buffers</span>    directBuffers <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    bufferSize <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>maxMemory <span class="token operator">&lt;</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use 1k buffers</span>    directBuffers <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    bufferSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use 16k buffers for best performance</span>    <span class="token comment" spellcheck="true">//as 16k is generally the max amount of data that can be sent in a single write() call</span>    directBuffers <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    bufferSize <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">-</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//the 20 is to allow some space for protocol headers, see UNDERTOW-1209</span><span class="token punctuation">}</span></code></pre><p>很显然，Undertow认为它的运用场景是在IO密集型的系统应用中，并且认为多核机器是一个比较容易满足的点，Undertow初始化假想应用的阻塞系数在0.8~0.9之间，所以阻塞线程数直接乘了个8，当然，如果对应用较精确的估测阻塞系数，可以配置上去。</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> undertow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 60 题：排列组合问题</title>
      <link href="/2019/07/11/LeetCode%20%E7%AC%AC%2060%20%E9%A2%98%EF%BC%9A%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/11/LeetCode%20%E7%AC%AC%2060%20%E9%A2%98%EF%BC%9A%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-第-60-题：第k个排列"><a href="#LeetCode-第-60-题：第k个排列" class="headerlink" title="LeetCode 第 60 题：第k个排列"></a>LeetCode 第 60 题：第k个排列</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>给出集合 <code>[1,2,3,…,n]</code>，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：<br><code>&quot;123&quot;   &quot;132&quot;   &quot;213&quot;   &quot;231&quot;   &quot;312&quot;   &quot;321&quot;</code><br>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><ul><li>给定 n 的范围是<code>[1, 9]</code>。</li><li>给定 k 的范围是<code>[1,  n!]</code>。</li></ul><p>示例 1:</p><pre><code>输入: n = 3, k = 3输出: &quot;213&quot;</code></pre><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>核心公式：</p><p>当前位置字符 = ((k - 1) % n!) / (n - 1)! 由于排列是按顺序的，那么第k个排列是可以计算出来的</p><p>比如:</p><ul><li><p><code>n=3</code>时。在所有<code>3！= 6</code>个排列中，第一个字符是按照<code>（3-1）！</code>个一组排列的，也就是<code>123,132（（3-1）！）</code>。</p></li><li><p><code>n=4</code>也一样<code>1234,1243,1324,1342,1423,1432（（4-1）！）</code>。 </p></li></ul><p>那么就可以根据这个规律设计核心公式，前提是在程序设计上需要一个基本字符串。比如当n=3，k=3时第一个字符所在位置为2，是针对123这个字符串来说的，在把2提出后，源字符串应该改写为13.根据这两点不断递归得到结果</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeetCode60</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成基本字符串     *     * @param n     * @param k     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPermutation</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuffer baseStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuffer str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> baseStr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">doCount</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> baseStr<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据公式生成字符串     *     * @param n     * @param k     * @param baseStr     * @param str     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> StringBuffer <span class="token function">doCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> StringBuffer baseStr<span class="token punctuation">,</span> StringBuffer str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>baseStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer fac <span class="token operator">=</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> k <span class="token operator">/</span> fac<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当前位置的字符</span>        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>baseStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        baseStr<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">doCount</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">%</span> fac<span class="token punctuation">,</span> baseStr<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 阶乘计算公式     *     * @param n     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fac <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fac <span class="token operator">*=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> fac<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>LeetCode60<span class="token punctuation">.</span><span class="token function">getPermutation</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 98 题：验证二叉搜索树</title>
      <link href="/2019/07/09/LeetCode%20%E7%AC%AC%2098%20%E9%A2%98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2019/07/09/LeetCode%20%E7%AC%AC%2098%20%E9%A2%98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-第-98-题：验证二叉搜索树"><a href="#LeetCode-第-98-题：验证二叉搜索树" class="headerlink" title="LeetCode 第 98 题：验证二叉搜索树"></a>LeetCode 第 98 题：验证二叉搜索树</h2><p><strong>题目</strong><br><code>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</code></p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong><em>示例 1:</em></strong></p><pre><code>输入:    2   / \  1   3输出: true</code></pre><p><strong><em>示例 2:</em></strong></p><pre><code>输入:    5   / \  1   4     / \    3   6输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> val<span class="token punctuation">;</span>  TreeNode left<span class="token punctuation">;</span>  TreeNode right<span class="token punctuation">;</span>  <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    val <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>乍一看，这是一个平凡的问题。只需要遍历整棵树，检查<code>node.right.val &gt; node.val</code>和 <code>node.left.val &lt; node.val</code>对每个结点是否成立。<br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/9/1.png" alt></p><p>问题是，这种方法并不总是正确。不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点。例如:<br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/9/2.png" alt></p><p>这意味着我们需要在遍历树的同时保留结点的上界与下界，子啊比较时不仅比较子结点的值，也要与上下界比较。 </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: lishangzhi * @Date: 2019/7/9 * @Description: &lt;验证二叉搜索树> * @link https://leetcode-cn.com/problems/validate-binary-search-tree/ */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeetCode90</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> pre <span class="token operator">=</span> Long<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 验证二叉树     *     * @param root     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 验证左边树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//验证右边树</span>                <span class="token keyword">return</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试案例     *     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LeetCode90 leetCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LeetCode90</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 模拟二叉树数据</span>        TreeNode treeNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        TreeNode treeNode = new TreeNode(5);</span><span class="token comment" spellcheck="true">//        treeNode.right = new TreeNode(1);</span><span class="token comment" spellcheck="true">//        treeNode.left = new TreeNode(4);</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//        treeNode.right.left = new TreeNode(3);</span><span class="token comment" spellcheck="true">//        treeNode.right.right = new TreeNode(6);</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetCode<span class="token punctuation">.</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的五种依赖注入方式</title>
      <link href="/2019/07/08/Spring%E7%9A%84%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/07/08/Spring%E7%9A%84%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring的五种依赖注入方式"><a href="#Spring的五种依赖注入方式" class="headerlink" title="Spring的五种依赖注入方式"></a>Spring的五种依赖注入方式</h2><blockquote><p><font size="1">Java开发中，某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做</font></p></blockquote><p><strong>Spring有多种依赖注入的形式，下面介绍spring进行DI的方式</strong></p><h3 id="一-Autowired：自动装配"><a href="#一-Autowired：自动装配" class="headerlink" title="一 @Autowired：自动装配"></a>一 @Autowired：自动装配</h3><p>前面已经比较过<code>@Autowired</code>和<code>@Resource</code>的区别<br><a href="https://lishangzhi.github.io/2019/07/08/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/">@Autowired和@Resource的区别?</a></p><p>@Autowired默认是根据参数类型进行自动装配，且必须有一个Bean候选者注入<font color="red">默认required=true，如果允许出现0个Bean候选者需要设置属性“required=false”</font>，“required”属性含义和@Required一样，只是@Required只适用于基于XML配置的setter注入方式,只能打在setting方法上</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Autowired</span>   <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="二-setter-方法注入"><a href="#二-setter-方法注入" class="headerlink" title="二 setter 方法注入"></a>二 setter 方法注入</h3><p>这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个IDao对象，那么就可以定义一个private的IDao成员变量，然后创建IDao的set方法（这是ioc的注入入口）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象 iDao</span>    <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一定要写被注入对象的set方法   </span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setiDao</span><span class="token punctuation">(</span>IDao iDao<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>iDao <span class="token operator">=</span> iDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        iDao<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="三-构造器注入"><a href="#三-构造器注入" class="headerlink" title="三 构造器注入"></a>三 构造器注入</h3><p>这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象SpringDao</span>    <span class="token keyword">private</span>  SpringDao springDao<span class="token punctuation">;</span>    <span class="token keyword">private</span>  User user<span class="token punctuation">;</span>    <span class="token keyword">private</span>  <span class="token function">SpringAction</span><span class="token punctuation">(</span>SpringDao springDao<span class="token punctuation">,</span>User user<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>springDao <span class="token operator">=</span>springDao<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法调用springDao和user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span>  <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"iByte"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        springDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="四-静态工厂的方法注入"><a href="#四-静态工厂的方法注入" class="headerlink" title="四 静态工厂的方法注入"></a>四 静态工厂的方法注入</h3><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaoFactory</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//静态工厂  </span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FactoryDao <span class="token function">getStaticFactoryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StaticFacotryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象  </span>    privateFactoryDaostaticFactoryDao<span class="token punctuation">;</span>    <span class="token function">publicvoidstaticFactoryOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        staticFactoryDao<span class="token punctuation">.</span><span class="token function">saveFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//注入对象的set方法  </span>    <span class="token function">publicvoidsetStaticFactoryDao</span><span class="token punctuation">(</span>FactoryDaostaticFactoryDao<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>staticFactoryDao<span class="token operator">=</span>staticFactoryDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="四-实例工厂的方法注入"><a href="#四-实例工厂的方法注入" class="headerlink" title="四 实例工厂的方法注入"></a>四 实例工厂的方法注入</h3><p>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依赖注入 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired和@Resource的区别</title>
      <link href="/2019/07/07/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/07/07/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Autowired和-Resource的区别是什么"><a href="#Autowired和-Resource的区别是什么" class="headerlink" title="@Autowired和@Resource的区别是什么?"></a>@Autowired和@Resource的区别是什么?</h2><blockquote><p><font size="1">最近在实现NLP意图匹配时候接口实现，默认支持了采用图灵nlp,采用云问nlp,百度nlp和公司内部自研的nlp; 基础接口都一样实现方式不一样而已,在定义完NLPWrapedService接口后统一,四个实现类全部实现NLPWrapedService，在注入的时候采用<code>@Autowired</code>在业务端确定Nlp类型后AI端无法注入指定的实现类，后续调整为@Resource;顺便查了相关资料补充下</font></p></blockquote><p>用途：做bean的注入时使用</p><p><strong>背景</strong>：</p><ul><li><code>@Autowired</code> 属于Spring的注解　<code>org.springframework.beans.factory.annotation.Autowired</code></li><li><code>@Resource</code>　不属于Spring的注解，JDK1.6支持的注解　<code>javax.annotation.Resource</code></li></ul><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/8/1.png" alt="@Autowired" title="@Autowired.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/8/2.png" alt="@Resource" title="@Resource.png"></p><p><strong>共同点</strong>：</p><ul><li>装配bean. 写在字段上,或写在<code>setter</code>方法</li></ul><p><strong>不同点</strong>：</p><ul><li><p><code>@Autowired</code>  默认按类型装配,依赖对象必须存在，如果要允许null值，可以设置它的required属性为false<br><code>@Autowired(required=false)</code>也可以使用名称装配，配合@Qualifier注解</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Autowired</span>   <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li><li><p><code>@Resource</code>  默认按名称进行装配，通过name属性进行指定</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 下面两种@Resource只要使用一种即可</span>  <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>  <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于字段上</span>  <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setIDao</span><span class="token punctuation">(</span>IDao iDao<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 用于属性的setter方法上</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>iDao <span class="token operator">=</span> iDao<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><table><thead><tr><th>注入方式</th><th>API文档说明</th></tr></thead><tbody><tr><td>*.annotation.Autowired</td><td>【Spring】<a href="https://docs.spring.io/spring/docs/current/javadoc-api/" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/javadoc-api/</a></td></tr><tr><td>*.annotation.Resource</td><td>【JDK1.8】<a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/index.html</a></td></tr></tbody></table><br><p><strong>注意</strong><br>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><p>@Resource装配顺序：</p><p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p><p>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p><p>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p><p>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：回溯算法</title>
      <link href="/2019/07/06/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2019/07/06/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法问题：回溯算法"><a href="#经典算法问题：回溯算法" class="headerlink" title="经典算法问题：回溯算法"></a>经典算法问题：回溯算法</h2><h3 id="回溯法-（Back-Tracking）"><a href="#回溯法-（Back-Tracking）" class="headerlink" title="回溯法 （Back Tracking）"></a>回溯法 （Back Tracking）</h3><p>回溯法是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p><code>回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。</code></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p><strong>示例 1:</strong><br><code>输入: k = 3, n = 7输出: [[1,2,4]]</code><br><strong>示例 2:</strong><br><code>输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong><em>标签：递归回溯</em></strong><br>递归终止条件：数组中包含k个数，如果和为n则加入结果集，否则直接返回终止递归<br>递归过程：循环遍历1-9，将新数字加入临时数组中进入下一层递归，出来后再将其移除<br>回溯的关键在于，添加和移除，保证所有可能性都遍历到，整体结构和栈类似</p><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/6/1.png" alt="递归回溯" title="递归回溯.jpg"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum3</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">traceBack</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">traceBack</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> sum<span class="token punctuation">)</span>                ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">traceBack</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> sum <span class="token operator">+</span> i <span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
            <tag> 经典算法问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 5 题：最长回文子串</title>
      <link href="/2019/07/04/LeetCode%20%E7%AC%AC%205%20%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/07/04/LeetCode%20%E7%AC%AC%205%20%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-第-5-题：最长回文子串"><a href="#LeetCode-第-5-题：最长回文子串" class="headerlink" title="LeetCode 第 5 题：最长回文子串"></a>LeetCode 第 5 题：最长回文子串</h2><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p></blockquote><pre><code>示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><p>回文串可分为奇数回文串和偶数回文串。它们的区别是：奇数回文串关于它的“中点”满足“中心对称”，偶数回文串关于它“中间的两个点”满足“中心对称”。</p><h3 id="方法一：暴力匹配-（Brute-Force）"><a href="#方法一：暴力匹配-（Brute-Force）" class="headerlink" title="方法一：暴力匹配 （Brute Force）"></a>方法一：暴力匹配 （Brute Force）</h3><p>暴力解法虽然时间复杂度高，但是思路清晰、编写简单，因为编写的正确性高，完全可以使用暴力匹配算法检验我们编写的算法的正确性。<br>（这里就不展示暴力匹配的写法了，实际上是我很懒。）</p><h3 id="方法二：中心扩散法"><a href="#方法二：中心扩散法" class="headerlink" title="方法二：中心扩散法"></a>方法二：中心扩散法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>            start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            end <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> L <span class="token operator">=</span> left<span class="token punctuation">,</span> R <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        L<span class="token operator">--</span><span class="token punctuation">;</span>        R<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="方法三：动态规划（推荐）"><a href="#方法三：动态规划（推荐）" class="headerlink" title="方法三：动态规划（推荐）"></a>方法三：动态规划（推荐）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> longestPalindrome <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        String longestPalindromeStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// abcdedcba</span>        <span class="token comment" spellcheck="true">//   l   r</span>        <span class="token comment" spellcheck="true">// 如果 dp[l, r] = true 那么 dp[l + 1, r - 1] 也一定为 true</span>        <span class="token comment" spellcheck="true">// 关键在这里：[l + 1, r - 1] 一定至少有 2 个元素才有判断的必要</span>        <span class="token comment" spellcheck="true">// 因为如果 [l + 1, r - 1] 只有一个元素，不用判断，一定是回文串</span>        <span class="token comment" spellcheck="true">// 如果 [l + 1, r - 1] 表示的区间为空，不用判断，也一定是回文串</span>        <span class="token comment" spellcheck="true">// [l + 1, r - 1] 一定至少有 2 个元素 等价于 l + 1 &lt; r - 1，即 r - l >  2</span>        <span class="token comment" spellcheck="true">// 写代码的时候这样写：如果 [l + 1, r - 1]  的元素小于等于 1 个，即 r - l &lt;=  2 ，就不用做判断了</span>        <span class="token comment" spellcheck="true">// 因为只有 1 个字符的情况在最开始做了判断</span>        <span class="token comment" spellcheck="true">// 左边界一定要比右边界小，因此右边界从 1 开始</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 区间应该慢慢放大</span>                <span class="token comment" spellcheck="true">// 状态转移方程：如果头尾字符相等并且中间也是回文</span>                <span class="token comment" spellcheck="true">// 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可</span>                <span class="token comment" spellcheck="true">// 否则要继续看收缩以后的区间的回文性</span>                <span class="token comment" spellcheck="true">// 重点理解 or 的短路性质在这里的作用</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> longestPalindrome<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        longestPalindrome <span class="token operator">=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                        longestPalindromeStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> longestPalindromeStr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 中心扩散 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第148题：排序链表</title>
      <link href="/2019/07/03/LeetCode%E7%AC%AC148%E9%A2%98%EF%BC%9A%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/03/LeetCode%E7%AC%AC148%E9%A2%98%EF%BC%9A%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode第148题：排序链表"><a href="#LeetCode第148题：排序链表" class="headerlink" title="LeetCode第148题：排序链表"></a>LeetCode第148题：排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><pre class=" language-$xslt"><code class="language-$xslt">示例 1:输入: 4->2->1->3输出: 1->2->3->4示例 2:输入: -1->5->3->4->0输出: -1->0->3->4->5</code></pre><h3 id="“单链表”自底向上实现”归并排序”"><a href="#“单链表”自底向上实现”归并排序”" class="headerlink" title="“单链表”自底向上实现”归并排序”"></a>“单链表”自底向上实现”归并排序”</h3><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/1.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-1" title="配图-1.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/2.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-2" title="配图-2.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/3.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-3" title="配图-3.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/4.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-4" title="配图-4.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/5.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-5" title="配图-5.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/6.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-6" title="配图-6.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/7.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-7" title="配图-7.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/8.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-8" title="配图-8.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/9.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-9" title="配图-9.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/10.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-10" title="配图-10.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/11.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-11" title="配图-11.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/12.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-12" title="配图-12.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/13.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-13" title="配图-13.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/14.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-14" title="配图-14.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/15.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-15" title="配图-15.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/16.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-16" title="配图-16.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/17.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-17" title="配图-17.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/18.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-18" title="配图-18.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/19.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-19" title="配图-19.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/20.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-20" title="配图-20.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/21.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-21" title="配图-21.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/22.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-22" title="配图-22.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/23.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-23" title="配图-23.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/24.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-24" title="配图-24.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>lishangzhi<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: lishangzhi * @Date: 2019/7/3 * @Description: &lt;自下而上进行归并> */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Definition for singly-linked list.     * public class ListNode {     *     int val;     *     ListNode next;     *     ListNode(int x) { val = x; }     * }     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这里设置 64 ，是一个绰绰有余的数字，可以满足结点数量为 2^64 这么多的单链表的排序</span>        ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历到的最大的 counter 数组的索引</span>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 先把当前元素暂存起来，马上我们就要把它放到 counter 数组合适的位置上</span>            ListNode carryNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// curNode 指针马上后移，方便下次处理</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 拿出的节点就和原来的链表没有关系了，我们在 counter 数组中完成排序，所以要切断它和原链表的关系</span>            carryNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 尝试从 counter 数组 0 号索引开始放置</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 只要非空当前位置非空，就进行一次 merge，merge 以后尝试放到下一格，如果下一格非空就继续合并</span>            <span class="token comment" spellcheck="true">// 合并以后再尝试放到下一格，直到下一格为空，直接放在那个为空的下一格就好</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode newMergeNode <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>carryNode<span class="token punctuation">,</span> counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                carryNode <span class="token operator">=</span> newMergeNode<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 遇到了空，就把 carryNode 放在数组的这个位置上</span>            counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> carryNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 记录最多使用到 counter 数组的第几位，最后合并的时候要用上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> maxIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历整个 count 数组，将它们全部归并，这个操作就和归并 n 个有序单链表是一样的了，我们这里采用两两归并</span>        ListNode res <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 归并两个已经排好序的单链表，是我们非常熟悉的操作了，可以递归完成，也可以穿针引线，这里我们递归完成     *     * @param l1 顺序存放的单链表1     * @param l2 顺序存放的单链表2     * @return 合并以后的单链表     */</span>    <span class="token keyword">private</span> ListNode <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义长度为5的单链表</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        MergeSort solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MergeSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode sortList <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sortList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="题目地址"><a href="#题目地址" class="headerlink" title=" 题目地址   "></a> 题目地址   </h2><p> <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">LeetCode第148题：排序链表.</a>    </p>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 44 题：通配符匹配</title>
      <link href="/2019/07/02/LeetCode%20%E7%AC%AC44%E9%A2%98%EF%BC%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/07/02/LeetCode%20%E7%AC%AC44%E9%A2%98%EF%BC%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><pre><code>说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</code></pre><pre><code>示例 1:输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre><pre><code>示例 2:输入:s = &quot;aa&quot;p = &quot;*&quot;输出: true解释: &#39;*&#39; 可以匹配任意字符串。</code></pre><pre><code>示例 3:输入:s = &quot;cb&quot;p = &quot;?a&quot;输出: false解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。</code></pre><pre><code>示例 4:输入:s = &quot;adceb&quot;p = &quot;*a*b&quot;输出: true解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.</code></pre><pre><code>示例 5:输入:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;输入: false</code></pre><h2 id="LeetCode-第-44-题：通配符匹配"><a href="#LeetCode-第-44-题：通配符匹配" class="headerlink" title="LeetCode 第 44 题：通配符匹配"></a>LeetCode 第 44 题：通配符匹配</h2><h3 id="思路一-利用两个指针进行遍历"><a href="#思路一-利用两个指针进行遍历" class="headerlink" title="思路一: 利用两个指针进行遍历"></a>思路一: 利用两个指针进行遍历</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sn <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pn <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> match <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                start <span class="token operator">=</span> j<span class="token punctuation">;</span>                match <span class="token operator">=</span> i<span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                match<span class="token operator">++</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> match<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="思路二-动态规划"><a href="#思路二-动态规划" class="headerlink" title="思路二: 动态规划"></a>思路二: 动态规划</h3><p><code>dp[i][j]</code>表示<code>s</code>到<code>i</code>位置,<code>p</code>到<code>j</code>位置是否匹配!</p><p>初始化:<br><code>dp[0][0]</code>:什么都没有,所以为true<br>第一行<code>dp[0][j]</code>,换句话说,<code>s</code>为空,与<code>p</code>匹配,所以只要<code>p</code>开始为<code>*</code>才为<code>true</code><br>第一列<code>dp[i][0]</code>,当然全部为<code>False</code><br>动态方程:</p><p>如果<code>(s[i] == p[j] || p[j] == &quot;?&quot;)</code> &amp;&amp; <code>dp[i-1][j-1] ,有dp[i][j] = true</code></p><p>如果<code>p[j] == &quot;*&quot; &amp;&amp; (dp[i-1][j] = true || dp[i][j-1] = true)</code>有<code>dp[i][j] = true</code></p><h5 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h5><p>​    <code>dp[i-1][j]</code>,表示<code>*</code>代表是空字符,例如<code>ab,ab*</code></p><p>​    <code>dp[i][j-1]</code>,表示<code>*</code>代表非空任何字符,例如<code>abcd,ab*</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 多一维的空间，因为求 dp[len - 1][j] 的时候需要知道 dp[len][j] 的情况，</span>        <span class="token comment" spellcheck="true">// 多一维的话，就可以把 对 dp[len - 1][j] 也写进循环了</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// dp[len][len] 代表两个空串是否匹配了，"" 和 "" ，当然是 true 了。</span>        dp<span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从 len 开始减少</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// dp[text.length()][pattern.length()] 已经进行了初始化</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//相比之前增加了判断是否等于 *</span>                <span class="token keyword">boolean</span> first_match <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">||</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span> <span class="token operator">||</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//将 * 跳过 和将字符匹配一个并且 pattern 不变两种情况</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> first_match <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> first_match <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="题目地址"><a href="#题目地址" class="headerlink" title=" 题目地址   "></a> 题目地址   </h2><p> <a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">LeetCode 第 44 题：通配符匹配.</a>                    </p>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 557 题：反转字符串中的单词</title>
      <link href="/2019/07/01/LeetCode%20%E7%AC%AC557%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/"/>
      <url>/2019/07/01/LeetCode%20%E7%AC%AC557%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目地址</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">LeetCode 第 557 题：反转字符串中的单词.</a></td><td><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/557-fan-zhuan-zi-fu-chuan-zhong-de-dan-ci-iii-ti-j/" target="_blank" rel="noopener">字符串处理</a></td></tr></tbody></table><h2 id="LeetCode-第-557-题：反转字符串中的单词"><a href="#LeetCode-第-557-题：反转字符串中的单词" class="headerlink" title="LeetCode 第 557 题：反转字符串中的单词"></a>LeetCode 第 557 题：反转字符串中的单词</h2><ul><li>空间设想<br><img src="http://ptyodd4up.bkt.clouddn.com/leecode711.png" alt="空间设想" title="设想.jpg"></li></ul><h3 id="一-利用StringBuffer-reverse-方法"><a href="#一-利用StringBuffer-reverse-方法" class="headerlink" title="一 . 利用StringBuffer reverse()方法"></a>一 . 利用StringBuffer reverse()方法</h3><ol><li>令n为旧字符序列的长度，即在执行反向方法之前字符串缓冲区中包含的字符序列。</li><li>新字符序列中索引k处的字符等于旧字符序列中索引n-k-1处的字符</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String soure<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String target <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//字符串拆分成数组</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> soure<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 利用StringBuffer.reverse() 将字符逆序</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> temp<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                target <span class="token operator">=</span> target <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                target <span class="token operator">=</span> target <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="二-利用数组双指针思想"><a href="#二-利用数组双指针思想" class="headerlink" title="二 . 利用数组双指针思想"></a>二 . 利用数组双指针思想</h3><ol><li>划分子数组</li><li>子数组双指针交换；</li><li>生成字符串</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将字符串转化为数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">char</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                    l<span class="token operator">++</span><span class="token punctuation">;</span>                    r<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                r <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            l<span class="token operator">++</span><span class="token punctuation">;</span>            r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>两次的执行结果</p></blockquote><p><img src="http://ptyodd4up.bkt.clouddn.com/leecode712.png" alt="执行结果比较" title="执行结果比较.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：K近邻算法</title>
      <link href="/2019/06/29/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9AK%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/29/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9AK%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法问题：K近邻算法-KNN"><a href="#经典算法问题：K近邻算法-KNN" class="headerlink" title="经典算法问题：K近邻算法(KNN)"></a>经典算法问题：K近邻算法(KNN)</h2><blockquote><p>K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p></blockquote><p><img src="http://ptyodd4up.bkt.clouddn.com/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.png" alt="K近邻算法" title="K近邻算法.jpg"></p><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h3><p>最简单最初级的分类器是将全部的训练数据所对应的类别都记录下来，当测试对象的属性和某个训练对象的属性完全匹配时，便可以对其进行分类。但是怎么可能所有测试对象都会找到与之完全匹配的训练对象呢，其次就是存在一个测试对象同时与多个训练对象匹配，导致一个训练对象被分到了多个类的问题，基于这些问题呢，就产生了KNN。KNN是通过测量不同特征值之间的距离进行分类。它的的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。K通常是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。</p><p>下面通过一个简单的例子说明一下：如下图，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如果K=3，由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。<br><img src="http://ptyodd4up.bkt.clouddn.com/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95-2.png" alt="案例" title="案例.jpg"></p><h3 id="二-欧氏距离-哈曼顿距离"><a href="#二-欧氏距离-哈曼顿距离" class="headerlink" title="二. 欧氏距离 / 哈曼顿距离"></a>二. 欧氏距离 / 哈曼顿距离</h3><p><img src="http://ptyodd4up.bkt.clouddn.com/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95-3.png" alt="欧氏距离  /  哈曼顿距离 " title=" 欧氏距离  /  哈曼顿距离.jpg"></p><h3 id="三-K-近邻算法（KNN）描述"><a href="#三-K-近邻算法（KNN）描述" class="headerlink" title="三. K-近邻算法（KNN）描述"></a>三. K-近邻算法（KNN）描述</h3><p>1）计算测试数据与各个训练数据之间的距离；</p><p>2）按照距离的递增关系进行排序；</p><p>3）选取距离最小的K个点；</p><p>4）确定前K个点所在类别的出现频率；</p><p>5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。</p><h3 id="四-代码"><a href="#四-代码" class="headerlink" title="四. 代码"></a>四. 代码</h3><p>Java 代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KNN</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * KNN数据模型     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">KNNModel</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> a<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> b<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> c<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> distince<span class="token punctuation">;</span>        String type<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">KNNModel</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">double</span> c<span class="token punctuation">,</span> String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 按距离排序         *         * @param arg         * @return         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>KNNModel arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>distince<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>distince<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 计算距离     *     * @param knnModelList     * @param i     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">calDistince</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> knnModelList<span class="token punctuation">,</span> KNNModel i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> distince<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>KNNModel m <span class="token operator">:</span> knnModelList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            distince <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>a <span class="token operator">-</span> m<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>a <span class="token operator">-</span> m<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>b <span class="token operator">-</span> m<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>b <span class="token operator">-</span> m<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>c <span class="token operator">-</span> m<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>c <span class="token operator">-</span> m<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m<span class="token punctuation">.</span>distince <span class="token operator">=</span> distince<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 找出前k个数据中分类最多的数据     *     * @param knnModelList     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">findMostData</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> knnModelList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> typeCountMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String type <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        Integer tempVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 统计分类个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>KNNModel model <span class="token operator">:</span> knnModelList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>typeCountMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                typeCountMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>type<span class="token punctuation">,</span> typeCountMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                typeCountMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>type<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 找出最多分类</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> entry <span class="token operator">:</span> typeCountMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> tempVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>                tempVal <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                type <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> type<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * KNN 算法的实现     *     * @param k     * @param knnModelList     * @param inputModel     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">calKNN</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> knnModelList<span class="token punctuation">,</span> KNNModel inputModel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1.计算距离"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">calDistince</span><span class="token punctuation">(</span>knnModelList<span class="token punctuation">,</span> inputModel<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2.按距离（近-->远）排序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>knnModelList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3.取前k个数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>knnModelList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            knnModelList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4.找出前k个数据中分类出现频率最大的数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String type <span class="token operator">=</span> <span class="token function">findMostData</span><span class="token punctuation">(</span>knnModelList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> type<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试KNN算法     *     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 准备数据</span>        List<span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> knnModelList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>KNNModel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">3.1</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">3.1</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">5.4</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">6.3</span><span class="token punctuation">,</span> <span class="token number">4.1</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">,</span> <span class="token number">10.0</span><span class="token punctuation">,</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预测数据</span>        KNNModel predictionData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">5.1</span><span class="token punctuation">,</span> <span class="token number">6.2</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token string">"NB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算</span>        String result <span class="token operator">=</span> <span class="token function">calKNN</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> knnModelList<span class="token punctuation">,</span> predictionData<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"预测结果："</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Python 代码</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token keyword">from</span> numpy <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> operator<span class="token keyword">def</span> <span class="token function">createDataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token string">'创建数据集'</span>    group<span class="token operator">=</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    labels<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> group<span class="token punctuation">,</span>labels<span class="token keyword">def</span> <span class="token function">classify</span><span class="token punctuation">(</span>inX<span class="token punctuation">,</span>dataSet<span class="token punctuation">,</span>labels<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 获取维度</span>    dataSetSize<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 训练数据集数量</span>    <span class="token keyword">print</span> dataSetSize    <span class="token keyword">print</span> tile<span class="token punctuation">(</span>inX<span class="token punctuation">,</span><span class="token punctuation">(</span>dataSetSize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    diffMat<span class="token operator">=</span>tile<span class="token punctuation">(</span>inX<span class="token punctuation">,</span><span class="token punctuation">(</span>dataSetSize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>dataSet  <span class="token comment" spellcheck="true"># 测试样本的各维度的差值</span>    <span class="token keyword">print</span> diffMat    sqDiffMat<span class="token operator">=</span>diffMat<span class="token operator">**</span><span class="token number">2</span>  <span class="token comment" spellcheck="true"># 平方计算</span>    <span class="token keyword">print</span> sqDiffMat    sqDistance<span class="token operator">=</span>sqDiffMat<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出每行的值</span>    <span class="token keyword">print</span> sqDistance    distances<span class="token operator">=</span>sqDistance<span class="token operator">**</span><span class="token number">0.5</span>   <span class="token comment" spellcheck="true"># 开方计算</span>    <span class="token keyword">print</span> distances    sortedDistances<span class="token operator">=</span>distances<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 排序 按距离从小到大 输出索引</span>    <span class="token keyword">print</span> sortedDistances    classCount<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>        voteIlabel<span class="token operator">=</span>labels<span class="token punctuation">[</span>sortedDistances<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        classCount<span class="token punctuation">[</span>voteIlabel<span class="token punctuation">]</span><span class="token operator">=</span>classCount<span class="token punctuation">.</span>get<span class="token punctuation">(</span>voteIlabel<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1.0</span>    sortedClassCount<span class="token operator">=</span>sorted<span class="token punctuation">(</span>classCount<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>key<span class="token operator">=</span>operator<span class="token punctuation">.</span>itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> sortedClassCount<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>group<span class="token punctuation">,</span>labels<span class="token operator">=</span>createDataSet<span class="token punctuation">(</span><span class="token punctuation">)</span>res<span class="token operator">=</span>classify<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>group<span class="token punctuation">,</span>labels<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span> res</code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分类算法 </tag>
            
            <tag> 经典算法问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：编辑距离算法</title>
      <link href="/2019/06/28/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/28/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法问题：编辑距离算法"><a href="#经典算法问题：编辑距离算法" class="headerlink" title="经典算法问题：编辑距离算法"></a>经典算法问题：编辑距离算法</h2><blockquote><p>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p></blockquote><p>例如将kitten一字转成sitting：</p><ol><li>sitten （k→s）</li><li>sittin （e→i）</li><li>sitting （→g）</li></ol><p>俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。因此也叫Levenshtein Distance。</p><h3 id="编辑距离递推公式"><a href="#编辑距离递推公式" class="headerlink" title="编辑距离递推公式"></a>编辑距离递推公式</h3><p>设字符串S，T长度分别为m, n，记S(i)为S从第1个字符到第i个字符之间的子串。S(0)表示空串，S(m)表示S本身。</p><p>因此，S和T间的编辑距离，可由S(i)和T(j)的编辑距离计算而来。<br><img src="http://ptyodd4up.bkt.clouddn.com/%E7%BC%96%E8%B7%9D%E7%AE%97%E6%B3%95.png" alt="Edit Distance" title="屏幕截图.png"></p><h3 id="基础案例"><a href="#基础案例" class="headerlink" title="基础案例"></a>基础案例</h3><ul><li>如果str1=”ivan”，str2=”ivan”，那么经过计算后等于 0。没有经过转换。相似度=1-0/Math.Max(str1.length,str2.length)=1</li><li>如果str1=”ivan1”，str2=”ivan2”，那么经过计算后等于1。str1的”1”转换”2”，转换了一个字符，所以距离是1，相似度=1-1/Math.Max(str1.length,str2.length)=0.8</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>DNA分析</li><li>拼字检查</li><li>语音辨识 </li><li>抄袭侦测</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>Java 代码</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">EditDistance</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> sources<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> targets<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sourceLen <span class="token operator">=</span> sources<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> targetLen <span class="token operator">=</span> targets<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>sourceLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>targetLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sourceLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> targetLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sourceLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> targetLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sources<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> targets<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//插入</span>                <span class="token keyword">int</span> insert <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//删除</span>                <span class="token keyword">int</span> delete <span class="token operator">=</span> d<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//替换</span>                <span class="token keyword">int</span> replace <span class="token operator">=</span> d<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>insert<span class="token punctuation">,</span> delete<span class="token punctuation">)</span> <span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>delete<span class="token punctuation">,</span> replace<span class="token punctuation">)</span> <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>delete<span class="token punctuation">,</span> replace<span class="token punctuation">)</span> <span class="token operator">:</span>                        Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>insert<span class="token punctuation">,</span> delete<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> d<span class="token punctuation">[</span>sourceLen<span class="token punctuation">]</span><span class="token punctuation">[</span>targetLen<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Python 代码</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">edit_distance</span><span class="token punctuation">(</span>sources<span class="token punctuation">,</span> targets<span class="token punctuation">)</span><span class="token punctuation">:</span>    len1 <span class="token operator">=</span> len<span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">;</span>    len2 <span class="token operator">=</span> len<span class="token punctuation">(</span>targets<span class="token punctuation">)</span><span class="token punctuation">;</span>    dp <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            delta <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> sources<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> targets<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">1</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> delta<span class="token punctuation">,</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span></code></pre><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p><code>Java 代码</code></p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> sources <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"打球"</span><span class="token punctuation">,</span><span class="token string">"爬山"</span><span class="token punctuation">,</span><span class="token string">"跑步"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> targets <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"打球"</span><span class="token punctuation">,</span><span class="token string">"爬山"</span><span class="token punctuation">,</span><span class="token string">"跑步"</span><span class="token punctuation">,</span><span class="token string">"看书"</span><span class="token punctuation">,</span><span class="token string">"游泳"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>返回结果 ：<span class="token number">2</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典算法问题 </tag>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：数组中的逆序对</title>
      <link href="/2019/06/27/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2019/06/27/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法问题：数组中的逆序对"><a href="#经典算法问题：数组中的逆序对" class="headerlink" title="经典算法问题：数组中的逆序对"></a>经典算法问题：数组中的逆序对</h2><blockquote><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</p></blockquote><p>  输入一个数组，求出这个数组中的逆序对的总数。</p><p><code>输入：[1,2,3,4,5,6,0] 输出：6</code></p><h3 id="思路1：使用定义"><a href="#思路1：使用定义" class="headerlink" title="思路1：使用定义"></a>思路1：使用定义</h3><p>挨个数出来，使用定义计算逆序数。不过时间复杂度是 O(n2)。</p><p>python代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><p>这种思路虽然很直接，但编写出错的概率很低，在没有在线评测系统的时候，它可以作为一个“正确的”参考答案，用以检验我们自己编写的算法是否正确。</p><h3 id="思路2：分治"><a href="#思路2：分治" class="headerlink" title="思路2：分治"></a>思路2：分治</h3><p>这道题最经典的思路是使用分治法计算，借助“归并排序”的分治思想，排好序以后，逆序对就求出来了，时间复杂度为 O(nlogn)。下面举例说明：例如：前有序数组：[2,3,5,8]，后有序数组：[4,6,7,12]。</p><p>做归并的时候，步骤如下：</p><p>第 1 步，2 先出列，2 比“后有序数组”中所有的元素都小，构成“顺序对”；</p><p>第 2 步，3 出列，3 比“后有序数组”中所有的元素都小，构成“顺序对”；</p><p>第 3 步，4 出列，关键的地方在这里，“前有序数组”中所有剩下的元素 [5,8] 比 4 都大，构成 2 个 “逆序对”；</p><p>第 4 步，5 出列，5 比“后有序数组”中所有剩下的元素都小，构成“顺序对”；</p><p>第 5 步，6 出列，“前有序数组”中所有剩下的元素 [8] 比 6 都大，构成 1 个“逆序对”；</p><p>第 6 步，7 出列，“前有序数组”中所有剩下的元素 [8] 比 7 都大，构成 1 个“逆序对”；</p><p>第 7 步，8 出列，8 比“后有序数组”中所有剩下的元素 [8] 都小，构成 1 个“顺序对”；</p><p>第 8 步，12 出列，此时“前有序数组”为空。</p><p>因此，我们只需要在“前有序数组”非空，且“后有序数组”中有元素出列的时候，即上面的第 3、5、6 步计算“逆序对”就可以了。</p><p>python代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inversePairs1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">inversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">count_inversion_pairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        在数组 nums 的区间 [l,r] 统计逆序对        :param nums:        :param l: 待统计数组的左边界，可以取到        :param r: 待统计数组的右边界，可以取到        :param temp:        :return:        """</span>        <span class="token comment" spellcheck="true"># 极端情况下，就是只有 1 个元素的时候</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> r<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        left_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        right_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        merge_pairs <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 代码走到这里的时候，</span>        <span class="token comment" spellcheck="true"># [l, mid] 已经完成了排序并且计算好逆序对</span>        <span class="token comment" spellcheck="true"># [mid + 1, r] 已经完成了排序并且计算好逆序对</span>        <span class="token comment" spellcheck="true"># 如果 nums[mid] &lt;= nums[mid + 1]，此时就不存在逆序对</span>        <span class="token comment" spellcheck="true"># 当 nums[mid] > nums[mid + 1] 的时候，就要继续计算逆序对</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 在归并的过程中计算逆序对</span>            merge_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>merge_and_count<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 走到这里有 nums[mid] &lt;= nums[mid + 1] 成立，已经是顺序结构</span>        <span class="token keyword">return</span> left_pairs <span class="token operator">+</span> right_pairs <span class="token operator">+</span> merge_pairs    <span class="token keyword">def</span> <span class="token function">merge_and_count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        前：[2,3,5,8]，后：[4,6,7,12]        我们只需要在后面数组元素出列的时候，数一数前面这个数组还剩下多少个数字，        因为"前"数组和"后"数组都有序，        因此，"前"数组剩下的元素个数 mid - i + 1 就是与"后"数组元素出列的这个元素构成的逆序对个数        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        i <span class="token operator">=</span> l        j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">></span> mid<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> j <span class="token operator">></span> r<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 不统计逆序对，只做排序</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">assert</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true"># 快就快在这里，一次可以数出一个区间的个数的逆序对</span>                <span class="token comment" spellcheck="true"># 例：[7,8,9][4,6,9]，4 与 7 以及 7 前面所有的数都构成逆序对</span>                res <span class="token operator">+=</span> <span class="token punctuation">(</span>mid <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>说明：归并两个有序数组的时候，我们要借助额外的辅助空间，为此可以全局使用一个和原始数组等长的辅助数组，否则每一次进入 merge 函数都要 new 新数组，开销很大。</p><p>上述解法的缺点是修改了原始数组，排序完成以后，逆序数就计算出来了。为此：（1）我们可以引入一个索引数组；（2）或者直接拷贝一个原始数组，这样就不用修改原始数组了。</p><h3 id="思路3：使用“树状数组”"><a href="#思路3：使用“树状数组”" class="headerlink" title="思路3：使用“树状数组”"></a>思路3：使用“树状数组”</h3><p>python 代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">class</span> <span class="token class-name">FenwickTree</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>size <span class="token operator">=</span> n                self<span class="token punctuation">.</span>tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">__lowbit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> index <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>index<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 单点更新：从下到上，最多到 size，可以取等</span>            <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> index <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>size<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>tree<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+=</span> delta                    index <span class="token operator">+=</span> self<span class="token punctuation">.</span>__lowbit<span class="token punctuation">(</span>index<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 区间查询：从上到下，最少到 1，可以取等</span>            <span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>                res <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">while</span> index <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> self<span class="token punctuation">.</span>tree<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                    index <span class="token operator">-=</span> self<span class="token punctuation">.</span>__lowbit<span class="token punctuation">(</span>index<span class="token punctuation">)</span>                <span class="token keyword">return</span> res        <span class="token comment" spellcheck="true"># 特判</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 原始数组去除重复以后从小到大排序</span>        s <span class="token operator">=</span> list<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 构建最小堆，因为从小到大一个一个拿出来，用堆比较合适</span>        <span class="token keyword">import</span> heapq        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 由数字查排名</span>        rank_map <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        index <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 不重复数字的个数</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            num <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            rank_map<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> index            index <span class="token operator">+=</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 树状数组只要不重复数字个数这么多空间就够了</span>        ft <span class="token operator">=</span> FenwickTree<span class="token punctuation">(</span>size<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 从后向前看，拿出一个数字来，就更新一下，然后向前查询比它小的个数</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            rank <span class="token operator">=</span> rank_map<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>            ft<span class="token punctuation">.</span>update<span class="token punctuation">(</span>rank<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            res <span class="token operator">+=</span> ft<span class="token punctuation">.</span>query<span class="token punctuation">(</span>rank <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>说明：中间将数字映射到排名是将原数组“离散化”，“离散化”的原因有 2 点：</p><p>1、树状数组我们看到，索引是从“1”开始的，我们不能保证我们的数组所有的元素都大于等于 1；</p><p>2、即使元素都大于等于“1”，为了节约树状数组的空间，我们将之“离散化”可以把原始的数都压缩到一个小区间。我说的有点不太清楚，这一点可以参考 树</p><hr><p>【算法】逆序对问题的四种解法（归并排序，BST，树状数组，线段树）及变形<br><a href="https://blog.csdn.net/haolexiao/article/details/54989306" target="_blank" rel="noopener">https://blog.csdn.net/haolexiao/article/details/54989306</a></p><p>leetcode 315 Count of Smaller Numbers After Self 以及 BST总结。<br><a href="https://segmentfault.com/a/1190000008233783" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008233783</a></p>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典算法问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：赫夫曼树以及赫夫曼编码</title>
      <link href="/2019/06/26/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BB%A5%E5%8F%8A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
      <url>/2019/06/26/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BB%A5%E5%8F%8A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="赫夫曼树以及赫夫曼编码"><a href="#赫夫曼树以及赫夫曼编码" class="headerlink" title="赫夫曼树以及赫夫曼编码"></a>赫夫曼树以及赫夫曼编码</h3><p>是能使得给定的字符串编码成 0 1 串后长度最短的前缀编码。</p><p>1、编码问题：ASCII 码：一共 128 个：<a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="noopener">http://tool.oschina.net/commons?type=4</a></p><p>2、前缀码：前缀唯一</p><p>3、频率越高，编码越短</p><p>4、等长编码与不等长编码</p><p>5、构建出二叉树，左分支走 0 ，右分支走 1</p><p>6、非叶子结点上出现前缀，没有二义性</p><p>7、WLP 值一样。</p><p>参考资料：</p><p>《大话数据结构》</p><p>算法导论第 200 页：</p><p>殷人昆《数据结构》</p><p>赫夫曼树以及赫夫曼编码</p><ol><li>有多分支的时候，将常用的分支靠前，可以减少判断的次数，以提高效率，但是这样做需要对数据的分布有所了解，即要知道数据的频数；</li><li>应用于文件压缩，具体：重新编码（Huffman 编码），以减少存储和传输的空间大小；</li><li>Huffman 编码的基本思想，频数较多的靠前，类似与我们总是将常用的文字，设计成笔画较少，生僻字的笔画往往较多且复杂；</li><li>Huffman 树的特点：叶子结点带权，这个权就是我们上面说的频数；</li><li>一些定义：</li></ol><pre><code>（1）结点的路径长度：（2）树的路径长度：不限制是否是叶子结点（3）树的带权路径长度：所有叶子结点（4）树的带权路径长度 WPL：WPL 最小的二叉树称之为 Huffman 树，或者说是最优二叉树</code></pre><p>可以构造出不同的 Huffman 树（想到构造的过程其实是贪心算法，我们总是希望权值小的结点出现在较高的地方），但是 WLP 一定是一样的。</p><p>具体例子：<br>依据频数编码，将频数视为权值</p><p>前缀码：其实是反过来定义的，即不可能成为其它码的前缀的码，类比 Trie ，这是为了保证编码的唯一性，避免二义性。</p><p>左分支代表 0 ，右分支代表 1。</p><p>解码：（非等长编码）</p><p>发送方和接收方，必须要有同样的 Huffman 树。</p><p>参考资料</p><ol><li>《大话数据结构》</li><li>《算法导论》</li><li>灯笼大神的动态 Huffman 编码 Adaptive Huffman Encoding</li></ol>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典算法问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
