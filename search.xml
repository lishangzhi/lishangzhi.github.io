<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring的五种依赖注入方式</title>
      <link href="/2019/07/08/Spring%E7%9A%84%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/07/08/Spring%E7%9A%84%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring的五种依赖注入方式"><a href="#Spring的五种依赖注入方式" class="headerlink" title="Spring的五种依赖注入方式"></a>Spring的五种依赖注入方式</h2><blockquote><p><font size="1">Java开发中，某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做</font></p></blockquote><p><strong>Spring有多种依赖注入的形式，下面介绍spring进行DI的方式</strong></p><h3 id="一-Autowired：自动装配"><a href="#一-Autowired：自动装配" class="headerlink" title="一 @Autowired：自动装配"></a>一 @Autowired：自动装配</h3><p>前面已经比较过<code>@Autowired</code>和<code>@Resource</code>的区别<br><a href="https://lishangzhi.github.io/2019/07/08/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">@Autowired和@Resource的区别?</a></p><p>@Autowired默认是根据参数类型进行自动装配，且必须有一个Bean候选者注入<font color="red">默认required=true，如果允许出现0个Bean候选者需要设置属性“required=false”</font>，“required”属性含义和@Required一样，只是@Required只适用于基于XML配置的setter注入方式,只能打在setting方法上</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Autowired</span>   <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="二-setter-方法注入"><a href="#二-setter-方法注入" class="headerlink" title="二 setter 方法注入"></a>二 setter 方法注入</h3><p>这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个IDao对象，那么就可以定义一个private的IDao成员变量，然后创建IDao的set方法（这是ioc的注入入口）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象 iDao</span>    <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一定要写被注入对象的set方法   </span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setiDao</span><span class="token punctuation">(</span>IDao iDao<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>iDao <span class="token operator">=</span> iDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        iDao<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="三-构造器注入"><a href="#三-构造器注入" class="headerlink" title="三 构造器注入"></a>三 构造器注入</h3><p>这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象SpringDao</span>    <span class="token keyword">private</span>  SpringDao springDao<span class="token punctuation">;</span>    <span class="token keyword">private</span>  User user<span class="token punctuation">;</span>    <span class="token keyword">private</span>  <span class="token function">SpringAction</span><span class="token punctuation">(</span>SpringDao springDao<span class="token punctuation">,</span>User user<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>springDao <span class="token operator">=</span>springDao<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法调用springDao和user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span>  <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"iByte"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        springDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="四-静态工厂的方法注入"><a href="#四-静态工厂的方法注入" class="headerlink" title="四 静态工厂的方法注入"></a>四 静态工厂的方法注入</h3><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaoFactory</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//静态工厂  </span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FactoryDao <span class="token function">getStaticFactoryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StaticFacotryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入对象  </span>    privateFactoryDaostaticFactoryDao<span class="token punctuation">;</span>    <span class="token function">publicvoidstaticFactoryOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        staticFactoryDao<span class="token punctuation">.</span><span class="token function">saveFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//注入对象的set方法  </span>    <span class="token function">publicvoidsetStaticFactoryDao</span><span class="token punctuation">(</span>FactoryDaostaticFactoryDao<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>staticFactoryDao<span class="token operator">=</span>staticFactoryDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="四-实例工厂的方法注入"><a href="#四-实例工厂的方法注入" class="headerlink" title="四 实例工厂的方法注入"></a>四 实例工厂的方法注入</h3><p>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired和@Resource的区别</title>
      <link href="/2019/07/07/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/07/07/Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Autowired和-Resource的区别是什么"><a href="#Autowired和-Resource的区别是什么" class="headerlink" title="@Autowired和@Resource的区别是什么?"></a>@Autowired和@Resource的区别是什么?</h2><blockquote><p><font size="1">最近在实现NLP意图匹配时候接口实现，默认支持了采用图灵nlp,采用云问nlp,百度nlp和公司内部自研的nlp; 基础接口都一样实现方式不一样而已,在定义完NLPWrapedService接口后统一,四个实现类全部实现NLPWrapedService，在注入的时候采用<code>@Autowired</code>在业务端确定Nlp类型后AI端无法注入指定的实现类，后续调整为@Resource;顺便查了相关资料补充下</font></p></blockquote><p>用途：做bean的注入时使用</p><p><strong>背景</strong>：</p><ul><li><code>@Autowired</code> 属于Spring的注解　<code>org.springframework.beans.factory.annotation.Autowired</code></li><li><code>@Resource</code>　不属于Spring的注解，JDK1.6支持的注解　<code>javax.annotation.Resource</code></li></ul><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/8/1.png" alt="@Autowired" title="@Autowired.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/8/2.png" alt="@Resource" title="@Resource.png"></p><p><strong>共同点</strong>：</p><ul><li>装配bean. 写在字段上,或写在<code>setter</code>方法</li></ul><p><strong>不同点</strong>：</p><ul><li><p><code>@Autowired</code>  默认按类型装配,依赖对象必须存在，如果要允许null值，可以设置它的required属性为false<br><code>@Autowired(required=false)</code>也可以使用名称装配，配合@Qualifier注解</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Autowired</span>   <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li><li><p><code>@Resource</code>  默认按名称进行装配，通过name属性进行指定</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IServiceImpl</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 下面两种@Resource只要使用一种即可</span>  <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>  <span class="token keyword">private</span> IDao iDao<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于字段上</span>  <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"iDao"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setIDao</span><span class="token punctuation">(</span>IDao iDao<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 用于属性的setter方法上</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>iDao <span class="token operator">=</span> iDao<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><table><thead><tr><th>注入方式</th><th>API文档说明</th></tr></thead><tbody><tr><td>*.annotation.Autowired</td><td>【Spring】<a href="https://docs.spring.io/spring/docs/current/javadoc-api/" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/javadoc-api/</a></td></tr><tr><td>*.annotation.Resource</td><td>【JDK1.8】<a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/index.html</a></td></tr></tbody></table><br><p><strong>注意</strong><br>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><p>@Resource装配顺序：</p><p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p><p>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p><p>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p><p>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：回溯算法</title>
      <link href="/2019/07/06/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2019/07/06/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法问题：回溯算法"><a href="#经典算法问题：回溯算法" class="headerlink" title="经典算法问题：回溯算法"></a>经典算法问题：回溯算法</h2><h3 id="回溯法-（Back-Tracking）"><a href="#回溯法-（Back-Tracking）" class="headerlink" title="回溯法 （Back Tracking）"></a>回溯法 （Back Tracking）</h3><p>回溯法是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p><code>回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。</code></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p><strong>示例 1:</strong><br><code>输入: k = 3, n = 7输出: [[1,2,4]]</code><br><strong>示例 2:</strong><br><code>输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong><em>标签：递归回溯</em></strong><br>递归终止条件：数组中包含k个数，如果和为n则加入结果集，否则直接返回终止递归<br>递归过程：循环遍历1-9，将新数字加入临时数组中进入下一层递归，出来后再将其移除<br>回溯的关键在于，添加和移除，保证所有可能性都遍历到，整体结构和栈类似</p><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/6/1.png" alt="递归回溯" title="递归回溯.jpg"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum3</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">traceBack</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">traceBack</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> sum<span class="token punctuation">)</span>                ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">traceBack</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> sum <span class="token operator">+</span> i <span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
            <tag> 经典算法问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 5 题：最长回文子串</title>
      <link href="/2019/07/04/LeetCode%20%E7%AC%AC%205%20%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/07/04/LeetCode%20%E7%AC%AC%205%20%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-第-5-题：最长回文子串"><a href="#LeetCode-第-5-题：最长回文子串" class="headerlink" title="LeetCode 第 5 题：最长回文子串"></a>LeetCode 第 5 题：最长回文子串</h2><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p></blockquote><pre><code>示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><p>回文串可分为奇数回文串和偶数回文串。它们的区别是：奇数回文串关于它的“中点”满足“中心对称”，偶数回文串关于它“中间的两个点”满足“中心对称”。</p><h3 id="方法一：暴力匹配-（Brute-Force）"><a href="#方法一：暴力匹配-（Brute-Force）" class="headerlink" title="方法一：暴力匹配 （Brute Force）"></a>方法一：暴力匹配 （Brute Force）</h3><p>暴力解法虽然时间复杂度高，但是思路清晰、编写简单，因为编写的正确性高，完全可以使用暴力匹配算法检验我们编写的算法的正确性。<br>（这里就不展示暴力匹配的写法了，实际上是我很懒。）</p><h3 id="方法二：中心扩散法"><a href="#方法二：中心扩散法" class="headerlink" title="方法二：中心扩散法"></a>方法二：中心扩散法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>            start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            end <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> L <span class="token operator">=</span> left<span class="token punctuation">,</span> R <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        L<span class="token operator">--</span><span class="token punctuation">;</span>        R<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="方法三：动态规划（推荐）"><a href="#方法三：动态规划（推荐）" class="headerlink" title="方法三：动态规划（推荐）"></a>方法三：动态规划（推荐）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> longestPalindrome <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        String longestPalindromeStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// abcdedcba</span>        <span class="token comment" spellcheck="true">//   l   r</span>        <span class="token comment" spellcheck="true">// 如果 dp[l, r] = true 那么 dp[l + 1, r - 1] 也一定为 true</span>        <span class="token comment" spellcheck="true">// 关键在这里：[l + 1, r - 1] 一定至少有 2 个元素才有判断的必要</span>        <span class="token comment" spellcheck="true">// 因为如果 [l + 1, r - 1] 只有一个元素，不用判断，一定是回文串</span>        <span class="token comment" spellcheck="true">// 如果 [l + 1, r - 1] 表示的区间为空，不用判断，也一定是回文串</span>        <span class="token comment" spellcheck="true">// [l + 1, r - 1] 一定至少有 2 个元素 等价于 l + 1 &lt; r - 1，即 r - l >  2</span>        <span class="token comment" spellcheck="true">// 写代码的时候这样写：如果 [l + 1, r - 1]  的元素小于等于 1 个，即 r - l &lt;=  2 ，就不用做判断了</span>        <span class="token comment" spellcheck="true">// 因为只有 1 个字符的情况在最开始做了判断</span>        <span class="token comment" spellcheck="true">// 左边界一定要比右边界小，因此右边界从 1 开始</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 区间应该慢慢放大</span>                <span class="token comment" spellcheck="true">// 状态转移方程：如果头尾字符相等并且中间也是回文</span>                <span class="token comment" spellcheck="true">// 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可</span>                <span class="token comment" spellcheck="true">// 否则要继续看收缩以后的区间的回文性</span>                <span class="token comment" spellcheck="true">// 重点理解 or 的短路性质在这里的作用</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> longestPalindrome<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        longestPalindrome <span class="token operator">=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                        longestPalindromeStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> longestPalindromeStr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 中心扩散 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第148题：排序链表</title>
      <link href="/2019/07/03/LeetCode%E7%AC%AC148%E9%A2%98%EF%BC%9A%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/03/LeetCode%E7%AC%AC148%E9%A2%98%EF%BC%9A%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode第148题：排序链表"><a href="#LeetCode第148题：排序链表" class="headerlink" title="LeetCode第148题：排序链表"></a>LeetCode第148题：排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><pre class=" language-$xslt"><code class="language-$xslt">示例 1:输入: 4->2->1->3输出: 1->2->3->4示例 2:输入: -1->5->3->4->0输出: -1->0->3->4->5</code></pre><h3 id="“单链表”自底向上实现”归并排序”"><a href="#“单链表”自底向上实现”归并排序”" class="headerlink" title="“单链表”自底向上实现”归并排序”"></a>“单链表”自底向上实现”归并排序”</h3><p><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/1.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-1" title="配图-1.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/2.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-2" title="配图-2.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/3.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-3" title="配图-3.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/4.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-4" title="配图-4.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/5.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-5" title="配图-5.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/6.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-6" title="配图-6.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/7.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-7" title="配图-7.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/8.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-8" title="配图-8.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/9.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-9" title="配图-9.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/10.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-10" title="配图-10.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/11.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-11" title="配图-11.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/12.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-12" title="配图-12.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/13.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-13" title="配图-13.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/14.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-14" title="配图-14.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/15.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-15" title="配图-15.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/16.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-16" title="配图-16.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/17.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-17" title="配图-17.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/18.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-18" title="配图-18.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/19.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-19" title="配图-19.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/20.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-20" title="配图-20.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/21.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-21" title="配图-21.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/22.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-22" title="配图-22.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/23.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-23" title="配图-23.png"><br><img src="http://ptyodd4up.bkt.clouddn.com/2019/7/3/24.png" alt="&quot;单链表&quot;自底向上实现&quot;归并排序&quot;题解配图-24" title="配图-24.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>lishangzhi<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: lishangzhi * @Date: 2019/7/3 * @Description: &lt;自下而上进行归并> */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Definition for singly-linked list.     * public class ListNode {     *     int val;     *     ListNode next;     *     ListNode(int x) { val = x; }     * }     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这里设置 64 ，是一个绰绰有余的数字，可以满足结点数量为 2^64 这么多的单链表的排序</span>        ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历到的最大的 counter 数组的索引</span>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 先把当前元素暂存起来，马上我们就要把它放到 counter 数组合适的位置上</span>            ListNode carryNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// curNode 指针马上后移，方便下次处理</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 拿出的节点就和原来的链表没有关系了，我们在 counter 数组中完成排序，所以要切断它和原链表的关系</span>            carryNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 尝试从 counter 数组 0 号索引开始放置</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 只要非空当前位置非空，就进行一次 merge，merge 以后尝试放到下一格，如果下一格非空就继续合并</span>            <span class="token comment" spellcheck="true">// 合并以后再尝试放到下一格，直到下一格为空，直接放在那个为空的下一格就好</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode newMergeNode <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>carryNode<span class="token punctuation">,</span> counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                carryNode <span class="token operator">=</span> newMergeNode<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 遇到了空，就把 carryNode 放在数组的这个位置上</span>            counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> carryNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 记录最多使用到 counter 数组的第几位，最后合并的时候要用上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> maxIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历整个 count 数组，将它们全部归并，这个操作就和归并 n 个有序单链表是一样的了，我们这里采用两两归并</span>        ListNode res <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 归并两个已经排好序的单链表，是我们非常熟悉的操作了，可以递归完成，也可以穿针引线，这里我们递归完成     *     * @param l1 顺序存放的单链表1     * @param l2 顺序存放的单链表2     * @return 合并以后的单链表     */</span>    <span class="token keyword">private</span> ListNode <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeOfTwoSortedListNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义长度为5的单链表</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        MergeSort solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MergeSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode sortList <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sortList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="题目地址"><a href="#题目地址" class="headerlink" title=" 题目地址   "></a> 题目地址   </h2><p> <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">LeetCode第148题：排序链表.</a>    </p>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 44 题：通配符匹配</title>
      <link href="/2019/07/02/LeetCode%20%E7%AC%AC44%E9%A2%98%EF%BC%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/07/02/LeetCode%20%E7%AC%AC44%E9%A2%98%EF%BC%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><pre><code>说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</code></pre><pre><code>示例 1:输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre><pre><code>示例 2:输入:s = &quot;aa&quot;p = &quot;*&quot;输出: true解释: &#39;*&#39; 可以匹配任意字符串。</code></pre><pre><code>示例 3:输入:s = &quot;cb&quot;p = &quot;?a&quot;输出: false解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。</code></pre><pre><code>示例 4:输入:s = &quot;adceb&quot;p = &quot;*a*b&quot;输出: true解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.</code></pre><pre><code>示例 5:输入:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;输入: false</code></pre><h2 id="LeetCode-第-44-题：通配符匹配"><a href="#LeetCode-第-44-题：通配符匹配" class="headerlink" title="LeetCode 第 44 题：通配符匹配"></a>LeetCode 第 44 题：通配符匹配</h2><h3 id="思路一-利用两个指针进行遍历"><a href="#思路一-利用两个指针进行遍历" class="headerlink" title="思路一: 利用两个指针进行遍历"></a>思路一: 利用两个指针进行遍历</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sn <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pn <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> match <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                start <span class="token operator">=</span> j<span class="token punctuation">;</span>                match <span class="token operator">=</span> i<span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                match<span class="token operator">++</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> match<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="思路二-动态规划"><a href="#思路二-动态规划" class="headerlink" title="思路二: 动态规划"></a>思路二: 动态规划</h3><p><code>dp[i][j]</code>表示<code>s</code>到<code>i</code>位置,<code>p</code>到<code>j</code>位置是否匹配!</p><p>初始化:<br><code>dp[0][0]</code>:什么都没有,所以为true<br>第一行<code>dp[0][j]</code>,换句话说,<code>s</code>为空,与<code>p</code>匹配,所以只要<code>p</code>开始为<code>*</code>才为<code>true</code><br>第一列<code>dp[i][0]</code>,当然全部为<code>False</code><br>动态方程:</p><p>如果<code>(s[i] == p[j] || p[j] == &quot;?&quot;)</code> &amp;&amp; <code>dp[i-1][j-1] ,有dp[i][j] = true</code></p><p>如果<code>p[j] == &quot;*&quot; &amp;&amp; (dp[i-1][j] = true || dp[i][j-1] = true)</code>有<code>dp[i][j] = true</code></p><h5 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h5><p>​    <code>dp[i-1][j]</code>,表示<code>*</code>代表是空字符,例如<code>ab,ab*</code></p><p>​    <code>dp[i][j-1]</code>,表示<code>*</code>代表非空任何字符,例如<code>abcd,ab*</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 多一维的空间，因为求 dp[len - 1][j] 的时候需要知道 dp[len][j] 的情况，</span>        <span class="token comment" spellcheck="true">// 多一维的话，就可以把 对 dp[len - 1][j] 也写进循环了</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// dp[len][len] 代表两个空串是否匹配了，"" 和 "" ，当然是 true 了。</span>        dp<span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从 len 开始减少</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// dp[text.length()][pattern.length()] 已经进行了初始化</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//相比之前增加了判断是否等于 *</span>                <span class="token keyword">boolean</span> first_match <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">||</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span> <span class="token operator">||</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//将 * 跳过 和将字符匹配一个并且 pattern 不变两种情况</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> first_match <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> first_match <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="题目地址"><a href="#题目地址" class="headerlink" title=" 题目地址   "></a> 题目地址   </h2><p> <a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">LeetCode 第 44 题：通配符匹配.</a>                    </p>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 第 557 题：反转字符串中的单词</title>
      <link href="/2019/07/01/LeetCode%20%E7%AC%AC557%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/"/>
      <url>/2019/07/01/LeetCode%20%E7%AC%AC557%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目地址</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">LeetCode 第 557 题：反转字符串中的单词.</a></td><td><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/557-fan-zhuan-zi-fu-chuan-zhong-de-dan-ci-iii-ti-j/" target="_blank" rel="noopener">字符串处理</a></td></tr></tbody></table><h2 id="LeetCode-第-557-题：反转字符串中的单词"><a href="#LeetCode-第-557-题：反转字符串中的单词" class="headerlink" title="LeetCode 第 557 题：反转字符串中的单词"></a>LeetCode 第 557 题：反转字符串中的单词</h2><ul><li>空间设想<br><img src="http://ptyodd4up.bkt.clouddn.com/leecode711.png" alt="空间设想" title="设想.jpg"></li></ul><h3 id="一-利用StringBuffer-reverse-方法"><a href="#一-利用StringBuffer-reverse-方法" class="headerlink" title="一 . 利用StringBuffer reverse()方法"></a>一 . 利用StringBuffer reverse()方法</h3><ol><li>令n为旧字符序列的长度，即在执行反向方法之前字符串缓冲区中包含的字符序列。</li><li>新字符序列中索引k处的字符等于旧字符序列中索引n-k-1处的字符</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String soure<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String target <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//字符串拆分成数组</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> soure<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 利用StringBuffer.reverse() 将字符逆序</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> temp<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                target <span class="token operator">=</span> target <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                target <span class="token operator">=</span> target <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="二-利用数组双指针思想"><a href="#二-利用数组双指针思想" class="headerlink" title="二 . 利用数组双指针思想"></a>二 . 利用数组双指针思想</h3><ol><li>划分子数组</li><li>子数组双指针交换；</li><li>生成字符串</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将字符串转化为数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">char</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                    l<span class="token operator">++</span><span class="token punctuation">;</span>                    r<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                r <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            l<span class="token operator">++</span><span class="token punctuation">;</span>            r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>两次的执行结果</p></blockquote><p><img src="http://ptyodd4up.bkt.clouddn.com/leecode712.png" alt="执行结果比较" title="执行结果比较.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：K近邻算法</title>
      <link href="/2019/06/29/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9AK%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/29/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9AK%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法问题：K近邻算法-KNN"><a href="#经典算法问题：K近邻算法-KNN" class="headerlink" title="经典算法问题：K近邻算法(KNN)"></a>经典算法问题：K近邻算法(KNN)</h2><blockquote><p>K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p></blockquote><p><img src="http://ptyodd4up.bkt.clouddn.com/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.png" alt="K近邻算法" title="K近邻算法.jpg"></p><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h3><p>最简单最初级的分类器是将全部的训练数据所对应的类别都记录下来，当测试对象的属性和某个训练对象的属性完全匹配时，便可以对其进行分类。但是怎么可能所有测试对象都会找到与之完全匹配的训练对象呢，其次就是存在一个测试对象同时与多个训练对象匹配，导致一个训练对象被分到了多个类的问题，基于这些问题呢，就产生了KNN。KNN是通过测量不同特征值之间的距离进行分类。它的的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。K通常是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。</p><p>下面通过一个简单的例子说明一下：如下图，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如果K=3，由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。<br><img src="http://ptyodd4up.bkt.clouddn.com/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95-2.png" alt="案例" title="案例.jpg"></p><h3 id="二-欧氏距离-哈曼顿距离"><a href="#二-欧氏距离-哈曼顿距离" class="headerlink" title="二. 欧氏距离 / 哈曼顿距离"></a>二. 欧氏距离 / 哈曼顿距离</h3><p><img src="http://ptyodd4up.bkt.clouddn.com/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95-3.png" alt="欧氏距离  /  哈曼顿距离 " title=" 欧氏距离  /  哈曼顿距离.jpg"></p><h3 id="三-K-近邻算法（KNN）描述"><a href="#三-K-近邻算法（KNN）描述" class="headerlink" title="三. K-近邻算法（KNN）描述"></a>三. K-近邻算法（KNN）描述</h3><p>1）计算测试数据与各个训练数据之间的距离；</p><p>2）按照距离的递增关系进行排序；</p><p>3）选取距离最小的K个点；</p><p>4）确定前K个点所在类别的出现频率；</p><p>5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。</p><h3 id="四-代码"><a href="#四-代码" class="headerlink" title="四. 代码"></a>四. 代码</h3><p>Java 代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KNN</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * KNN数据模型     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">KNNModel</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> a<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> b<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> c<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> distince<span class="token punctuation">;</span>        String type<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">KNNModel</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">double</span> c<span class="token punctuation">,</span> String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 按距离排序         *         * @param arg         * @return         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>KNNModel arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>distince<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>distince<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 计算距离     *     * @param knnModelList     * @param i     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">calDistince</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> knnModelList<span class="token punctuation">,</span> KNNModel i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> distince<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>KNNModel m <span class="token operator">:</span> knnModelList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            distince <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>a <span class="token operator">-</span> m<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>a <span class="token operator">-</span> m<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>b <span class="token operator">-</span> m<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>b <span class="token operator">-</span> m<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>c <span class="token operator">-</span> m<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>c <span class="token operator">-</span> m<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m<span class="token punctuation">.</span>distince <span class="token operator">=</span> distince<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 找出前k个数据中分类最多的数据     *     * @param knnModelList     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">findMostData</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> knnModelList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> typeCountMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String type <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        Integer tempVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 统计分类个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>KNNModel model <span class="token operator">:</span> knnModelList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>typeCountMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                typeCountMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>type<span class="token punctuation">,</span> typeCountMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                typeCountMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>type<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 找出最多分类</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> entry <span class="token operator">:</span> typeCountMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> tempVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>                tempVal <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                type <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> type<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * KNN 算法的实现     *     * @param k     * @param knnModelList     * @param inputModel     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">calKNN</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> knnModelList<span class="token punctuation">,</span> KNNModel inputModel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1.计算距离"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">calDistince</span><span class="token punctuation">(</span>knnModelList<span class="token punctuation">,</span> inputModel<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2.按距离（近-->远）排序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>knnModelList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3.取前k个数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>knnModelList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            knnModelList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4.找出前k个数据中分类出现频率最大的数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String type <span class="token operator">=</span> <span class="token function">findMostData</span><span class="token punctuation">(</span>knnModelList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> type<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试KNN算法     *     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 准备数据</span>        List<span class="token operator">&lt;</span>KNNModel<span class="token operator">></span> knnModelList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>KNNModel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">3.1</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">3.1</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">5.4</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">6.3</span><span class="token punctuation">,</span> <span class="token number">4.1</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        knnModelList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">,</span> <span class="token number">10.0</span><span class="token punctuation">,</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预测数据</span>        KNNModel predictionData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KNNModel</span><span class="token punctuation">(</span><span class="token number">5.1</span><span class="token punctuation">,</span> <span class="token number">6.2</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token string">"NB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算</span>        String result <span class="token operator">=</span> <span class="token function">calKNN</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> knnModelList<span class="token punctuation">,</span> predictionData<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"预测结果："</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Python 代码</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token keyword">from</span> numpy <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> operator<span class="token keyword">def</span> <span class="token function">createDataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token string">'创建数据集'</span>    group<span class="token operator">=</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    labels<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> group<span class="token punctuation">,</span>labels<span class="token keyword">def</span> <span class="token function">classify</span><span class="token punctuation">(</span>inX<span class="token punctuation">,</span>dataSet<span class="token punctuation">,</span>labels<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 获取维度</span>    dataSetSize<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 训练数据集数量</span>    <span class="token keyword">print</span> dataSetSize    <span class="token keyword">print</span> tile<span class="token punctuation">(</span>inX<span class="token punctuation">,</span><span class="token punctuation">(</span>dataSetSize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    diffMat<span class="token operator">=</span>tile<span class="token punctuation">(</span>inX<span class="token punctuation">,</span><span class="token punctuation">(</span>dataSetSize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>dataSet  <span class="token comment" spellcheck="true"># 测试样本的各维度的差值</span>    <span class="token keyword">print</span> diffMat    sqDiffMat<span class="token operator">=</span>diffMat<span class="token operator">**</span><span class="token number">2</span>  <span class="token comment" spellcheck="true"># 平方计算</span>    <span class="token keyword">print</span> sqDiffMat    sqDistance<span class="token operator">=</span>sqDiffMat<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出每行的值</span>    <span class="token keyword">print</span> sqDistance    distances<span class="token operator">=</span>sqDistance<span class="token operator">**</span><span class="token number">0.5</span>   <span class="token comment" spellcheck="true"># 开方计算</span>    <span class="token keyword">print</span> distances    sortedDistances<span class="token operator">=</span>distances<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 排序 按距离从小到大 输出索引</span>    <span class="token keyword">print</span> sortedDistances    classCount<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>        voteIlabel<span class="token operator">=</span>labels<span class="token punctuation">[</span>sortedDistances<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        classCount<span class="token punctuation">[</span>voteIlabel<span class="token punctuation">]</span><span class="token operator">=</span>classCount<span class="token punctuation">.</span>get<span class="token punctuation">(</span>voteIlabel<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1.0</span>    sortedClassCount<span class="token operator">=</span>sorted<span class="token punctuation">(</span>classCount<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>key<span class="token operator">=</span>operator<span class="token punctuation">.</span>itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> sortedClassCount<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>group<span class="token punctuation">,</span>labels<span class="token operator">=</span>createDataSet<span class="token punctuation">(</span><span class="token punctuation">)</span>res<span class="token operator">=</span>classify<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>group<span class="token punctuation">,</span>labels<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span> res</code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分类算法 </tag>
            
            <tag> 经典算法问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：编辑距离算法</title>
      <link href="/2019/06/28/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/28/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法问题：编辑距离算法"><a href="#经典算法问题：编辑距离算法" class="headerlink" title="经典算法问题：编辑距离算法"></a>经典算法问题：编辑距离算法</h2><blockquote><p>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p></blockquote><p>例如将kitten一字转成sitting：</p><ol><li>sitten （k→s）</li><li>sittin （e→i）</li><li>sitting （→g）</li></ol><p>俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。因此也叫Levenshtein Distance。</p><h3 id="编辑距离递推公式"><a href="#编辑距离递推公式" class="headerlink" title="编辑距离递推公式"></a>编辑距离递推公式</h3><p>设字符串S，T长度分别为m, n，记S(i)为S从第1个字符到第i个字符之间的子串。S(0)表示空串，S(m)表示S本身。</p><p>因此，S和T间的编辑距离，可由S(i)和T(j)的编辑距离计算而来。<br><img src="http://ptyodd4up.bkt.clouddn.com/%E7%BC%96%E8%B7%9D%E7%AE%97%E6%B3%95.png" alt="Edit Distance" title="屏幕截图.png"></p><h3 id="基础案例"><a href="#基础案例" class="headerlink" title="基础案例"></a>基础案例</h3><ul><li>如果str1=”ivan”，str2=”ivan”，那么经过计算后等于 0。没有经过转换。相似度=1-0/Math.Max(str1.length,str2.length)=1</li><li>如果str1=”ivan1”，str2=”ivan2”，那么经过计算后等于1。str1的”1”转换”2”，转换了一个字符，所以距离是1，相似度=1-1/Math.Max(str1.length,str2.length)=0.8</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>DNA分析</li><li>拼字检查</li><li>语音辨识 </li><li>抄袭侦测</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>Java 代码</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">EditDistance</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> sources<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> targets<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sourceLen <span class="token operator">=</span> sources<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> targetLen <span class="token operator">=</span> targets<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>sourceLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>targetLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sourceLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> targetLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sourceLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> targetLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sources<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> targets<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//插入</span>                <span class="token keyword">int</span> insert <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//删除</span>                <span class="token keyword">int</span> delete <span class="token operator">=</span> d<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//替换</span>                <span class="token keyword">int</span> replace <span class="token operator">=</span> d<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>insert<span class="token punctuation">,</span> delete<span class="token punctuation">)</span> <span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>delete<span class="token punctuation">,</span> replace<span class="token punctuation">)</span> <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>delete<span class="token punctuation">,</span> replace<span class="token punctuation">)</span> <span class="token operator">:</span>                        Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>insert<span class="token punctuation">,</span> delete<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> d<span class="token punctuation">[</span>sourceLen<span class="token punctuation">]</span><span class="token punctuation">[</span>targetLen<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Python 代码</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">edit_distance</span><span class="token punctuation">(</span>sources<span class="token punctuation">,</span> targets<span class="token punctuation">)</span><span class="token punctuation">:</span>    len1 <span class="token operator">=</span> len<span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">;</span>    len2 <span class="token operator">=</span> len<span class="token punctuation">(</span>targets<span class="token punctuation">)</span><span class="token punctuation">;</span>    dp <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            delta <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> sources<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> targets<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">1</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> delta<span class="token punctuation">,</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span></code></pre><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p><code>Java 代码</code></p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> sources <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"打球"</span><span class="token punctuation">,</span><span class="token string">"爬山"</span><span class="token punctuation">,</span><span class="token string">"跑步"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> targets <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"打球"</span><span class="token punctuation">,</span><span class="token string">"爬山"</span><span class="token punctuation">,</span><span class="token string">"跑步"</span><span class="token punctuation">,</span><span class="token string">"看书"</span><span class="token punctuation">,</span><span class="token string">"游泳"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>返回结果 ：<span class="token number">2</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典算法问题 </tag>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：数组中的逆序对</title>
      <link href="/2019/06/27/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2019/06/27/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法问题：数组中的逆序对"><a href="#经典算法问题：数组中的逆序对" class="headerlink" title="经典算法问题：数组中的逆序对"></a>经典算法问题：数组中的逆序对</h2><blockquote><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</p></blockquote><p>  输入一个数组，求出这个数组中的逆序对的总数。</p><p><code>输入：[1,2,3,4,5,6,0] 输出：6</code></p><h3 id="思路1：使用定义"><a href="#思路1：使用定义" class="headerlink" title="思路1：使用定义"></a>思路1：使用定义</h3><p>挨个数出来，使用定义计算逆序数。不过时间复杂度是 O(n2)。</p><p>python代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><p>这种思路虽然很直接，但编写出错的概率很低，在没有在线评测系统的时候，它可以作为一个“正确的”参考答案，用以检验我们自己编写的算法是否正确。</p><h3 id="思路2：分治"><a href="#思路2：分治" class="headerlink" title="思路2：分治"></a>思路2：分治</h3><p>这道题最经典的思路是使用分治法计算，借助“归并排序”的分治思想，排好序以后，逆序对就求出来了，时间复杂度为 O(nlogn)。下面举例说明：例如：前有序数组：[2,3,5,8]，后有序数组：[4,6,7,12]。</p><p>做归并的时候，步骤如下：</p><p>第 1 步，2 先出列，2 比“后有序数组”中所有的元素都小，构成“顺序对”；</p><p>第 2 步，3 出列，3 比“后有序数组”中所有的元素都小，构成“顺序对”；</p><p>第 3 步，4 出列，关键的地方在这里，“前有序数组”中所有剩下的元素 [5,8] 比 4 都大，构成 2 个 “逆序对”；</p><p>第 4 步，5 出列，5 比“后有序数组”中所有剩下的元素都小，构成“顺序对”；</p><p>第 5 步，6 出列，“前有序数组”中所有剩下的元素 [8] 比 6 都大，构成 1 个“逆序对”；</p><p>第 6 步，7 出列，“前有序数组”中所有剩下的元素 [8] 比 7 都大，构成 1 个“逆序对”；</p><p>第 7 步，8 出列，8 比“后有序数组”中所有剩下的元素 [8] 都小，构成 1 个“顺序对”；</p><p>第 8 步，12 出列，此时“前有序数组”为空。</p><p>因此，我们只需要在“前有序数组”非空，且“后有序数组”中有元素出列的时候，即上面的第 3、5、6 步计算“逆序对”就可以了。</p><p>python代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inversePairs1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">inversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">count_inversion_pairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        在数组 nums 的区间 [l,r] 统计逆序对        :param nums:        :param l: 待统计数组的左边界，可以取到        :param r: 待统计数组的右边界，可以取到        :param temp:        :return:        """</span>        <span class="token comment" spellcheck="true"># 极端情况下，就是只有 1 个元素的时候</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> r<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        left_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        right_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        merge_pairs <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 代码走到这里的时候，</span>        <span class="token comment" spellcheck="true"># [l, mid] 已经完成了排序并且计算好逆序对</span>        <span class="token comment" spellcheck="true"># [mid + 1, r] 已经完成了排序并且计算好逆序对</span>        <span class="token comment" spellcheck="true"># 如果 nums[mid] &lt;= nums[mid + 1]，此时就不存在逆序对</span>        <span class="token comment" spellcheck="true"># 当 nums[mid] > nums[mid + 1] 的时候，就要继续计算逆序对</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 在归并的过程中计算逆序对</span>            merge_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>merge_and_count<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 走到这里有 nums[mid] &lt;= nums[mid + 1] 成立，已经是顺序结构</span>        <span class="token keyword">return</span> left_pairs <span class="token operator">+</span> right_pairs <span class="token operator">+</span> merge_pairs    <span class="token keyword">def</span> <span class="token function">merge_and_count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        前：[2,3,5,8]，后：[4,6,7,12]        我们只需要在后面数组元素出列的时候，数一数前面这个数组还剩下多少个数字，        因为"前"数组和"后"数组都有序，        因此，"前"数组剩下的元素个数 mid - i + 1 就是与"后"数组元素出列的这个元素构成的逆序对个数        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        i <span class="token operator">=</span> l        j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">></span> mid<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> j <span class="token operator">></span> r<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 不统计逆序对，只做排序</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">assert</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true"># 快就快在这里，一次可以数出一个区间的个数的逆序对</span>                <span class="token comment" spellcheck="true"># 例：[7,8,9][4,6,9]，4 与 7 以及 7 前面所有的数都构成逆序对</span>                res <span class="token operator">+=</span> <span class="token punctuation">(</span>mid <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>说明：归并两个有序数组的时候，我们要借助额外的辅助空间，为此可以全局使用一个和原始数组等长的辅助数组，否则每一次进入 merge 函数都要 new 新数组，开销很大。</p><p>上述解法的缺点是修改了原始数组，排序完成以后，逆序数就计算出来了。为此：（1）我们可以引入一个索引数组；（2）或者直接拷贝一个原始数组，这样就不用修改原始数组了。</p><h3 id="思路3：使用“树状数组”"><a href="#思路3：使用“树状数组”" class="headerlink" title="思路3：使用“树状数组”"></a>思路3：使用“树状数组”</h3><p>python 代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">class</span> <span class="token class-name">FenwickTree</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>size <span class="token operator">=</span> n                self<span class="token punctuation">.</span>tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">__lowbit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> index <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>index<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 单点更新：从下到上，最多到 size，可以取等</span>            <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> index <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>size<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>tree<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+=</span> delta                    index <span class="token operator">+=</span> self<span class="token punctuation">.</span>__lowbit<span class="token punctuation">(</span>index<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 区间查询：从上到下，最少到 1，可以取等</span>            <span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>                res <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">while</span> index <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> self<span class="token punctuation">.</span>tree<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                    index <span class="token operator">-=</span> self<span class="token punctuation">.</span>__lowbit<span class="token punctuation">(</span>index<span class="token punctuation">)</span>                <span class="token keyword">return</span> res        <span class="token comment" spellcheck="true"># 特判</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 原始数组去除重复以后从小到大排序</span>        s <span class="token operator">=</span> list<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 构建最小堆，因为从小到大一个一个拿出来，用堆比较合适</span>        <span class="token keyword">import</span> heapq        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 由数字查排名</span>        rank_map <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        index <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 不重复数字的个数</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            num <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            rank_map<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> index            index <span class="token operator">+=</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 树状数组只要不重复数字个数这么多空间就够了</span>        ft <span class="token operator">=</span> FenwickTree<span class="token punctuation">(</span>size<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 从后向前看，拿出一个数字来，就更新一下，然后向前查询比它小的个数</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            rank <span class="token operator">=</span> rank_map<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>            ft<span class="token punctuation">.</span>update<span class="token punctuation">(</span>rank<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            res <span class="token operator">+=</span> ft<span class="token punctuation">.</span>query<span class="token punctuation">(</span>rank <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>说明：中间将数字映射到排名是将原数组“离散化”，“离散化”的原因有 2 点：</p><p>1、树状数组我们看到，索引是从“1”开始的，我们不能保证我们的数组所有的元素都大于等于 1；</p><p>2、即使元素都大于等于“1”，为了节约树状数组的空间，我们将之“离散化”可以把原始的数都压缩到一个小区间。我说的有点不太清楚，这一点可以参考 树</p><hr><p>【算法】逆序对问题的四种解法（归并排序，BST，树状数组，线段树）及变形<br><a href="https://blog.csdn.net/haolexiao/article/details/54989306" target="_blank" rel="noopener">https://blog.csdn.net/haolexiao/article/details/54989306</a></p><p>leetcode 315 Count of Smaller Numbers After Self 以及 BST总结。<br><a href="https://segmentfault.com/a/1190000008233783" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008233783</a></p>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典算法问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法问题：赫夫曼树以及赫夫曼编码</title>
      <link href="/2019/06/26/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BB%A5%E5%8F%8A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
      <url>/2019/06/26/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%9A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BB%A5%E5%8F%8A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="赫夫曼树以及赫夫曼编码"><a href="#赫夫曼树以及赫夫曼编码" class="headerlink" title="赫夫曼树以及赫夫曼编码"></a>赫夫曼树以及赫夫曼编码</h3><p>是能使得给定的字符串编码成 0 1 串后长度最短的前缀编码。</p><p>1、编码问题：ASCII 码：一共 128 个：<a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="noopener">http://tool.oschina.net/commons?type=4</a></p><p>2、前缀码：前缀唯一</p><p>3、频率越高，编码越短</p><p>4、等长编码与不等长编码</p><p>5、构建出二叉树，左分支走 0 ，右分支走 1</p><p>6、非叶子结点上出现前缀，没有二义性</p><p>7、WLP 值一样。</p><p>参考资料：</p><p>《大话数据结构》</p><p>算法导论第 200 页：</p><p>殷人昆《数据结构》</p><p>赫夫曼树以及赫夫曼编码</p><ol><li>有多分支的时候，将常用的分支靠前，可以减少判断的次数，以提高效率，但是这样做需要对数据的分布有所了解，即要知道数据的频数；</li><li>应用于文件压缩，具体：重新编码（Huffman 编码），以减少存储和传输的空间大小；</li><li>Huffman 编码的基本思想，频数较多的靠前，类似与我们总是将常用的文字，设计成笔画较少，生僻字的笔画往往较多且复杂；</li><li>Huffman 树的特点：叶子结点带权，这个权就是我们上面说的频数；</li><li>一些定义：</li></ol><pre><code>（1）结点的路径长度：（2）树的路径长度：不限制是否是叶子结点（3）树的带权路径长度：所有叶子结点（4）树的带权路径长度 WPL：WPL 最小的二叉树称之为 Huffman 树，或者说是最优二叉树</code></pre><p>可以构造出不同的 Huffman 树（想到构造的过程其实是贪心算法，我们总是希望权值小的结点出现在较高的地方），但是 WLP 一定是一样的。</p><p>具体例子：<br>依据频数编码，将频数视为权值</p><p>前缀码：其实是反过来定义的，即不可能成为其它码的前缀的码，类比 Trie ，这是为了保证编码的唯一性，避免二义性。</p><p>左分支代表 0 ，右分支代表 1。</p><p>解码：（非等长编码）</p><p>发送方和接收方，必须要有同样的 Huffman 树。</p><p>参考资料</p><ol><li>《大话数据结构》</li><li>《算法导论》</li><li>灯笼大神的动态 Huffman 编码 Adaptive Huffman Encoding</li></ol>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典算法问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
